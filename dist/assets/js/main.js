/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/can-use-dom/index.js":
/*!*******************************************!*\
  !*** ./node_modules/can-use-dom/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
module.exports = canUseDOM;

/***/ }),

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
} // add a key to Array.prototype[@@unscopables]


module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt; // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};

/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;

var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

module.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js"); // `Array.prototype.{ indexOf, includes }` methods implementation


var createMethod = function createMethod(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");

var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

var createMethod = function createMethod(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);

        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push.call(target, value);
              // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-method-is-strict.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-method-uses-to-length.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-uses-to-length.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function thrower(it) {
  throw it;
};

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;
  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = {
      length: -1
    };
    if (ACCESSORS) defineProperty(O, 1, {
      enumerable: true,
      get: thrower
    });else O[1] = 1;
    method.call(O, argument0, argument1);
  });
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js"); // `Array.prototype.{ reduce, reduceRight }` methods implementation


var createMethod = function createMethod(IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) {
      if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
    }

    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

module.exports = function (originalArray, length) {
  var C;

  if (isArray(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js"); // call something on iterator step with safe closing on error


module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function next() {
      return {
        done: !!called++
      };
    },
    'return': function _return() {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR] = function () {
      return {
        next: function next() {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

/***/ }),

/***/ "./node_modules/core-js/internals/collection-weak.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-weak.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");

var getWeakData = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData;

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");

var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");

var ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");

var $has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.entries = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.entries.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) this.entries.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
      return that;
    };

    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && $has(data, state.id) && delete data[state.id];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && $has(data, state.id);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        var state = getInternalState(this);

        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return C;
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/collection.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");

var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");

var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function fixMethod(KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  }; // eslint-disable-next-line max-len


  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new

    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    }); // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);
  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");

var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;

var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function returnThis() {
  return this;
};

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");

var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function getIterationMethod(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));

    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      } // Set @@toStringTag to native iterators


      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;

    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  } // define iterator


  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }

  Iterators[NAME] = defaultIterator; // export additional methods

  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  }

  return methods;
};

/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js"); // Thank's IE8 for his funny defineProperty


module.exports = !fails(function () {
  return Object.defineProperty({}, 1, {
    get: function get() {
      return 7;
    }
  })[1] != 7;
});

/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';

/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;

/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/


module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (_typeof(sourceProperty) === _typeof(targetProperty)) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // TODO: Remove from `core-js@4` since it's moved to entry points

__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var SPECIES = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
}); // IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0

var REPLACE_KEEPS_$0 = function () {
  return 'a'.replace(/./, '$0') === '$0';
}();

var REPLACE = wellKnownSymbol('replace'); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string

var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }

  return false;
}(); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper


var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.

      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };

      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

/***/ }),

/***/ "./node_modules/core-js/internals/freezing.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/freezing.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});

/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js"); // optional / simple context binding


module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function aFunction(variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var check = function check(it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


module.exports = // eslint-disable-next-line no-undef
check((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self) || check((typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global) || // eslint-disable-next-line no-new-func
Function('return this')();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');

/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js"); // Thank's IE8 for his funny defineProperty


module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js"); // makes subclassing work correct for wrapped built-ins


module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if ( // it can work only with native `setPrototypeOf`
  setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};

/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;

/***/ }),

/***/ "./node_modules/core-js/internals/internal-metadata.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/internal-metadata.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function setMetadata(it) {
  defineProperty(it, METADATA, {
    value: {
      objectID: 'O' + ++id,
      // object ID
      weakData: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMetadata(it); // return object ID
  }

  return it[METADATA].objectID;
};

var getWeakData = function getWeakData(it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMetadata(it); // return the store of weak collections IDs
  }

  return it[METADATA].weakData;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function enforce(it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function getterFor(TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;

  set = function set(it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };

  get = function get(it) {
    return wmget.call(store, it) || {};
  };

  has = function has(it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function set(it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function get(it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };

  has = function has(it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype; // check on default Array iterator

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js"); // `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray


module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var replacement = /#|\.prototype\./;

var isForced = function isForced(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");

var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");

var Result = function Result(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      }

      return new Result(false);
    }

    iterator = iterFn.call(iterable);
  }

  next = iterator.next;

  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (_typeof(result) == 'object' && result && result instanceof Result) return result;
  }

  return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};

/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function returnThis() {
  return this;
}; // `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;
module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

/***/ }),

/***/ "./node_modules/core-js/internals/number-parse-int.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/number-parse-int.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;

var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var $parseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix

module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(String(string));
  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/core-js/internals/object-assign.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-assign.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");

var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign

module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({
    b: 1
  }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function get() {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;

  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : nativeAssign;

/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");

var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");

var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function EmptyConstructor() {
  /* empty */
};

var scriptTag = function scriptTag(content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak

  return temp;
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
}; // Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug


var activeXDocument;

var _NullProtoObject = function NullProtoObject() {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) {
    /* ignore */
  }

  _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;

  while (length--) {
    delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  }

  return _NullProtoObject();
};

hiddenKeys[IE_PROTO] = true; // `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _NullProtoObject();

  return Properties === undefined ? result : defineProperties(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js"); // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) {
    definePropertyModule.f(O, key = keys[index++], Properties[key]);
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");

var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof

module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectPrototype : null;
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    !has(hiddenKeys, key) && has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js"); // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys


module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js"); // `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */


module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js"); // `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");

var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js"); // all object keys, includes non-enumerable and symbols


module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global;

/***/ }),

/***/ "./node_modules/core-js/internals/redefine-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

module.exports = function (target, src, options) {
  for (var key in src) {
    redefine(target, key, src[key], options);
  }

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;

  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }

  if (O === global) {
    if (simple) O[key] = value;else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }

  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var classof = __webpack_require__(/*! ./classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var regexpExec = __webpack_require__(/*! ./regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js"); // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec


module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (_typeof(result) !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var stickyHelpers = __webpack_require__(/*! ./regexp-sticky-helpers */ "./node_modules/core-js/internals/regexp-sticky-helpers.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');

      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex); // Support anchored sticky behavior.

      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      } // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.


      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js"); // `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags


module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/internals/regexp-sticky-helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-sticky-helpers.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./fails */ "./node_modules/core-js/internals/fails.js"); // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.


function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});
exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  }

  return value;
};

/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});
module.exports = store;

/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.5',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js"); // `String.prototype.{ codePointAt, at }` methods implementation


var createMethod = function createMethod(CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod = function createMethod(TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js"); // `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject


module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js"); // `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL // eslint-disable-next-line no-undef
&& !Symbol.sham // eslint-disable-next-line no-undef
&& _typeof(Symbol.iterator) == 'symbol';

/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var _Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? _Symbol : _Symbol && _Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(_Symbol, name)) WellKnownSymbolsStore[name] = _Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  }

  return WellKnownSymbolsStore[name];
};

/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.filter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var $filter = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").filter;

var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // Edge 14- issue

var USES_TO_LENGTH = arrayMethodUsesToLength('filter'); // `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species

$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js"); // `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach


$({
  target: 'Array',
  proto: true,
  forced: [].forEach != forEach
}, {
  forEach: forEach
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator

module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

Iterators.Arguments = Iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var $reduce = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").left;

var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', {
  1: 0
}); // `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD || !USES_TO_LENGTH
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.function.name.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.name.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name

if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function get() {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es.object.assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js"); // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign


$({
  target: 'Object',
  stat: true,
  forced: Object.assign !== assign
}, {
  assign: assign
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js"); // `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, {
    unsafe: true
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-int.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var parseIntImplementation = __webpack_require__(/*! ../internals/number-parse-int */ "./node_modules/core-js/internals/number-parse-int.js"); // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix


$({
  global: true,
  forced: parseInt != parseIntImplementation
}, {
  parseInt: parseIntImplementation
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var exec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

$({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== exec
}, {
  exec: exec
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;

var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.string.match.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.match.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");

var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js"); // @@match logic


fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");

var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
      if (res.done) return res.value;
    }

    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-map.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-map.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");

var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");

var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var enforceIternalState = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce;

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var isExtensible = Object.isExtensible;
var InternalWeakMap;

var wrapper = function wrapper(init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}; // `WeakMap` constructor
// https://tc39.github.io/ecma262/#sec-weakmap-constructor


var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485

if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.REQUIRED = true;
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = WeakMapPrototype['delete'];
  var nativeHas = WeakMapPrototype.has;
  var nativeGet = WeakMapPrototype.get;
  var nativeSet = WeakMapPrototype.set;
  redefineAll(WeakMapPrototype, {
    'delete': function _delete(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete.call(this, key) || state.frozen['delete'](key);
      }

      return nativeDelete.call(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) || state.frozen.has(key);
      }

      return nativeHas.call(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
      }

      return nativeGet.call(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
      } else nativeSet.call(this, key, value);

      return this;
    }
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");

var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");

var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }

    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }

    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}

/***/ }),

/***/ "./node_modules/desandro-matches-selector/matches-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/desandro-matches-selector/matches-selector.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
(function (window, factory) {
  /*global define: false, module: false */
  'use strict'; // universal module definition

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory() {
  'use strict';

  var matchesMethod = function () {
    var ElemProto = window.Element.prototype; // check for the standard method name first

    if (ElemProto.matches) {
      return 'matches';
    } // check un-prefixed


    if (ElemProto.matchesSelector) {
      return 'matchesSelector';
    } // check vendor prefixes


    var prefixes = ['webkit', 'moz', 'ms', 'o'];

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';

      if (ElemProto[method]) {
        return method;
      }
    }
  }();

  return function matchesSelector(elem, selector) {
    return elem[matchesMethod](selector);
  };
});

/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */
(function (global, factory) {
  // universal module definition

  /* jshint strict: false */

  /* globals define, module, window */
  if (true) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(typeof window != 'undefined' ? window : this, function () {
  "use strict";

  function EvEmitter() {}

  var proto = EvEmitter.prototype;

  proto.on = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    } // set events hash


    var events = this._events = this._events || {}; // set listeners array

    var listeners = events[eventName] = events[eventName] || []; // only add once

    if (listeners.indexOf(listener) == -1) {
      listeners.push(listener);
    }

    return this;
  };

  proto.once = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    } // add event


    this.on(eventName, listener); // set once flag
    // set onceEvents hash

    var onceEvents = this._onceEvents = this._onceEvents || {}; // set onceListeners object

    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {}; // set flag

    onceListeners[listener] = true;
    return this;
  };

  proto.off = function (eventName, listener) {
    var listeners = this._events && this._events[eventName];

    if (!listeners || !listeners.length) {
      return;
    }

    var index = listeners.indexOf(listener);

    if (index != -1) {
      listeners.splice(index, 1);
    }

    return this;
  };

  proto.emitEvent = function (eventName, args) {
    var listeners = this._events && this._events[eventName];

    if (!listeners || !listeners.length) {
      return;
    } // copy over to avoid interference if .off() in listener


    listeners = listeners.slice(0);
    args = args || []; // once stuff

    var onceListeners = this._onceEvents && this._onceEvents[eventName];

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      var isOnce = onceListeners && onceListeners[listener];

      if (isOnce) {
        // remove listener
        // remove before trigger to prevent recursion
        this.off(eventName, listener); // unset once flag

        delete onceListeners[listener];
      } // trigger listener


      listener.apply(this, args);
    }

    return this;
  };

  proto.allOff = function () {
    delete this._events;
    delete this._onceEvents;
  };

  return EvEmitter;
});

/***/ }),

/***/ "./node_modules/fizzy-ui-utils/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/fizzy-ui-utils/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Fizzy UI utils v2.0.7
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */
(function (window, factory) {
  // universal module definition

  /*jshint strict: false */

  /*globals define, module, require */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! desandro-matches-selector/matches-selector */ "./node_modules/desandro-matches-selector/matches-selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (matchesSelector) {
      return factory(window, matchesSelector);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, matchesSelector) {
  'use strict';

  var utils = {}; // ----- extend ----- //
  // extends objects

  utils.extend = function (a, b) {
    for (var prop in b) {
      a[prop] = b[prop];
    }

    return a;
  }; // ----- modulo ----- //


  utils.modulo = function (num, div) {
    return (num % div + div) % div;
  }; // ----- makeArray ----- //


  var arraySlice = Array.prototype.slice; // turn element or nodeList into an array

  utils.makeArray = function (obj) {
    if (Array.isArray(obj)) {
      // use object if already an array
      return obj;
    } // return empty array if undefined or null. #6


    if (obj === null || obj === undefined) {
      return [];
    }

    var isArrayLike = _typeof(obj) == 'object' && typeof obj.length == 'number';

    if (isArrayLike) {
      // convert nodeList to array
      return arraySlice.call(obj);
    } // array of single index


    return [obj];
  }; // ----- removeFrom ----- //


  utils.removeFrom = function (ary, obj) {
    var index = ary.indexOf(obj);

    if (index != -1) {
      ary.splice(index, 1);
    }
  }; // ----- getParent ----- //


  utils.getParent = function (elem, selector) {
    while (elem.parentNode && elem != document.body) {
      elem = elem.parentNode;

      if (matchesSelector(elem, selector)) {
        return elem;
      }
    }
  }; // ----- getQueryElement ----- //
  // use element as selector string


  utils.getQueryElement = function (elem) {
    if (typeof elem == 'string') {
      return document.querySelector(elem);
    }

    return elem;
  }; // ----- handleEvent ----- //
  // enable .ontype to trigger from .addEventListener( elem, 'type' )


  utils.handleEvent = function (event) {
    var method = 'on' + event.type;

    if (this[method]) {
      this[method](event);
    }
  }; // ----- filterFindElements ----- //


  utils.filterFindElements = function (elems, selector) {
    // make array of elems
    elems = utils.makeArray(elems);
    var ffElems = [];
    elems.forEach(function (elem) {
      // check that elem is an actual element
      if (!(elem instanceof HTMLElement)) {
        return;
      } // add elem if no selector


      if (!selector) {
        ffElems.push(elem);
        return;
      } // filter & find items if we have a selector
      // filter


      if (matchesSelector(elem, selector)) {
        ffElems.push(elem);
      } // find children


      var childElems = elem.querySelectorAll(selector); // concat childElems to filterFound array

      for (var i = 0; i < childElems.length; i++) {
        ffElems.push(childElems[i]);
      }
    });
    return ffElems;
  }; // ----- debounceMethod ----- //


  utils.debounceMethod = function (_class, methodName, threshold) {
    threshold = threshold || 100; // original method

    var method = _class.prototype[methodName];
    var timeoutName = methodName + 'Timeout';

    _class.prototype[methodName] = function () {
      var timeout = this[timeoutName];
      clearTimeout(timeout);
      var args = arguments;

      var _this = this;

      this[timeoutName] = setTimeout(function () {
        method.apply(_this, args);
        delete _this[timeoutName];
      }, threshold);
    };
  }; // ----- docReady ----- //


  utils.docReady = function (callback) {
    var readyState = document.readyState;

    if (readyState == 'complete' || readyState == 'interactive') {
      // do async to allow for other scripts to run. metafizzy/flickity#441
      setTimeout(callback);
    } else {
      document.addEventListener('DOMContentLoaded', callback);
    }
  }; // ----- htmlInit ----- //
  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/


  utils.toDashed = function (str) {
    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {
      return $1 + '-' + $2;
    }).toLowerCase();
  };

  var console = window.console;
  /**
   * allow user to initialize classes via [data-namespace] or .js-namespace class
   * htmlInit( Widget, 'widgetName' )
   * options are parsed from data-namespace-options
   */

  utils.htmlInit = function (WidgetClass, namespace) {
    utils.docReady(function () {
      var dashedNamespace = utils.toDashed(namespace);
      var dataAttr = 'data-' + dashedNamespace;
      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');
      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);
      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
      var dataOptionsAttr = dataAttr + '-options';
      var jQuery = window.jQuery;
      elems.forEach(function (elem) {
        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
        var options;

        try {
          options = attr && JSON.parse(attr);
        } catch (error) {
          // log error, do not initialize
          if (console) {
            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);
          }

          return;
        } // initialize


        var instance = new WidgetClass(elem, options); // make available via $().data('namespace')

        if (jQuery) {
          jQuery.data(elem, namespace, instance);
        }
      });
    });
  }; // -----  ----- //


  return utils;
});

/***/ }),

/***/ "./node_modules/flickity/js/add-remove-cell.js":
/*!*****************************************************!*\
  !*** ./node_modules/flickity/js/add-remove-cell.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// add, remove cell
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, utils) {
      return factory(window, Flickity, utils);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, Flickity, utils) {
  'use strict'; // append cells to a document fragment

  function getCellsFragment(cells) {
    var fragment = document.createDocumentFragment();
    cells.forEach(function (cell) {
      fragment.appendChild(cell.element);
    });
    return fragment;
  } // -------------------------- add/remove cell prototype -------------------------- //


  var proto = Flickity.prototype;
  /**
   * Insert, prepend, or append cells
   * @param {Element, Array, NodeList} elems
   * @param {Integer} index
   */

  proto.insert = function (elems, index) {
    var cells = this._makeCells(elems);

    if (!cells || !cells.length) {
      return;
    }

    var len = this.cells.length; // default to append

    index = index === undefined ? len : index; // add cells with document fragment

    var fragment = getCellsFragment(cells); // append to slider

    var isAppend = index == len;

    if (isAppend) {
      this.slider.appendChild(fragment);
    } else {
      var insertCellElement = this.cells[index].element;
      this.slider.insertBefore(fragment, insertCellElement);
    } // add to this.cells


    if (index === 0) {
      // prepend, add to start
      this.cells = cells.concat(this.cells);
    } else if (isAppend) {
      // append, add to end
      this.cells = this.cells.concat(cells);
    } else {
      // insert in this.cells
      var endCells = this.cells.splice(index, len - index);
      this.cells = this.cells.concat(cells).concat(endCells);
    }

    this._sizeCells(cells);

    this.cellChange(index, true);
  };

  proto.append = function (elems) {
    this.insert(elems, this.cells.length);
  };

  proto.prepend = function (elems) {
    this.insert(elems, 0);
  };
  /**
   * Remove cells
   * @param {Element, Array, NodeList} elems
   */


  proto.remove = function (elems) {
    var cells = this.getCells(elems);

    if (!cells || !cells.length) {
      return;
    }

    var minCellIndex = this.cells.length - 1; // remove cells from collection & DOM

    cells.forEach(function (cell) {
      cell.remove();
      var index = this.cells.indexOf(cell);
      minCellIndex = Math.min(index, minCellIndex);
      utils.removeFrom(this.cells, cell);
    }, this);
    this.cellChange(minCellIndex, true);
  };
  /**
   * logic to be run after a cell's size changes
   * @param {Element} elem - cell's element
   */


  proto.cellSizeChange = function (elem) {
    var cell = this.getCell(elem);

    if (!cell) {
      return;
    }

    cell.getSize();
    var index = this.cells.indexOf(cell);
    this.cellChange(index);
  };
  /**
   * logic any time a cell is changed: added, removed, or size changed
   * @param {Integer} changedCellIndex - index of the changed cell, optional
   */


  proto.cellChange = function (changedCellIndex, isPositioningSlider) {
    var prevSelectedElem = this.selectedElement;

    this._positionCells(changedCellIndex);

    this._getWrapShiftCells();

    this.setGallerySize(); // update selectedIndex
    // try to maintain position & select previous selected element

    var cell = this.getCell(prevSelectedElem);

    if (cell) {
      this.selectedIndex = this.getCellSlideIndex(cell);
    }

    this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex);
    this.emitEvent('cellChange', [changedCellIndex]); // position slider

    this.select(this.selectedIndex); // do not position slider after lazy load

    if (isPositioningSlider) {
      this.positionSliderAtSelected();
    }
  }; // -----  ----- //


  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/animate.js":
/*!*********************************************!*\
  !*** ./node_modules/flickity/js/animate.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// animate
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (utils) {
      return factory(window, utils);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, utils) {
  'use strict'; // -------------------------- animate -------------------------- //

  var proto = {};

  proto.startAnimation = function () {
    if (this.isAnimating) {
      return;
    }

    this.isAnimating = true;
    this.restingFrames = 0;
    this.animate();
  };

  proto.animate = function () {
    this.applyDragForce();
    this.applySelectedAttraction();
    var previousX = this.x;
    this.integratePhysics();
    this.positionSlider();
    this.settle(previousX); // animate next frame

    if (this.isAnimating) {
      var _this = this;

      requestAnimationFrame(function animateFrame() {
        _this.animate();
      });
    }
  };

  proto.positionSlider = function () {
    var x = this.x; // wrap position around

    if (this.options.wrapAround && this.cells.length > 1) {
      x = utils.modulo(x, this.slideableWidth);
      x = x - this.slideableWidth;
      this.shiftWrapCells(x);
    }

    this.setTranslateX(x, this.isAnimating);
    this.dispatchScrollEvent();
  };

  proto.setTranslateX = function (x, is3d) {
    x += this.cursorPosition; // reverse if right-to-left and using transform

    x = this.options.rightToLeft ? -x : x;
    var translateX = this.getPositionValue(x); // use 3D tranforms for hardware acceleration on iOS
    // but use 2D when settled, for better font-rendering

    this.slider.style.transform = is3d ? 'translate3d(' + translateX + ',0,0)' : 'translateX(' + translateX + ')';
  };

  proto.dispatchScrollEvent = function () {
    var firstSlide = this.slides[0];

    if (!firstSlide) {
      return;
    }

    var positionX = -this.x - firstSlide.target;
    var progress = positionX / this.slidesWidth;
    this.dispatchEvent('scroll', null, [progress, positionX]);
  };

  proto.positionSliderAtSelected = function () {
    if (!this.cells.length) {
      return;
    }

    this.x = -this.selectedSlide.target;
    this.velocity = 0; // stop wobble

    this.positionSlider();
  };

  proto.getPositionValue = function (position) {
    if (this.options.percentPosition) {
      // percent position, round to 2 digits, like 12.34%
      return Math.round(position / this.size.innerWidth * 10000) * 0.01 + '%';
    } else {
      // pixel positioning
      return Math.round(position) + 'px';
    }
  };

  proto.settle = function (previousX) {
    // keep track of frames where x hasn't moved
    if (!this.isPointerDown && Math.round(this.x * 100) == Math.round(previousX * 100)) {
      this.restingFrames++;
    } // stop animating if resting for 3 or more frames


    if (this.restingFrames > 2) {
      this.isAnimating = false;
      delete this.isFreeScrolling; // render position with translateX when settled

      this.positionSlider();
      this.dispatchEvent('settle', null, [this.selectedIndex]);
    }
  };

  proto.shiftWrapCells = function (x) {
    // shift before cells
    var beforeGap = this.cursorPosition + x;

    this._shiftCells(this.beforeShiftCells, beforeGap, -1); // shift after cells


    var afterGap = this.size.innerWidth - (x + this.slideableWidth + this.cursorPosition);

    this._shiftCells(this.afterShiftCells, afterGap, 1);
  };

  proto._shiftCells = function (cells, gap, shift) {
    for (var i = 0; i < cells.length; i++) {
      var cell = cells[i];
      var cellShift = gap > 0 ? shift : 0;
      cell.wrapShift(cellShift);
      gap -= cell.size.outerWidth;
    }
  };

  proto._unshiftCells = function (cells) {
    if (!cells || !cells.length) {
      return;
    }

    for (var i = 0; i < cells.length; i++) {
      cells[i].wrapShift(0);
    }
  }; // -------------------------- physics -------------------------- //


  proto.integratePhysics = function () {
    this.x += this.velocity;
    this.velocity *= this.getFrictionFactor();
  };

  proto.applyForce = function (force) {
    this.velocity += force;
  };

  proto.getFrictionFactor = function () {
    return 1 - this.options[this.isFreeScrolling ? 'freeScrollFriction' : 'friction'];
  };

  proto.getRestingPosition = function () {
    // my thanks to Steven Wittens, who simplified this math greatly
    return this.x + this.velocity / (1 - this.getFrictionFactor());
  };

  proto.applyDragForce = function () {
    if (!this.isDraggable || !this.isPointerDown) {
      return;
    } // change the position to drag position by applying force


    var dragVelocity = this.dragX - this.x;
    var dragForce = dragVelocity - this.velocity;
    this.applyForce(dragForce);
  };

  proto.applySelectedAttraction = function () {
    // do not attract if pointer down or no slides
    var dragDown = this.isDraggable && this.isPointerDown;

    if (dragDown || this.isFreeScrolling || !this.slides.length) {
      return;
    }

    var distance = this.selectedSlide.target * -1 - this.x;
    var force = distance * this.options.selectedAttraction;
    this.applyForce(force);
  };

  return proto;
});

/***/ }),

/***/ "./node_modules/flickity/js/cell.js":
/*!******************************************!*\
  !*** ./node_modules/flickity/js/cell.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Flickity.Cell
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! get-size/get-size */ "./node_modules/get-size/get-size.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (getSize) {
      return factory(window, getSize);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, getSize) {
  'use strict';

  function Cell(elem, parent) {
    this.element = elem;
    this.parent = parent;
    this.create();
  }

  var proto = Cell.prototype;

  proto.create = function () {
    this.element.style.position = 'absolute';
    this.element.setAttribute('aria-hidden', 'true');
    this.x = 0;
    this.shift = 0;
  };

  proto.destroy = function () {
    // reset style
    this.unselect();
    this.element.style.position = '';
    var side = this.parent.originSide;
    this.element.style[side] = '';
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  proto.setPosition = function (x) {
    this.x = x;
    this.updateTarget();
    this.renderPosition(x);
  }; // setDefaultTarget v1 method, backwards compatibility, remove in v3


  proto.updateTarget = proto.setDefaultTarget = function () {
    var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';
    this.target = this.x + this.size[marginProperty] + this.size.width * this.parent.cellAlign;
  };

  proto.renderPosition = function (x) {
    // render position of cell with in slider
    var side = this.parent.originSide;
    this.element.style[side] = this.parent.getPositionValue(x);
  };

  proto.select = function () {
    this.element.classList.add('is-selected');
    this.element.removeAttribute('aria-hidden');
  };

  proto.unselect = function () {
    this.element.classList.remove('is-selected');
    this.element.setAttribute('aria-hidden', 'true');
  };
  /**
   * @param {Integer} factor - 0, 1, or -1
  **/


  proto.wrapShift = function (shift) {
    this.shift = shift;
    this.renderPosition(this.x + this.parent.slideableWidth * shift);
  };

  proto.remove = function () {
    this.element.parentNode.removeChild(this.element);
  };

  return Cell;
});

/***/ }),

/***/ "./node_modules/flickity/js/drag.js":
/*!******************************************!*\
  !*** ./node_modules/flickity/js/drag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// drag
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"), __webpack_require__(/*! unidragger/unidragger */ "./node_modules/unidragger/unidragger.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, Unidragger, utils) {
      return factory(window, Flickity, Unidragger, utils);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, Flickity, Unidragger, utils) {
  'use strict'; // ----- defaults ----- //

  utils.extend(Flickity.defaults, {
    draggable: '>1',
    dragThreshold: 3
  }); // ----- create ----- //

  Flickity.createMethods.push('_createDrag'); // -------------------------- drag prototype -------------------------- //

  var proto = Flickity.prototype;
  utils.extend(proto, Unidragger.prototype);
  proto._touchActionValue = 'pan-y'; // --------------------------  -------------------------- //

  var isTouch = ('createTouch' in document);
  var isTouchmoveScrollCanceled = false;

  proto._createDrag = function () {
    this.on('activate', this.onActivateDrag);
    this.on('uiChange', this._uiChangeDrag);
    this.on('deactivate', this.onDeactivateDrag);
    this.on('cellChange', this.updateDraggable); // TODO updateDraggable on resize? if groupCells & slides change
    // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior
    // #457, RubaXa/Sortable#973

    if (isTouch && !isTouchmoveScrollCanceled) {
      window.addEventListener('touchmove', function () {});
      isTouchmoveScrollCanceled = true;
    }
  };

  proto.onActivateDrag = function () {
    this.handles = [this.viewport];
    this.bindHandles();
    this.updateDraggable();
  };

  proto.onDeactivateDrag = function () {
    this.unbindHandles();
    this.element.classList.remove('is-draggable');
  };

  proto.updateDraggable = function () {
    // disable dragging if less than 2 slides. #278
    if (this.options.draggable == '>1') {
      this.isDraggable = this.slides.length > 1;
    } else {
      this.isDraggable = this.options.draggable;
    }

    if (this.isDraggable) {
      this.element.classList.add('is-draggable');
    } else {
      this.element.classList.remove('is-draggable');
    }
  }; // backwards compatibility


  proto.bindDrag = function () {
    this.options.draggable = true;
    this.updateDraggable();
  };

  proto.unbindDrag = function () {
    this.options.draggable = false;
    this.updateDraggable();
  };

  proto._uiChangeDrag = function () {
    delete this.isFreeScrolling;
  }; // -------------------------- pointer events -------------------------- //


  proto.pointerDown = function (event, pointer) {
    if (!this.isDraggable) {
      this._pointerDownDefault(event, pointer);

      return;
    }

    var isOkay = this.okayPointerDown(event);

    if (!isOkay) {
      return;
    }

    this._pointerDownPreventDefault(event);

    this.pointerDownFocus(event); // blur

    if (document.activeElement != this.element) {
      // do not blur if already focused
      this.pointerDownBlur();
    } // stop if it was moving


    this.dragX = this.x;
    this.viewport.classList.add('is-pointer-down'); // track scrolling

    this.pointerDownScroll = getScrollPosition();
    window.addEventListener('scroll', this);

    this._pointerDownDefault(event, pointer);
  }; // default pointerDown logic, used for staticClick


  proto._pointerDownDefault = function (event, pointer) {
    // track start event position
    // Safari 9 overrides pageX and pageY. These values needs to be copied. #779
    this.pointerDownPointer = {
      pageX: pointer.pageX,
      pageY: pointer.pageY
    }; // bind move and end events

    this._bindPostStartEvents(event);

    this.dispatchEvent('pointerDown', event, [pointer]);
  };

  var focusNodes = {
    INPUT: true,
    TEXTAREA: true,
    SELECT: true
  };

  proto.pointerDownFocus = function (event) {
    var isFocusNode = focusNodes[event.target.nodeName];

    if (!isFocusNode) {
      this.focus();
    }
  };

  proto._pointerDownPreventDefault = function (event) {
    var isTouchStart = event.type == 'touchstart';
    var isTouchPointer = event.pointerType == 'touch';
    var isFocusNode = focusNodes[event.target.nodeName];

    if (!isTouchStart && !isTouchPointer && !isFocusNode) {
      event.preventDefault();
    }
  }; // ----- move ----- //


  proto.hasDragStarted = function (moveVector) {
    return Math.abs(moveVector.x) > this.options.dragThreshold;
  }; // ----- up ----- //


  proto.pointerUp = function (event, pointer) {
    delete this.isTouchScrolling;
    this.viewport.classList.remove('is-pointer-down');
    this.dispatchEvent('pointerUp', event, [pointer]);

    this._dragPointerUp(event, pointer);
  };

  proto.pointerDone = function () {
    window.removeEventListener('scroll', this);
    delete this.pointerDownScroll;
  }; // -------------------------- dragging -------------------------- //


  proto.dragStart = function (event, pointer) {
    if (!this.isDraggable) {
      return;
    }

    this.dragStartPosition = this.x;
    this.startAnimation();
    window.removeEventListener('scroll', this);
    this.dispatchEvent('dragStart', event, [pointer]);
  };

  proto.pointerMove = function (event, pointer) {
    var moveVector = this._dragPointerMove(event, pointer);

    this.dispatchEvent('pointerMove', event, [pointer, moveVector]);

    this._dragMove(event, pointer, moveVector);
  };

  proto.dragMove = function (event, pointer, moveVector) {
    if (!this.isDraggable) {
      return;
    }

    event.preventDefault();
    this.previousDragX = this.dragX; // reverse if right-to-left

    var direction = this.options.rightToLeft ? -1 : 1;

    if (this.options.wrapAround) {
      // wrap around move. #589
      moveVector.x = moveVector.x % this.slideableWidth;
    }

    var dragX = this.dragStartPosition + moveVector.x * direction;

    if (!this.options.wrapAround && this.slides.length) {
      // slow drag
      var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);
      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;
      var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);
      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;
    }

    this.dragX = dragX;
    this.dragMoveTime = new Date();
    this.dispatchEvent('dragMove', event, [pointer, moveVector]);
  };

  proto.dragEnd = function (event, pointer) {
    if (!this.isDraggable) {
      return;
    }

    if (this.options.freeScroll) {
      this.isFreeScrolling = true;
    } // set selectedIndex based on where flick will end up


    var index = this.dragEndRestingSelect();

    if (this.options.freeScroll && !this.options.wrapAround) {
      // if free-scroll & not wrap around
      // do not free-scroll if going outside of bounding slides
      // so bounding slides can attract slider, and keep it in bounds
      var restingX = this.getRestingPosition();
      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;
    } else if (!this.options.freeScroll && index == this.selectedIndex) {
      // boost selection if selected index has not changed
      index += this.dragEndBoostSelect();
    }

    delete this.previousDragX; // apply selection
    // TODO refactor this, selecting here feels weird
    // HACK, set flag so dragging stays in correct direction

    this.isDragSelect = this.options.wrapAround;
    this.select(index);
    delete this.isDragSelect;
    this.dispatchEvent('dragEnd', event, [pointer]);
  };

  proto.dragEndRestingSelect = function () {
    var restingX = this.getRestingPosition(); // how far away from selected slide

    var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex)); // get closet resting going up and going down

    var positiveResting = this._getClosestResting(restingX, distance, 1);

    var negativeResting = this._getClosestResting(restingX, distance, -1); // use closer resting for wrap-around


    var index = positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;
    return index;
  };
  /**
   * given resting X and distance to selected cell
   * get the distance and index of the closest cell
   * @param {Number} restingX - estimated post-flick resting position
   * @param {Number} distance - distance to selected cell
   * @param {Integer} increment - +1 or -1, going up or down
   * @returns {Object} - { distance: {Number}, index: {Integer} }
   */


  proto._getClosestResting = function (restingX, distance, increment) {
    var index = this.selectedIndex;
    var minDistance = Infinity;
    var condition = this.options.contain && !this.options.wrapAround ? // if contain, keep going if distance is equal to minDistance
    function (d, md) {
      return d <= md;
    } : function (d, md) {
      return d < md;
    };

    while (condition(distance, minDistance)) {
      // measure distance to next cell
      index += increment;
      minDistance = distance;
      distance = this.getSlideDistance(-restingX, index);

      if (distance === null) {
        break;
      }

      distance = Math.abs(distance);
    }

    return {
      distance: minDistance,
      // selected was previous index
      index: index - increment
    };
  };
  /**
   * measure distance between x and a slide target
   * @param {Number} x
   * @param {Integer} index - slide index
   */


  proto.getSlideDistance = function (x, index) {
    var len = this.slides.length; // wrap around if at least 2 slides

    var isWrapAround = this.options.wrapAround && len > 1;
    var slideIndex = isWrapAround ? utils.modulo(index, len) : index;
    var slide = this.slides[slideIndex];

    if (!slide) {
      return null;
    } // add distance for wrap-around slides


    var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;
    return x - (slide.target + wrap);
  };

  proto.dragEndBoostSelect = function () {
    // do not boost if no previousDragX or dragMoveTime
    if (this.previousDragX === undefined || !this.dragMoveTime || // or if drag was held for 100 ms
    new Date() - this.dragMoveTime > 100) {
      return 0;
    }

    var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);
    var delta = this.previousDragX - this.dragX;

    if (distance > 0 && delta > 0) {
      // boost to next if moving towards the right, and positive velocity
      return 1;
    } else if (distance < 0 && delta < 0) {
      // boost to previous if moving towards the left, and negative velocity
      return -1;
    }

    return 0;
  }; // ----- staticClick ----- //


  proto.staticClick = function (event, pointer) {
    // get clickedCell, if cell was clicked
    var clickedCell = this.getParentCell(event.target);
    var cellElem = clickedCell && clickedCell.element;
    var cellIndex = clickedCell && this.cells.indexOf(clickedCell);
    this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);
  }; // ----- scroll ----- //


  proto.onscroll = function () {
    var scroll = getScrollPosition();
    var scrollMoveX = this.pointerDownScroll.x - scroll.x;
    var scrollMoveY = this.pointerDownScroll.y - scroll.y; // cancel click/tap if scroll is too much

    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {
      this._pointerDone();
    }
  }; // ----- utils ----- //


  function getScrollPosition() {
    return {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  } // -----  ----- //


  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/flickity.js":
/*!**********************************************!*\
  !*** ./node_modules/flickity/js/flickity.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Flickity main
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js"), __webpack_require__(/*! get-size/get-size */ "./node_modules/get-size/get-size.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js"), __webpack_require__(/*! ./cell */ "./node_modules/flickity/js/cell.js"), __webpack_require__(/*! ./slide */ "./node_modules/flickity/js/slide.js"), __webpack_require__(/*! ./animate */ "./node_modules/flickity/js/animate.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {
      return factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var _Flickity; }
})(window, function factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {
  'use strict'; // vars

  var jQuery = window.jQuery;
  var getComputedStyle = window.getComputedStyle;
  var console = window.console;

  function moveElements(elems, toElem) {
    elems = utils.makeArray(elems);

    while (elems.length) {
      toElem.appendChild(elems.shift());
    }
  } // -------------------------- Flickity -------------------------- //
  // globally unique identifiers


  var GUID = 0; // internal store of all Flickity intances

  var instances = {};

  function Flickity(element, options) {
    var queryElement = utils.getQueryElement(element);

    if (!queryElement) {
      if (console) {
        console.error('Bad element for Flickity: ' + (queryElement || element));
      }

      return;
    }

    this.element = queryElement; // do not initialize twice on same element

    if (this.element.flickityGUID) {
      var instance = instances[this.element.flickityGUID];
      instance.option(options);
      return instance;
    } // add jQuery


    if (jQuery) {
      this.$element = jQuery(this.element);
    } // options


    this.options = utils.extend({}, this.constructor.defaults);
    this.option(options); // kick things off

    this._create();
  }

  Flickity.defaults = {
    accessibility: true,
    // adaptiveHeight: false,
    cellAlign: 'center',
    // cellSelector: undefined,
    // contain: false,
    freeScrollFriction: 0.075,
    // friction when free-scrolling
    friction: 0.28,
    // friction when selecting
    namespaceJQueryEvents: true,
    // initialIndex: 0,
    percentPosition: true,
    resize: true,
    selectedAttraction: 0.025,
    setGallerySize: true // watchCSS: false,
    // wrapAround: false

  }; // hash of methods triggered on _create()

  Flickity.createMethods = [];
  var proto = Flickity.prototype; // inherit EventEmitter

  utils.extend(proto, EvEmitter.prototype);

  proto._create = function () {
    // add id for Flickity.data
    var id = this.guid = ++GUID;
    this.element.flickityGUID = id; // expando

    instances[id] = this; // associate via id
    // initial properties

    this.selectedIndex = 0; // how many frames slider has been in same position

    this.restingFrames = 0; // initial physics properties

    this.x = 0;
    this.velocity = 0;
    this.originSide = this.options.rightToLeft ? 'right' : 'left'; // create viewport & slider

    this.viewport = document.createElement('div');
    this.viewport.className = 'flickity-viewport';

    this._createSlider();

    if (this.options.resize || this.options.watchCSS) {
      window.addEventListener('resize', this);
    } // add listeners from on option


    for (var eventName in this.options.on) {
      var listener = this.options.on[eventName];
      this.on(eventName, listener);
    }

    Flickity.createMethods.forEach(function (method) {
      this[method]();
    }, this);

    if (this.options.watchCSS) {
      this.watchCSS();
    } else {
      this.activate();
    }
  };
  /**
   * set options
   * @param {Object} opts
   */


  proto.option = function (opts) {
    utils.extend(this.options, opts);
  };

  proto.activate = function () {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.element.classList.add('flickity-enabled');

    if (this.options.rightToLeft) {
      this.element.classList.add('flickity-rtl');
    }

    this.getSize(); // move initial cell elements so they can be loaded as cells

    var cellElems = this._filterFindCellElements(this.element.children);

    moveElements(cellElems, this.slider);
    this.viewport.appendChild(this.slider);
    this.element.appendChild(this.viewport); // get cells from children

    this.reloadCells();

    if (this.options.accessibility) {
      // allow element to focusable
      this.element.tabIndex = 0; // listen for key presses

      this.element.addEventListener('keydown', this);
    }

    this.emitEvent('activate');
    this.selectInitialIndex(); // flag for initial activation, for using initialIndex

    this.isInitActivated = true; // ready event. #493

    this.dispatchEvent('ready');
  }; // slider positions the cells


  proto._createSlider = function () {
    // slider element does all the positioning
    var slider = document.createElement('div');
    slider.className = 'flickity-slider';
    slider.style[this.originSide] = 0;
    this.slider = slider;
  };

  proto._filterFindCellElements = function (elems) {
    return utils.filterFindElements(elems, this.options.cellSelector);
  }; // goes through all children


  proto.reloadCells = function () {
    // collection of item elements
    this.cells = this._makeCells(this.slider.children);
    this.positionCells();

    this._getWrapShiftCells();

    this.setGallerySize();
  };
  /**
   * turn elements into Flickity.Cells
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - collection of new Flickity Cells
   */


  proto._makeCells = function (elems) {
    var cellElems = this._filterFindCellElements(elems); // create new Flickity for collection


    var cells = cellElems.map(function (cellElem) {
      return new Cell(cellElem, this);
    }, this);
    return cells;
  };

  proto.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  proto.getLastSlide = function () {
    return this.slides[this.slides.length - 1];
  }; // positions all cells


  proto.positionCells = function () {
    // size all cells
    this._sizeCells(this.cells); // position all cells


    this._positionCells(0);
  };
  /**
   * position certain cells
   * @param {Integer} index - which cell to start with
   */


  proto._positionCells = function (index) {
    index = index || 0; // also measure maxCellHeight
    // start 0 if positioning all cells

    this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
    var cellX = 0; // get cellX

    if (index > 0) {
      var startCell = this.cells[index - 1];
      cellX = startCell.x + startCell.size.outerWidth;
    }

    var len = this.cells.length;

    for (var i = index; i < len; i++) {
      var cell = this.cells[i];
      cell.setPosition(cellX);
      cellX += cell.size.outerWidth;
      this.maxCellHeight = Math.max(cell.size.outerHeight, this.maxCellHeight);
    } // keep track of cellX for wrap-around


    this.slideableWidth = cellX; // slides

    this.updateSlides(); // contain slides target

    this._containSlides(); // update slidesWidth


    this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;
  };
  /**
   * cell.getSize() on multiple cells
   * @param {Array} cells
   */


  proto._sizeCells = function (cells) {
    cells.forEach(function (cell) {
      cell.getSize();
    });
  }; // --------------------------  -------------------------- //


  proto.updateSlides = function () {
    this.slides = [];

    if (!this.cells.length) {
      return;
    }

    var slide = new Slide(this);
    this.slides.push(slide);
    var isOriginLeft = this.originSide == 'left';
    var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';

    var canCellFit = this._getCanCellFit();

    this.cells.forEach(function (cell, i) {
      // just add cell if first cell in slide
      if (!slide.cells.length) {
        slide.addCell(cell);
        return;
      }

      var slideWidth = slide.outerWidth - slide.firstMargin + (cell.size.outerWidth - cell.size[nextMargin]);

      if (canCellFit.call(this, i, slideWidth)) {
        slide.addCell(cell);
      } else {
        // doesn't fit, new slide
        slide.updateTarget();
        slide = new Slide(this);
        this.slides.push(slide);
        slide.addCell(cell);
      }
    }, this); // last slide

    slide.updateTarget(); // update .selectedSlide

    this.updateSelectedSlide();
  };

  proto._getCanCellFit = function () {
    var groupCells = this.options.groupCells;

    if (!groupCells) {
      return function () {
        return false;
      };
    } else if (typeof groupCells == 'number') {
      // group by number. 3 -> [0,1,2], [3,4,5], ...
      var number = parseInt(groupCells, 10);
      return function (i) {
        return i % number !== 0;
      };
    } // default, group by width of slide
    // parse '75%


    var percentMatch = typeof groupCells == 'string' && groupCells.match(/^(\d+)%$/);
    var percent = percentMatch ? parseInt(percentMatch[1], 10) / 100 : 1;
    return function (i, slideWidth) {
      return slideWidth <= (this.size.innerWidth + 1) * percent;
    };
  }; // alias _init for jQuery plugin .flickity()


  proto._init = proto.reposition = function () {
    this.positionCells();
    this.positionSliderAtSelected();
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
    this.setCellAlign();
    this.cursorPosition = this.size.innerWidth * this.cellAlign;
  };

  var cellAlignShorthands = {
    // cell align, then based on origin side
    center: {
      left: 0.5,
      right: 0.5
    },
    left: {
      left: 0,
      right: 1
    },
    right: {
      right: 0,
      left: 1
    }
  };

  proto.setCellAlign = function () {
    var shorthand = cellAlignShorthands[this.options.cellAlign];
    this.cellAlign = shorthand ? shorthand[this.originSide] : this.options.cellAlign;
  };

  proto.setGallerySize = function () {
    if (this.options.setGallerySize) {
      var height = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;
      this.viewport.style.height = height + 'px';
    }
  };

  proto._getWrapShiftCells = function () {
    // only for wrap-around
    if (!this.options.wrapAround) {
      return;
    } // unshift previous cells


    this._unshiftCells(this.beforeShiftCells);

    this._unshiftCells(this.afterShiftCells); // get before cells
    // initial gap


    var gapX = this.cursorPosition;
    var cellIndex = this.cells.length - 1;
    this.beforeShiftCells = this._getGapCells(gapX, cellIndex, -1); // get after cells
    // ending gap between last cell and end of gallery viewport

    gapX = this.size.innerWidth - this.cursorPosition; // start cloning at first cell, working forwards

    this.afterShiftCells = this._getGapCells(gapX, 0, 1);
  };

  proto._getGapCells = function (gapX, cellIndex, increment) {
    // keep adding cells until the cover the initial gap
    var cells = [];

    while (gapX > 0) {
      var cell = this.cells[cellIndex];

      if (!cell) {
        break;
      }

      cells.push(cell);
      cellIndex += increment;
      gapX -= cell.size.outerWidth;
    }

    return cells;
  }; // ----- contain ----- //
  // contain cell targets so no excess sliding


  proto._containSlides = function () {
    if (!this.options.contain || this.options.wrapAround || !this.cells.length) {
      return;
    }

    var isRightToLeft = this.options.rightToLeft;
    var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';
    var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';
    var contentWidth = this.slideableWidth - this.getLastCell().size[endMargin]; // content is less than gallery size

    var isContentSmaller = contentWidth < this.size.innerWidth; // bounds

    var beginBound = this.cursorPosition + this.cells[0].size[beginMargin];
    var endBound = contentWidth - this.size.innerWidth * (1 - this.cellAlign); // contain each cell target

    this.slides.forEach(function (slide) {
      if (isContentSmaller) {
        // all cells fit inside gallery
        slide.target = contentWidth * this.cellAlign;
      } else {
        // contain to bounds
        slide.target = Math.max(slide.target, beginBound);
        slide.target = Math.min(slide.target, endBound);
      }
    }, this);
  }; // -----  ----- //

  /**
   * emits events via eventEmitter and jQuery events
   * @param {String} type - name of event
   * @param {Event} event - original event
   * @param {Array} args - extra arguments
   */


  proto.dispatchEvent = function (type, event, args) {
    var emitArgs = event ? [event].concat(args) : args;
    this.emitEvent(type, emitArgs);

    if (jQuery && this.$element) {
      // default trigger with type if no event
      type += this.options.namespaceJQueryEvents ? '.flickity' : '';
      var $event = type;

      if (event) {
        // create jQuery event
        var jQEvent = jQuery.Event(event);
        jQEvent.type = type;
        $event = jQEvent;
      }

      this.$element.trigger($event, args);
    }
  }; // -------------------------- select -------------------------- //

  /**
   * @param {Integer} index - index of the slide
   * @param {Boolean} isWrap - will wrap-around to last/first if at the end
   * @param {Boolean} isInstant - will immediately set position at selected cell
   */


  proto.select = function (index, isWrap, isInstant) {
    if (!this.isActive) {
      return;
    }

    index = parseInt(index, 10);

    this._wrapSelect(index);

    if (this.options.wrapAround || isWrap) {
      index = utils.modulo(index, this.slides.length);
    } // bail if invalid index


    if (!this.slides[index]) {
      return;
    }

    var prevIndex = this.selectedIndex;
    this.selectedIndex = index;
    this.updateSelectedSlide();

    if (isInstant) {
      this.positionSliderAtSelected();
    } else {
      this.startAnimation();
    }

    if (this.options.adaptiveHeight) {
      this.setGallerySize();
    } // events


    this.dispatchEvent('select', null, [index]); // change event if new index

    if (index != prevIndex) {
      this.dispatchEvent('change', null, [index]);
    } // old v1 event name, remove in v3


    this.dispatchEvent('cellSelect');
  }; // wraps position for wrapAround, to move to closest slide. #113


  proto._wrapSelect = function (index) {
    var len = this.slides.length;
    var isWrapping = this.options.wrapAround && len > 1;

    if (!isWrapping) {
      return index;
    }

    var wrapIndex = utils.modulo(index, len); // go to shortest

    var delta = Math.abs(wrapIndex - this.selectedIndex);
    var backWrapDelta = Math.abs(wrapIndex + len - this.selectedIndex);
    var forewardWrapDelta = Math.abs(wrapIndex - len - this.selectedIndex);

    if (!this.isDragSelect && backWrapDelta < delta) {
      index += len;
    } else if (!this.isDragSelect && forewardWrapDelta < delta) {
      index -= len;
    } // wrap position so slider is within normal area


    if (index < 0) {
      this.x -= this.slideableWidth;
    } else if (index >= len) {
      this.x += this.slideableWidth;
    }
  };

  proto.previous = function (isWrap, isInstant) {
    this.select(this.selectedIndex - 1, isWrap, isInstant);
  };

  proto.next = function (isWrap, isInstant) {
    this.select(this.selectedIndex + 1, isWrap, isInstant);
  };

  proto.updateSelectedSlide = function () {
    var slide = this.slides[this.selectedIndex]; // selectedIndex could be outside of slides, if triggered before resize()

    if (!slide) {
      return;
    } // unselect previous selected slide


    this.unselectSelectedSlide(); // update new selected slide

    this.selectedSlide = slide;
    slide.select();
    this.selectedCells = slide.cells;
    this.selectedElements = slide.getCellElements(); // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility
    // Remove in v3?

    this.selectedCell = slide.cells[0];
    this.selectedElement = this.selectedElements[0];
  };

  proto.unselectSelectedSlide = function () {
    if (this.selectedSlide) {
      this.selectedSlide.unselect();
    }
  };

  proto.selectInitialIndex = function () {
    var initialIndex = this.options.initialIndex; // already activated, select previous selectedIndex

    if (this.isInitActivated) {
      this.select(this.selectedIndex, false, true);
      return;
    } // select with selector string


    if (initialIndex && typeof initialIndex == 'string') {
      var cell = this.queryCell(initialIndex);

      if (cell) {
        this.selectCell(initialIndex, false, true);
        return;
      }
    }

    var index = 0; // select with number

    if (initialIndex && this.slides[initialIndex]) {
      index = initialIndex;
    } // select instantly


    this.select(index, false, true);
  };
  /**
   * select slide from number or cell element
   * @param {Element or Number} elem
   */


  proto.selectCell = function (value, isWrap, isInstant) {
    // get cell
    var cell = this.queryCell(value);

    if (!cell) {
      return;
    }

    var index = this.getCellSlideIndex(cell);
    this.select(index, isWrap, isInstant);
  };

  proto.getCellSlideIndex = function (cell) {
    // get index of slides that has cell
    for (var i = 0; i < this.slides.length; i++) {
      var slide = this.slides[i];
      var index = slide.cells.indexOf(cell);

      if (index != -1) {
        return i;
      }
    }
  }; // -------------------------- get cells -------------------------- //

  /**
   * get Flickity.Cell, given an Element
   * @param {Element} elem
   * @returns {Flickity.Cell} item
   */


  proto.getCell = function (elem) {
    // loop through cells to get the one that matches
    for (var i = 0; i < this.cells.length; i++) {
      var cell = this.cells[i];

      if (cell.element == elem) {
        return cell;
      }
    }
  };
  /**
   * get collection of Flickity.Cells, given Elements
   * @param {Element, Array, NodeList} elems
   * @returns {Array} cells - Flickity.Cells
   */


  proto.getCells = function (elems) {
    elems = utils.makeArray(elems);
    var cells = [];
    elems.forEach(function (elem) {
      var cell = this.getCell(elem);

      if (cell) {
        cells.push(cell);
      }
    }, this);
    return cells;
  };
  /**
   * get cell elements
   * @returns {Array} cellElems
   */


  proto.getCellElements = function () {
    return this.cells.map(function (cell) {
      return cell.element;
    });
  };
  /**
   * get parent cell from an element
   * @param {Element} elem
   * @returns {Flickit.Cell} cell
   */


  proto.getParentCell = function (elem) {
    // first check if elem is cell
    var cell = this.getCell(elem);

    if (cell) {
      return cell;
    } // try to get parent cell elem


    elem = utils.getParent(elem, '.flickity-slider > *');
    return this.getCell(elem);
  };
  /**
   * get cells adjacent to a slide
   * @param {Integer} adjCount - number of adjacent slides
   * @param {Integer} index - index of slide to start
   * @returns {Array} cells - array of Flickity.Cells
   */


  proto.getAdjacentCellElements = function (adjCount, index) {
    if (!adjCount) {
      return this.selectedSlide.getCellElements();
    }

    index = index === undefined ? this.selectedIndex : index;
    var len = this.slides.length;

    if (1 + adjCount * 2 >= len) {
      return this.getCellElements();
    }

    var cellElems = [];

    for (var i = index - adjCount; i <= index + adjCount; i++) {
      var slideIndex = this.options.wrapAround ? utils.modulo(i, len) : i;
      var slide = this.slides[slideIndex];

      if (slide) {
        cellElems = cellElems.concat(slide.getCellElements());
      }
    }

    return cellElems;
  };
  /**
   * select slide from number or cell element
   * @param {Element, Selector String, or Number} selector
   */


  proto.queryCell = function (selector) {
    if (typeof selector == 'number') {
      // use number as index
      return this.cells[selector];
    }

    if (typeof selector == 'string') {
      // do not select invalid selectors from hash: #123, #/. #791
      if (selector.match(/^[#\.]?[\d\/]/)) {
        return;
      } // use string as selector, get element


      selector = this.element.querySelector(selector);
    } // get cell from element


    return this.getCell(selector);
  }; // -------------------------- events -------------------------- //


  proto.uiChange = function () {
    this.emitEvent('uiChange');
  }; // keep focus on element when child UI elements are clicked


  proto.childUIPointerDown = function (event) {
    // HACK iOS does not allow touch events to bubble up?!
    if (event.type != 'touchstart') {
      event.preventDefault();
    }

    this.focus();
  }; // ----- resize ----- //


  proto.onresize = function () {
    this.watchCSS();
    this.resize();
  };

  utils.debounceMethod(Flickity, 'onresize', 150);

  proto.resize = function () {
    if (!this.isActive) {
      return;
    }

    this.getSize(); // wrap values

    if (this.options.wrapAround) {
      this.x = utils.modulo(this.x, this.slideableWidth);
    }

    this.positionCells();

    this._getWrapShiftCells();

    this.setGallerySize();
    this.emitEvent('resize'); // update selected index for group slides, instant
    // TODO: position can be lost between groups of various numbers

    var selectedElement = this.selectedElements && this.selectedElements[0];
    this.selectCell(selectedElement, false, true);
  }; // watches the :after property, activates/deactivates


  proto.watchCSS = function () {
    var watchOption = this.options.watchCSS;

    if (!watchOption) {
      return;
    }

    var afterContent = getComputedStyle(this.element, ':after').content; // activate if :after { content: 'flickity' }

    if (afterContent.indexOf('flickity') != -1) {
      this.activate();
    } else {
      this.deactivate();
    }
  }; // ----- keydown ----- //
  // go previous/next if left/right keys pressed


  proto.onkeydown = function (event) {
    // only work if element is in focus
    var isNotFocused = document.activeElement && document.activeElement != this.element;

    if (!this.options.accessibility || isNotFocused) {
      return;
    }

    var handler = Flickity.keyboardHandlers[event.keyCode];

    if (handler) {
      handler.call(this);
    }
  };

  Flickity.keyboardHandlers = {
    // left arrow
    37: function _() {
      var leftMethod = this.options.rightToLeft ? 'next' : 'previous';
      this.uiChange();
      this[leftMethod]();
    },
    // right arrow
    39: function _() {
      var rightMethod = this.options.rightToLeft ? 'previous' : 'next';
      this.uiChange();
      this[rightMethod]();
    }
  }; // ----- focus ----- //

  proto.focus = function () {
    // TODO remove scrollTo once focus options gets more support
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Browser_compatibility
    var prevScrollY = window.pageYOffset;
    this.element.focus({
      preventScroll: true
    }); // hack to fix scroll jump after focus, #76

    if (window.pageYOffset != prevScrollY) {
      window.scrollTo(window.pageXOffset, prevScrollY);
    }
  }; // -------------------------- destroy -------------------------- //
  // deactivate all Flickity functionality, but keep stuff available


  proto.deactivate = function () {
    if (!this.isActive) {
      return;
    }

    this.element.classList.remove('flickity-enabled');
    this.element.classList.remove('flickity-rtl');
    this.unselectSelectedSlide(); // destroy cells

    this.cells.forEach(function (cell) {
      cell.destroy();
    });
    this.element.removeChild(this.viewport); // move child elements back into element

    moveElements(this.slider.children, this.element);

    if (this.options.accessibility) {
      this.element.removeAttribute('tabIndex');
      this.element.removeEventListener('keydown', this);
    } // set flags


    this.isActive = false;
    this.emitEvent('deactivate');
  };

  proto.destroy = function () {
    this.deactivate();
    window.removeEventListener('resize', this);
    this.allOff();
    this.emitEvent('destroy');

    if (jQuery && this.$element) {
      jQuery.removeData(this.element, 'flickity');
    }

    delete this.element.flickityGUID;
    delete instances[this.guid];
  }; // -------------------------- prototype -------------------------- //


  utils.extend(proto, animatePrototype); // -------------------------- extras -------------------------- //

  /**
   * get Flickity instance from element
   * @param {Element} elem
   * @returns {Flickity}
   */

  Flickity.data = function (elem) {
    elem = utils.getQueryElement(elem);
    var id = elem && elem.flickityGUID;
    return id && instances[id];
  };

  utils.htmlInit(Flickity, 'flickity');

  if (jQuery && jQuery.bridget) {
    jQuery.bridget('flickity', Flickity);
  } // set internal jQuery, for Webpack + jQuery v3, #478


  Flickity.setJQuery = function (jq) {
    jQuery = jq;
  };

  Flickity.Cell = Cell;
  Flickity.Slide = Slide;
  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/index.js":
/*!*******************************************!*\
  !*** ./node_modules/flickity/js/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Flickity v2.2.1
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2019 Metafizzy
 */
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"), __webpack_require__(/*! ./drag */ "./node_modules/flickity/js/drag.js"), __webpack_require__(/*! ./prev-next-button */ "./node_modules/flickity/js/prev-next-button.js"), __webpack_require__(/*! ./page-dots */ "./node_modules/flickity/js/page-dots.js"), __webpack_require__(/*! ./player */ "./node_modules/flickity/js/player.js"), __webpack_require__(/*! ./add-remove-cell */ "./node_modules/flickity/js/add-remove-cell.js"), __webpack_require__(/*! ./lazyload */ "./node_modules/flickity/js/lazyload.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(Flickity) {
  /*jshint strict: false*/
  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/lazyload.js":
/*!**********************************************!*\
  !*** ./node_modules/flickity/js/lazyload.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// lazyload
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, utils) {
      return factory(window, Flickity, utils);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, Flickity, utils) {
  'use strict';

  Flickity.createMethods.push('_createLazyload');
  var proto = Flickity.prototype;

  proto._createLazyload = function () {
    this.on('select', this.lazyLoad);
  };

  proto.lazyLoad = function () {
    var lazyLoad = this.options.lazyLoad;

    if (!lazyLoad) {
      return;
    } // get adjacent cells, use lazyLoad option for adjacent count


    var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
    var cellElems = this.getAdjacentCellElements(adjCount); // get lazy images in those cells

    var lazyImages = [];
    cellElems.forEach(function (cellElem) {
      var lazyCellImages = getCellLazyImages(cellElem);
      lazyImages = lazyImages.concat(lazyCellImages);
    }); // load lazy images

    lazyImages.forEach(function (img) {
      new LazyLoader(img, this);
    }, this);
  };

  function getCellLazyImages(cellElem) {
    // check if cell element is lazy image
    if (cellElem.nodeName == 'IMG') {
      var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');
      var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');
      var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');

      if (lazyloadAttr || srcAttr || srcsetAttr) {
        return [cellElem];
      }
    } // select lazy images in cell


    var lazySelector = 'img[data-flickity-lazyload], ' + 'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';
    var imgs = cellElem.querySelectorAll(lazySelector);
    return utils.makeArray(imgs);
  } // -------------------------- LazyLoader -------------------------- //

  /**
   * class to handle loading images
   */


  function LazyLoader(img, flickity) {
    this.img = img;
    this.flickity = flickity;
    this.load();
  }

  LazyLoader.prototype.handleEvent = utils.handleEvent;

  LazyLoader.prototype.load = function () {
    this.img.addEventListener('load', this);
    this.img.addEventListener('error', this); // get src & srcset

    var src = this.img.getAttribute('data-flickity-lazyload') || this.img.getAttribute('data-flickity-lazyload-src');
    var srcset = this.img.getAttribute('data-flickity-lazyload-srcset'); // set src & serset

    this.img.src = src;

    if (srcset) {
      this.img.setAttribute('srcset', srcset);
    } // remove attr


    this.img.removeAttribute('data-flickity-lazyload');
    this.img.removeAttribute('data-flickity-lazyload-src');
    this.img.removeAttribute('data-flickity-lazyload-srcset');
  };

  LazyLoader.prototype.onload = function (event) {
    this.complete(event, 'flickity-lazyloaded');
  };

  LazyLoader.prototype.onerror = function (event) {
    this.complete(event, 'flickity-lazyerror');
  };

  LazyLoader.prototype.complete = function (event, className) {
    // unbind events
    this.img.removeEventListener('load', this);
    this.img.removeEventListener('error', this);
    var cell = this.flickity.getParentCell(this.img);
    var cellElem = cell && cell.element;
    this.flickity.cellSizeChange(cellElem);
    this.img.classList.add(className);
    this.flickity.dispatchEvent('lazyLoad', event, cellElem);
  }; // -----  ----- //


  Flickity.LazyLoader = LazyLoader;
  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/page-dots.js":
/*!***********************************************!*\
  !*** ./node_modules/flickity/js/page-dots.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// page dots
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"), __webpack_require__(/*! unipointer/unipointer */ "./node_modules/unipointer/unipointer.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, Unipointer, utils) {
      return factory(window, Flickity, Unipointer, utils);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, Flickity, Unipointer, utils) {
  // -------------------------- PageDots -------------------------- //
  'use strict';

  function PageDots(parent) {
    this.parent = parent;

    this._create();
  }

  PageDots.prototype = Object.create(Unipointer.prototype);

  PageDots.prototype._create = function () {
    // create holder element
    this.holder = document.createElement('ol');
    this.holder.className = 'flickity-page-dots'; // create dots, array of elements

    this.dots = []; // events

    this.handleClick = this.onClick.bind(this);
    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));
  };

  PageDots.prototype.activate = function () {
    this.setDots();
    this.holder.addEventListener('click', this.handleClick);
    this.bindStartEvent(this.holder); // add to DOM

    this.parent.element.appendChild(this.holder);
  };

  PageDots.prototype.deactivate = function () {
    this.holder.removeEventListener('click', this.handleClick);
    this.unbindStartEvent(this.holder); // remove from DOM

    this.parent.element.removeChild(this.holder);
  };

  PageDots.prototype.setDots = function () {
    // get difference between number of slides and number of dots
    var delta = this.parent.slides.length - this.dots.length;

    if (delta > 0) {
      this.addDots(delta);
    } else if (delta < 0) {
      this.removeDots(-delta);
    }
  };

  PageDots.prototype.addDots = function (count) {
    var fragment = document.createDocumentFragment();
    var newDots = [];
    var length = this.dots.length;
    var max = length + count;

    for (var i = length; i < max; i++) {
      var dot = document.createElement('li');
      dot.className = 'dot';
      dot.setAttribute('aria-label', 'Page dot ' + (i + 1));
      fragment.appendChild(dot);
      newDots.push(dot);
    }

    this.holder.appendChild(fragment);
    this.dots = this.dots.concat(newDots);
  };

  PageDots.prototype.removeDots = function (count) {
    // remove from this.dots collection
    var removeDots = this.dots.splice(this.dots.length - count, count); // remove from DOM

    removeDots.forEach(function (dot) {
      this.holder.removeChild(dot);
    }, this);
  };

  PageDots.prototype.updateSelected = function () {
    // remove selected class on previous
    if (this.selectedDot) {
      this.selectedDot.className = 'dot';
      this.selectedDot.removeAttribute('aria-current');
    } // don't proceed if no dots


    if (!this.dots.length) {
      return;
    }

    this.selectedDot = this.dots[this.parent.selectedIndex];
    this.selectedDot.className = 'dot is-selected';
    this.selectedDot.setAttribute('aria-current', 'step');
  };

  PageDots.prototype.onTap = // old method name, backwards-compatible
  PageDots.prototype.onClick = function (event) {
    var target = event.target; // only care about dot clicks

    if (target.nodeName != 'LI') {
      return;
    }

    this.parent.uiChange();
    var index = this.dots.indexOf(target);
    this.parent.select(index);
  };

  PageDots.prototype.destroy = function () {
    this.deactivate();
    this.allOff();
  };

  Flickity.PageDots = PageDots; // -------------------------- Flickity -------------------------- //

  utils.extend(Flickity.defaults, {
    pageDots: true
  });
  Flickity.createMethods.push('_createPageDots');
  var proto = Flickity.prototype;

  proto._createPageDots = function () {
    if (!this.options.pageDots) {
      return;
    }

    this.pageDots = new PageDots(this); // events

    this.on('activate', this.activatePageDots);
    this.on('select', this.updateSelectedPageDots);
    this.on('cellChange', this.updatePageDots);
    this.on('resize', this.updatePageDots);
    this.on('deactivate', this.deactivatePageDots);
  };

  proto.activatePageDots = function () {
    this.pageDots.activate();
  };

  proto.updateSelectedPageDots = function () {
    this.pageDots.updateSelected();
  };

  proto.updatePageDots = function () {
    this.pageDots.setDots();
  };

  proto.deactivatePageDots = function () {
    this.pageDots.deactivate();
  }; // -----  ----- //


  Flickity.PageDots = PageDots;
  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/player.js":
/*!********************************************!*\
  !*** ./node_modules/flickity/js/player.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// player & autoPlay
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js"), __webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter, utils, Flickity) {
      return factory(EvEmitter, utils, Flickity);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(EvEmitter, utils, Flickity) {
  'use strict'; // -------------------------- Player -------------------------- //

  function Player(parent) {
    this.parent = parent;
    this.state = 'stopped'; // visibility change event handler

    this.onVisibilityChange = this.visibilityChange.bind(this);
    this.onVisibilityPlay = this.visibilityPlay.bind(this);
  }

  Player.prototype = Object.create(EvEmitter.prototype); // start play

  Player.prototype.play = function () {
    if (this.state == 'playing') {
      return;
    } // do not play if page is hidden, start playing when page is visible


    var isPageHidden = document.hidden;

    if (isPageHidden) {
      document.addEventListener('visibilitychange', this.onVisibilityPlay);
      return;
    }

    this.state = 'playing'; // listen to visibility change

    document.addEventListener('visibilitychange', this.onVisibilityChange); // start ticking

    this.tick();
  };

  Player.prototype.tick = function () {
    // do not tick if not playing
    if (this.state != 'playing') {
      return;
    }

    var time = this.parent.options.autoPlay; // default to 3 seconds

    time = typeof time == 'number' ? time : 3000;

    var _this = this; // HACK: reset ticks if stopped and started within interval


    this.clear();
    this.timeout = setTimeout(function () {
      _this.parent.next(true);

      _this.tick();
    }, time);
  };

  Player.prototype.stop = function () {
    this.state = 'stopped';
    this.clear(); // remove visibility change event

    document.removeEventListener('visibilitychange', this.onVisibilityChange);
  };

  Player.prototype.clear = function () {
    clearTimeout(this.timeout);
  };

  Player.prototype.pause = function () {
    if (this.state == 'playing') {
      this.state = 'paused';
      this.clear();
    }
  };

  Player.prototype.unpause = function () {
    // re-start play if paused
    if (this.state == 'paused') {
      this.play();
    }
  }; // pause if page visibility is hidden, unpause if visible


  Player.prototype.visibilityChange = function () {
    var isPageHidden = document.hidden;
    this[isPageHidden ? 'pause' : 'unpause']();
  };

  Player.prototype.visibilityPlay = function () {
    this.play();
    document.removeEventListener('visibilitychange', this.onVisibilityPlay);
  }; // -------------------------- Flickity -------------------------- //


  utils.extend(Flickity.defaults, {
    pauseAutoPlayOnHover: true
  });
  Flickity.createMethods.push('_createPlayer');
  var proto = Flickity.prototype;

  proto._createPlayer = function () {
    this.player = new Player(this);
    this.on('activate', this.activatePlayer);
    this.on('uiChange', this.stopPlayer);
    this.on('pointerDown', this.stopPlayer);
    this.on('deactivate', this.deactivatePlayer);
  };

  proto.activatePlayer = function () {
    if (!this.options.autoPlay) {
      return;
    }

    this.player.play();
    this.element.addEventListener('mouseenter', this);
  }; // Player API, don't hate the ... thanks I know where the door is


  proto.playPlayer = function () {
    this.player.play();
  };

  proto.stopPlayer = function () {
    this.player.stop();
  };

  proto.pausePlayer = function () {
    this.player.pause();
  };

  proto.unpausePlayer = function () {
    this.player.unpause();
  };

  proto.deactivatePlayer = function () {
    this.player.stop();
    this.element.removeEventListener('mouseenter', this);
  }; // ----- mouseenter/leave ----- //
  // pause auto-play on hover


  proto.onmouseenter = function () {
    if (!this.options.pauseAutoPlayOnHover) {
      return;
    }

    this.player.pause();
    this.element.addEventListener('mouseleave', this);
  }; // resume auto-play on hover off


  proto.onmouseleave = function () {
    this.player.unpause();
    this.element.removeEventListener('mouseleave', this);
  }; // -----  ----- //


  Flickity.Player = Player;
  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/prev-next-button.js":
/*!******************************************************!*\
  !*** ./node_modules/flickity/js/prev-next-button.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// prev/next buttons
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"), __webpack_require__(/*! unipointer/unipointer */ "./node_modules/unipointer/unipointer.js"), __webpack_require__(/*! fizzy-ui-utils/utils */ "./node_modules/fizzy-ui-utils/utils.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, Unipointer, utils) {
      return factory(window, Flickity, Unipointer, utils);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, Flickity, Unipointer, utils) {
  'use strict';

  var svgURI = 'http://www.w3.org/2000/svg'; // -------------------------- PrevNextButton -------------------------- //

  function PrevNextButton(direction, parent) {
    this.direction = direction;
    this.parent = parent;

    this._create();
  }

  PrevNextButton.prototype = Object.create(Unipointer.prototype);

  PrevNextButton.prototype._create = function () {
    // properties
    this.isEnabled = true;
    this.isPrevious = this.direction == -1;
    var leftDirection = this.parent.options.rightToLeft ? 1 : -1;
    this.isLeft = this.direction == leftDirection;
    var element = this.element = document.createElement('button');
    element.className = 'flickity-button flickity-prev-next-button';
    element.className += this.isPrevious ? ' previous' : ' next'; // prevent button from submitting form http://stackoverflow.com/a/10836076/182183

    element.setAttribute('type', 'button'); // init as disabled

    this.disable();
    element.setAttribute('aria-label', this.isPrevious ? 'Previous' : 'Next'); // create arrow

    var svg = this.createSVG();
    element.appendChild(svg); // events

    this.parent.on('select', this.update.bind(this));
    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));
  };

  PrevNextButton.prototype.activate = function () {
    this.bindStartEvent(this.element);
    this.element.addEventListener('click', this); // add to DOM

    this.parent.element.appendChild(this.element);
  };

  PrevNextButton.prototype.deactivate = function () {
    // remove from DOM
    this.parent.element.removeChild(this.element); // click events

    this.unbindStartEvent(this.element);
    this.element.removeEventListener('click', this);
  };

  PrevNextButton.prototype.createSVG = function () {
    var svg = document.createElementNS(svgURI, 'svg');
    svg.setAttribute('class', 'flickity-button-icon');
    svg.setAttribute('viewBox', '0 0 100 100');
    var path = document.createElementNS(svgURI, 'path');
    var pathMovements = getArrowMovements(this.parent.options.arrowShape);
    path.setAttribute('d', pathMovements);
    path.setAttribute('class', 'arrow'); // rotate arrow

    if (!this.isLeft) {
      path.setAttribute('transform', 'translate(100, 100) rotate(180) ');
    }

    svg.appendChild(path);
    return svg;
  }; // get SVG path movmement


  function getArrowMovements(shape) {
    // use shape as movement if string
    if (typeof shape == 'string') {
      return shape;
    } // create movement string


    return 'M ' + shape.x0 + ',50' + ' L ' + shape.x1 + ',' + (shape.y1 + 50) + ' L ' + shape.x2 + ',' + (shape.y2 + 50) + ' L ' + shape.x3 + ',50 ' + ' L ' + shape.x2 + ',' + (50 - shape.y2) + ' L ' + shape.x1 + ',' + (50 - shape.y1) + ' Z';
  }

  PrevNextButton.prototype.handleEvent = utils.handleEvent;

  PrevNextButton.prototype.onclick = function () {
    if (!this.isEnabled) {
      return;
    }

    this.parent.uiChange();
    var method = this.isPrevious ? 'previous' : 'next';
    this.parent[method]();
  }; // -----  ----- //


  PrevNextButton.prototype.enable = function () {
    if (this.isEnabled) {
      return;
    }

    this.element.disabled = false;
    this.isEnabled = true;
  };

  PrevNextButton.prototype.disable = function () {
    if (!this.isEnabled) {
      return;
    }

    this.element.disabled = true;
    this.isEnabled = false;
  };

  PrevNextButton.prototype.update = function () {
    // index of first or last slide, if previous or next
    var slides = this.parent.slides; // enable is wrapAround and at least 2 slides

    if (this.parent.options.wrapAround && slides.length > 1) {
      this.enable();
      return;
    }

    var lastIndex = slides.length ? slides.length - 1 : 0;
    var boundIndex = this.isPrevious ? 0 : lastIndex;
    var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';
    this[method]();
  };

  PrevNextButton.prototype.destroy = function () {
    this.deactivate();
    this.allOff();
  }; // -------------------------- Flickity prototype -------------------------- //


  utils.extend(Flickity.defaults, {
    prevNextButtons: true,
    arrowShape: {
      x0: 10,
      x1: 60,
      y1: 50,
      x2: 70,
      y2: 40,
      x3: 30
    }
  });
  Flickity.createMethods.push('_createPrevNextButtons');
  var proto = Flickity.prototype;

  proto._createPrevNextButtons = function () {
    if (!this.options.prevNextButtons) {
      return;
    }

    this.prevButton = new PrevNextButton(-1, this);
    this.nextButton = new PrevNextButton(1, this);
    this.on('activate', this.activatePrevNextButtons);
  };

  proto.activatePrevNextButtons = function () {
    this.prevButton.activate();
    this.nextButton.activate();
    this.on('deactivate', this.deactivatePrevNextButtons);
  };

  proto.deactivatePrevNextButtons = function () {
    this.prevButton.deactivate();
    this.nextButton.deactivate();
    this.off('deactivate', this.deactivatePrevNextButtons);
  }; // --------------------------  -------------------------- //


  Flickity.PrevNextButton = PrevNextButton;
  return Flickity;
});

/***/ }),

/***/ "./node_modules/flickity/js/slide.js":
/*!*******************************************!*\
  !*** ./node_modules/flickity/js/slide.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// slide
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory() {
  'use strict';

  function Slide(parent) {
    this.parent = parent;
    this.isOriginLeft = parent.originSide == 'left';
    this.cells = [];
    this.outerWidth = 0;
    this.height = 0;
  }

  var proto = Slide.prototype;

  proto.addCell = function (cell) {
    this.cells.push(cell);
    this.outerWidth += cell.size.outerWidth;
    this.height = Math.max(cell.size.outerHeight, this.height); // first cell stuff

    if (this.cells.length == 1) {
      this.x = cell.x; // x comes from first cell

      var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';
      this.firstMargin = cell.size[beginMargin];
    }
  };

  proto.updateTarget = function () {
    var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';
    var lastCell = this.getLastCell();
    var lastMargin = lastCell ? lastCell.size[endMargin] : 0;
    var slideWidth = this.outerWidth - (this.firstMargin + lastMargin);
    this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;
  };

  proto.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  proto.select = function () {
    this.cells.forEach(function (cell) {
      cell.select();
    });
  };

  proto.unselect = function () {
    this.cells.forEach(function (cell) {
      cell.unselect();
    });
  };

  proto.getCellElements = function () {
    return this.cells.map(function (cell) {
      return cell.element;
    });
  };

  return Slide;
});

/***/ }),

/***/ "./node_modules/get-size/get-size.js":
/*!*******************************************!*\
  !*** ./node_modules/get-size/get-size.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */

/* globals console: false */
(function (window, factory) {
  /* jshint strict: false */

  /* globals define, module */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory() {
  'use strict'; // -------------------------- helpers -------------------------- //
  // get a number from a string, not a percentage

  function getStyleSize(value) {
    var num = parseFloat(value); // not a percent like '100%', and a number

    var isValid = value.indexOf('%') == -1 && !isNaN(num);
    return isValid && num;
  }

  function noop() {}

  var logError = typeof console == 'undefined' ? noop : function (message) {
    console.error(message);
  }; // -------------------------- measurements -------------------------- //

  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];
  var measurementsLength = measurements.length;

  function getZeroSize() {
    var size = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    };

    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      size[measurement] = 0;
    }

    return size;
  } // -------------------------- getStyle -------------------------- //

  /**
   * getStyle, get style of element, check for Firefox bug
   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
   */


  function getStyle(elem) {
    var style = getComputedStyle(elem);

    if (!style) {
      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See https://bit.ly/getsizebug1');
    }

    return style;
  } // -------------------------- setup -------------------------- //


  var isSetup = false;
  var isBoxSizeOuter;
  /**
   * setup
   * check isBoxSizerOuter
   * do on first getSize() rather than on page load for Firefox bug
   */

  function setup() {
    // setup once
    if (isSetup) {
      return;
    }

    isSetup = true; // -------------------------- box sizing -------------------------- //

    /**
     * Chrome & Safari measure the outer-width on style.width on border-box elems
     * IE11 & Firefox<29 measures the inner-width
     */

    var div = document.createElement('div');
    div.style.width = '200px';
    div.style.padding = '1px 2px 3px 4px';
    div.style.borderStyle = 'solid';
    div.style.borderWidth = '1px 2px 3px 4px';
    div.style.boxSizing = 'border-box';
    var body = document.body || document.documentElement;
    body.appendChild(div);
    var style = getStyle(div); // round value for browser zoom. desandro/masonry#928

    isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;
    getSize.isBoxSizeOuter = isBoxSizeOuter;
    body.removeChild(div);
  } // -------------------------- getSize -------------------------- //


  function getSize(elem) {
    setup(); // use querySeletor if elem is string

    if (typeof elem == 'string') {
      elem = document.querySelector(elem);
    } // do not proceed on non-objects


    if (!elem || _typeof(elem) != 'object' || !elem.nodeType) {
      return;
    }

    var style = getStyle(elem); // if hidden, everything is 0

    if (style.display == 'none') {
      return getZeroSize();
    }

    var size = {};
    size.width = elem.offsetWidth;
    size.height = elem.offsetHeight;
    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box'; // get all measurements

    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      var value = style[measurement];
      var num = parseFloat(value); // any 'auto', 'medium' value will be 0

      size[measurement] = !isNaN(num) ? num : 0;
    }

    var paddingWidth = size.paddingLeft + size.paddingRight;
    var paddingHeight = size.paddingTop + size.paddingBottom;
    var marginWidth = size.marginLeft + size.marginRight;
    var marginHeight = size.marginTop + size.marginBottom;
    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
    var borderHeight = size.borderTopWidth + size.borderBottomWidth;
    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter; // overwrite width and height if we can get it from style

    var styleWidth = getStyleSize(style.width);

    if (styleWidth !== false) {
      size.width = styleWidth + ( // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
    }

    var styleHeight = getStyleSize(style.height);

    if (styleHeight !== false) {
      size.height = styleHeight + ( // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
    }

    size.innerWidth = size.width - (paddingWidth + borderWidth);
    size.innerHeight = size.height - (paddingHeight + borderHeight);
    size.outerWidth = size.width + marginWidth;
    size.outerHeight = size.height + marginHeight;
    return size;
  }

  return getSize;
});

/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && _typeof(value) == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = debounce;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash.memoize/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.memoize/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** `Object#toString` result references. */

var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue(object, key) {
  return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */


function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;

  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }

  return result;
}
/** Used for built-in method references. */


var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */


var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */

var splice = arrayProto.splice;
/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */


function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */


function listCacheClear() {
  this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */


function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */


function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */


function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */


function memoize(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Assign cache to `_.memoize`.


memoize.Cache = MapCache;
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq(value, other) {
  return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */


function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash.throttle/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.throttle/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && _typeof(value) == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = throttle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */

/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */


  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }

      return false;
    });
    return result;
  }

  return (
    /** @class */
    function () {
      function class_1() {
        this.__entries__ = [];
      }

      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function get() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */

      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */


      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);

        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype["delete"] = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);

        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */


      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */


      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }

        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };

      return class_1;
    }()
  );
}();
/**
 * Detects whether window and document objects are available in current environment.
 */


var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

var global$1 = function () {
  if (typeof global !== 'undefined' && global.Math === Math) {
    return global;
  }

  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }

  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  } // eslint-disable-next-line no-new-func


  return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */


var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }

  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}(); // Defines minimum timeout before adding a trailing call.


var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */

function throttle(callback, delay) {
  var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */

  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }

    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */


  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */


  function proxy() {
    var timeStamp = Date.now();

    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      } // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.


      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }

    lastCallTime = timeStamp;
  }

  return proxy;
} // Minimum delay before invoking the update of observers.


var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.

var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */

var ResizeObserverController =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */

    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */

    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */

    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */


  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    } // Add listeners if they haven't been added yet.


    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */


  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer); // Remove observer if it's present in registry.

    if (~index) {
      observers.splice(index, 1);
    } // Remove listeners if controller has no connected observers.


    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */


  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.

    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */


  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    }); // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.

    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    } // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.


    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */


  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */


  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */


  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */


var defineConfigurable = function defineConfigurable(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }

  return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */


var getWindowOf = function getWindowOf(target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
  // provided element.

  return ownerGlobal || global$1;
}; // Placeholder of an empty content rectangle.


var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */

function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */


function getBordersSize(styles) {
  var positions = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }

  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */


function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};

  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }

  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */


function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */


function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.

  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }

  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.

  var width = toFloat(styles.width),
      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).

  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }

    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  } // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.


  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.

    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }

    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }

  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  } // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens


  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */


function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }

  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }

  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */


function createReadOnlyRect(_a) {
  var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */


function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */


var ResizeObservation =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */

    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */

    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */


  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */


  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };

  return ResizeObservation;
}();

var ResizeObserverEntry =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.

    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }

  return ResizeObserverEntry;
}();

var ResizeObserverSPI =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */

    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is already being observed.

    if (observations.has(target)) {
      return;
    }

    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this); // Force the update of observations.

    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is not being observed.

    if (!observations.has(target)) {
      return;
    }

    observations["delete"](target);

    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;

    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }

    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */


  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };

  return ResizeObserverSPI;
}(); // Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.


var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */

var ResizeObserver =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }

    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }

  return ResizeObserver;
}(); // Expose public methods of ResizeObserver.


['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;

    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});

var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }

  return ResizeObserver;
}();

/* harmony default export */ __webpack_exports__["default"] = (index);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/simplebar/dist/simplebar.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/simplebar/dist/simplebar.esm.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var can_use_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! can-use-dom */ "./node_modules/can-use-dom/index.js");
/* harmony import */ var can_use_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(can_use_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");
/* harmony import */ var core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");
/* harmony import */ var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_parse_int__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.parse-int */ "./node_modules/core-js/modules/es.parse-int.js");
/* harmony import */ var core_js_modules_es_parse_int__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_int__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");
/* harmony import */ var core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash.throttle */ "./node_modules/lodash.throttle/index.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash.memoize */ "./node_modules/lodash.memoize/index.js");
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(lodash_memoize__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
/* harmony import */ var core_js_modules_es_array_reduce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");
/* harmony import */ var core_js_modules_es_array_reduce__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_reduce__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_es_function_name__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");
/* harmony import */ var core_js_modules_es_function_name__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.string.match */ "./node_modules/core-js/modules/es.string.match.js");
/* harmony import */ var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_19__);
/**
 * SimpleBar.js - v5.2.1
 * Scrollbars, simpler.
 * https://grsmto.github.io/simplebar/
 *
 * Made by Adrien Denat from a fork by Jonathan Nicol
 * Under MIT License
 */




















var cachedScrollbarWidth = null;
var cachedDevicePixelRatio = null;

if (can_use_dom__WEBPACK_IMPORTED_MODULE_2___default.a) {
  window.addEventListener('resize', function () {
    if (cachedDevicePixelRatio !== window.devicePixelRatio) {
      cachedDevicePixelRatio = window.devicePixelRatio;
      cachedScrollbarWidth = null;
    }
  });
}

function scrollbarWidth() {
  if (cachedScrollbarWidth === null) {
    if (typeof document === 'undefined') {
      cachedScrollbarWidth = 0;
      return cachedScrollbarWidth;
    }

    var body = document.body;
    var box = document.createElement('div');
    box.classList.add('simplebar-hide-scrollbar');
    body.appendChild(box);
    var width = box.getBoundingClientRect().right;
    body.removeChild(box);
    cachedScrollbarWidth = width;
  }

  return cachedScrollbarWidth;
} // Helper function to retrieve options from element attributes


var getOptions = function getOptions(obj) {
  var options = Array.prototype.reduce.call(obj, function (acc, attribute) {
    var option = attribute.name.match(/data-simplebar-(.+)/);

    if (option) {
      var key = option[1].replace(/\W+(.)/g, function (x, chr) {
        return chr.toUpperCase();
      });

      switch (attribute.value) {
        case 'true':
          acc[key] = true;
          break;

        case 'false':
          acc[key] = false;
          break;

        case undefined:
          acc[key] = true;
          break;

        default:
          acc[key] = attribute.value;
      }
    }

    return acc;
  }, {});
  return options;
};

function getElementWindow(element) {
  if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) {
    return window;
  }

  return element.ownerDocument.defaultView;
}

function getElementDocument(element) {
  if (!element || !element.ownerDocument) {
    return document;
  }

  return element.ownerDocument;
}

var SimpleBar = /*#__PURE__*/function () {
  function SimpleBar(element, options) {
    var _this = this;

    this.onScroll = function () {
      var elWindow = getElementWindow(_this.el);

      if (!_this.scrollXTicking) {
        elWindow.requestAnimationFrame(_this.scrollX);
        _this.scrollXTicking = true;
      }

      if (!_this.scrollYTicking) {
        elWindow.requestAnimationFrame(_this.scrollY);
        _this.scrollYTicking = true;
      }
    };

    this.scrollX = function () {
      if (_this.axis.x.isOverflowing) {
        _this.showScrollbar('x');

        _this.positionScrollbar('x');
      }

      _this.scrollXTicking = false;
    };

    this.scrollY = function () {
      if (_this.axis.y.isOverflowing) {
        _this.showScrollbar('y');

        _this.positionScrollbar('y');
      }

      _this.scrollYTicking = false;
    };

    this.onMouseEnter = function () {
      _this.showScrollbar('x');

      _this.showScrollbar('y');
    };

    this.onMouseMove = function (e) {
      _this.mouseX = e.clientX;
      _this.mouseY = e.clientY;

      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
        _this.onMouseMoveForAxis('x');
      }

      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
        _this.onMouseMoveForAxis('y');
      }
    };

    this.onMouseLeave = function () {
      _this.onMouseMove.cancel();

      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
        _this.onMouseLeaveForAxis('x');
      }

      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
        _this.onMouseLeaveForAxis('y');
      }

      _this.mouseX = -1;
      _this.mouseY = -1;
    };

    this.onWindowResize = function () {
      // Recalculate scrollbarWidth in case it's a zoom
      _this.scrollbarWidth = _this.getScrollbarWidth();

      _this.hideNativeScrollbar();
    };

    this.hideScrollbars = function () {
      _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
      _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();

      if (!_this.isWithinBounds(_this.axis.y.track.rect)) {
        _this.axis.y.scrollbar.el.classList.remove(_this.classNames.visible);

        _this.axis.y.isVisible = false;
      }

      if (!_this.isWithinBounds(_this.axis.x.track.rect)) {
        _this.axis.x.scrollbar.el.classList.remove(_this.classNames.visible);

        _this.axis.x.isVisible = false;
      }
    };

    this.onPointerEvent = function (e) {
      var isWithinTrackXBounds, isWithinTrackYBounds;
      _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
      _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();

      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
        isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);
      }

      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
        isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);
      } // If any pointer event is called on the scrollbar


      if (isWithinTrackXBounds || isWithinTrackYBounds) {
        // Preventing the event's default action stops text being
        // selectable during the drag.
        e.preventDefault(); // Prevent event leaking

        e.stopPropagation();

        if (e.type === 'mousedown') {
          if (isWithinTrackXBounds) {
            _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();

            if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {
              _this.onDragStart(e, 'x');
            } else {
              _this.onTrackClick(e, 'x');
            }
          }

          if (isWithinTrackYBounds) {
            _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();

            if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {
              _this.onDragStart(e, 'y');
            } else {
              _this.onTrackClick(e, 'y');
            }
          }
        }
      }
    };

    this.drag = function (e) {
      var eventOffset;
      var track = _this.axis[_this.draggedAxis].track;
      var trackSize = track.rect[_this.axis[_this.draggedAxis].sizeAttr];
      var scrollbar = _this.axis[_this.draggedAxis].scrollbar;
      var contentSize = _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollSizeAttr];
      var hostSize = parseInt(_this.elStyles[_this.axis[_this.draggedAxis].sizeAttr], 10);
      e.preventDefault();
      e.stopPropagation();

      if (_this.draggedAxis === 'y') {
        eventOffset = e.pageY;
      } else {
        eventOffset = e.pageX;
      } // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).


      var dragPos = eventOffset - track.rect[_this.axis[_this.draggedAxis].offsetAttr] - _this.axis[_this.draggedAxis].dragOffset; // Convert the mouse position into a percentage of the scrollbar height/width.

      var dragPerc = dragPos / (trackSize - scrollbar.size); // Scroll the content by the same percentage.

      var scrollPos = dragPerc * (contentSize - hostSize); // Fix browsers inconsistency on RTL

      if (_this.draggedAxis === 'x') {
        scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted ? scrollPos - (trackSize + scrollbar.size) : scrollPos;
        scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted ? -scrollPos : scrollPos;
      }

      _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;
    };

    this.onEndDrag = function (e) {
      var elDocument = getElementDocument(_this.el);
      var elWindow = getElementWindow(_this.el);
      e.preventDefault();
      e.stopPropagation();

      _this.el.classList.remove(_this.classNames.dragging);

      elDocument.removeEventListener('mousemove', _this.drag, true);
      elDocument.removeEventListener('mouseup', _this.onEndDrag, true);
      _this.removePreventClickId = elWindow.setTimeout(function () {
        // Remove these asynchronously so we still suppress click events
        // generated simultaneously with mouseup.
        elDocument.removeEventListener('click', _this.preventClick, true);
        elDocument.removeEventListener('dblclick', _this.preventClick, true);
        _this.removePreventClickId = null;
      });
    };

    this.preventClick = function (e) {
      e.preventDefault();
      e.stopPropagation();
    };

    this.el = element;
    this.minScrollbarWidth = 20;
    this.options = Object.assign({}, SimpleBar.defaultOptions, {}, options);
    this.classNames = Object.assign({}, SimpleBar.defaultOptions.classNames, {}, this.options.classNames);
    this.axis = {
      x: {
        scrollOffsetAttr: 'scrollLeft',
        sizeAttr: 'width',
        scrollSizeAttr: 'scrollWidth',
        offsetSizeAttr: 'offsetWidth',
        offsetAttr: 'left',
        overflowAttr: 'overflowX',
        dragOffset: 0,
        isOverflowing: true,
        isVisible: false,
        forceVisible: false,
        track: {},
        scrollbar: {}
      },
      y: {
        scrollOffsetAttr: 'scrollTop',
        sizeAttr: 'height',
        scrollSizeAttr: 'scrollHeight',
        offsetSizeAttr: 'offsetHeight',
        offsetAttr: 'top',
        overflowAttr: 'overflowY',
        dragOffset: 0,
        isOverflowing: true,
        isVisible: false,
        forceVisible: false,
        track: {},
        scrollbar: {}
      }
    };
    this.removePreventClickId = null; // Don't re-instantiate over an existing one

    if (SimpleBar.instances.has(this.el)) {
      return;
    }

    this.recalculate = lodash_throttle__WEBPACK_IMPORTED_MODULE_11___default()(this.recalculate.bind(this), 64);
    this.onMouseMove = lodash_throttle__WEBPACK_IMPORTED_MODULE_11___default()(this.onMouseMove.bind(this), 64);
    this.hideScrollbars = lodash_debounce__WEBPACK_IMPORTED_MODULE_12___default()(this.hideScrollbars.bind(this), this.options.timeout);
    this.onWindowResize = lodash_debounce__WEBPACK_IMPORTED_MODULE_12___default()(this.onWindowResize.bind(this), 64, {
      leading: true
    });
    SimpleBar.getRtlHelpers = lodash_memoize__WEBPACK_IMPORTED_MODULE_13___default()(SimpleBar.getRtlHelpers);
    this.init();
  }
  /**
   * Static properties
   */

  /**
   * Helper to fix browsers inconsistency on RTL:
   *  - Firefox inverts the scrollbar initial position
   *  - IE11 inverts both scrollbar position and scrolling offset
   * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634
   */


  SimpleBar.getRtlHelpers = function getRtlHelpers() {
    var dummyDiv = document.createElement('div');
    dummyDiv.innerHTML = '<div class="hs-dummy-scrollbar-size"><div style="height: 200%; width: 200%; margin: 10px 0;"></div></div>';
    var scrollbarDummyEl = dummyDiv.firstElementChild;
    document.body.appendChild(scrollbarDummyEl);
    var dummyContainerChild = scrollbarDummyEl.firstElementChild;
    scrollbarDummyEl.scrollLeft = 0;
    var dummyContainerOffset = SimpleBar.getOffset(scrollbarDummyEl);
    var dummyContainerChildOffset = SimpleBar.getOffset(dummyContainerChild);
    scrollbarDummyEl.scrollLeft = 999;
    var dummyContainerScrollOffsetAfterScroll = SimpleBar.getOffset(dummyContainerChild);
    return {
      // determines if the scrolling is responding with negative values
      isRtlScrollingInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left && dummyContainerChildOffset.left - dummyContainerScrollOffsetAfterScroll.left !== 0,
      // determines if the origin scrollbar position is inverted or not (positioned on left or right)
      isRtlScrollbarInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left
    };
  };

  SimpleBar.getOffset = function getOffset(el) {
    var rect = el.getBoundingClientRect();
    var elDocument = getElementDocument(el);
    var elWindow = getElementWindow(el);
    return {
      top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),
      left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)
    };
  };

  var _proto = SimpleBar.prototype;

  _proto.init = function init() {
    // Save a reference to the instance, so we know this DOM node has already been instancied
    SimpleBar.instances.set(this.el, this); // We stop here on server-side

    if (can_use_dom__WEBPACK_IMPORTED_MODULE_2___default.a) {
      this.initDOM();
      this.scrollbarWidth = this.getScrollbarWidth();
      this.recalculate();
      this.initListeners();
    }
  };

  _proto.initDOM = function initDOM() {
    var _this2 = this; // make sure this element doesn't have the elements yet


    if (Array.prototype.filter.call(this.el.children, function (child) {
      return child.classList.contains(_this2.classNames.wrapper);
    }).length) {
      // assume that element has his DOM already initiated
      this.wrapperEl = this.el.querySelector("." + this.classNames.wrapper);
      this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector("." + this.classNames.contentWrapper);
      this.contentEl = this.options.contentNode || this.el.querySelector("." + this.classNames.contentEl);
      this.offsetEl = this.el.querySelector("." + this.classNames.offset);
      this.maskEl = this.el.querySelector("." + this.classNames.mask);
      this.placeholderEl = this.findChild(this.wrapperEl, "." + this.classNames.placeholder);
      this.heightAutoObserverWrapperEl = this.el.querySelector("." + this.classNames.heightAutoObserverWrapperEl);
      this.heightAutoObserverEl = this.el.querySelector("." + this.classNames.heightAutoObserverEl);
      this.axis.x.track.el = this.findChild(this.el, "." + this.classNames.track + "." + this.classNames.horizontal);
      this.axis.y.track.el = this.findChild(this.el, "." + this.classNames.track + "." + this.classNames.vertical);
    } else {
      // Prepare DOM
      this.wrapperEl = document.createElement('div');
      this.contentWrapperEl = document.createElement('div');
      this.offsetEl = document.createElement('div');
      this.maskEl = document.createElement('div');
      this.contentEl = document.createElement('div');
      this.placeholderEl = document.createElement('div');
      this.heightAutoObserverWrapperEl = document.createElement('div');
      this.heightAutoObserverEl = document.createElement('div');
      this.wrapperEl.classList.add(this.classNames.wrapper);
      this.contentWrapperEl.classList.add(this.classNames.contentWrapper);
      this.offsetEl.classList.add(this.classNames.offset);
      this.maskEl.classList.add(this.classNames.mask);
      this.contentEl.classList.add(this.classNames.contentEl);
      this.placeholderEl.classList.add(this.classNames.placeholder);
      this.heightAutoObserverWrapperEl.classList.add(this.classNames.heightAutoObserverWrapperEl);
      this.heightAutoObserverEl.classList.add(this.classNames.heightAutoObserverEl);

      while (this.el.firstChild) {
        this.contentEl.appendChild(this.el.firstChild);
      }

      this.contentWrapperEl.appendChild(this.contentEl);
      this.offsetEl.appendChild(this.contentWrapperEl);
      this.maskEl.appendChild(this.offsetEl);
      this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);
      this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);
      this.wrapperEl.appendChild(this.maskEl);
      this.wrapperEl.appendChild(this.placeholderEl);
      this.el.appendChild(this.wrapperEl);
    }

    if (!this.axis.x.track.el || !this.axis.y.track.el) {
      var track = document.createElement('div');
      var scrollbar = document.createElement('div');
      track.classList.add(this.classNames.track);
      scrollbar.classList.add(this.classNames.scrollbar);
      track.appendChild(scrollbar);
      this.axis.x.track.el = track.cloneNode(true);
      this.axis.x.track.el.classList.add(this.classNames.horizontal);
      this.axis.y.track.el = track.cloneNode(true);
      this.axis.y.track.el.classList.add(this.classNames.vertical);
      this.el.appendChild(this.axis.x.track.el);
      this.el.appendChild(this.axis.y.track.el);
    }

    this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector("." + this.classNames.scrollbar);
    this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector("." + this.classNames.scrollbar);

    if (!this.options.autoHide) {
      this.axis.x.scrollbar.el.classList.add(this.classNames.visible);
      this.axis.y.scrollbar.el.classList.add(this.classNames.visible);
    }

    this.el.setAttribute('data-simplebar', 'init');
  };

  _proto.initListeners = function initListeners() {
    var _this3 = this;

    var elWindow = getElementWindow(this.el); // Event listeners

    if (this.options.autoHide) {
      this.el.addEventListener('mouseenter', this.onMouseEnter);
    }

    ['mousedown', 'click', 'dblclick'].forEach(function (e) {
      _this3.el.addEventListener(e, _this3.onPointerEvent, true);
    });
    ['touchstart', 'touchend', 'touchmove'].forEach(function (e) {
      _this3.el.addEventListener(e, _this3.onPointerEvent, {
        capture: true,
        passive: true
      });
    });
    this.el.addEventListener('mousemove', this.onMouseMove);
    this.el.addEventListener('mouseleave', this.onMouseLeave);
    this.contentWrapperEl.addEventListener('scroll', this.onScroll); // Browser zoom triggers a window resize

    elWindow.addEventListener('resize', this.onWindowResize); // Hack for https://github.com/WICG/ResizeObserver/issues/38

    var resizeObserverStarted = false;
    var resizeObserver = elWindow.ResizeObserver || resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_14__["default"];
    this.resizeObserver = new resizeObserver(function () {
      if (!resizeObserverStarted) return;

      _this3.recalculate();
    });
    this.resizeObserver.observe(this.el);
    this.resizeObserver.observe(this.contentEl);
    elWindow.requestAnimationFrame(function () {
      resizeObserverStarted = true;
    }); // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.

    this.mutationObserver = new elWindow.MutationObserver(this.recalculate);
    this.mutationObserver.observe(this.contentEl, {
      childList: true,
      subtree: true,
      characterData: true
    });
  };

  _proto.recalculate = function recalculate() {
    var elWindow = getElementWindow(this.el);
    this.elStyles = elWindow.getComputedStyle(this.el);
    this.isRtl = this.elStyles.direction === 'rtl';
    var contentElOffsetWidth = this.contentEl.offsetWidth;
    var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;
    var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;
    var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;
    var elOverflowX = this.elStyles.overflowX;
    var elOverflowY = this.elStyles.overflowY;
    this.contentEl.style.padding = this.elStyles.paddingTop + " " + this.elStyles.paddingRight + " " + this.elStyles.paddingBottom + " " + this.elStyles.paddingLeft;
    this.wrapperEl.style.margin = "-" + this.elStyles.paddingTop + " -" + this.elStyles.paddingRight + " -" + this.elStyles.paddingBottom + " -" + this.elStyles.paddingLeft;
    var contentElScrollHeight = this.contentEl.scrollHeight;
    var contentElScrollWidth = this.contentEl.scrollWidth;
    this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%'; // Determine placeholder size

    this.placeholderEl.style.width = isWidthAuto ? (contentElOffsetWidth || contentElScrollWidth) + "px" : 'auto';
    this.placeholderEl.style.height = contentElScrollHeight + "px";
    var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;
    this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;
    this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight; // Set isOverflowing to false if user explicitely set hidden overflow

    this.axis.x.isOverflowing = elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;
    this.axis.y.isOverflowing = elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;
    this.axis.x.forceVisible = this.options.forceVisible === 'x' || this.options.forceVisible === true;
    this.axis.y.forceVisible = this.options.forceVisible === 'y' || this.options.forceVisible === true;
    this.hideNativeScrollbar(); // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)

    var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;
    var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
    this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;
    this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;
    this.axis.x.scrollbar.size = this.getScrollbarSize('x');
    this.axis.y.scrollbar.size = this.getScrollbarSize('y');
    this.axis.x.scrollbar.el.style.width = this.axis.x.scrollbar.size + "px";
    this.axis.y.scrollbar.el.style.height = this.axis.y.scrollbar.size + "px";
    this.positionScrollbar('x');
    this.positionScrollbar('y');
    this.toggleTrackVisibility('x');
    this.toggleTrackVisibility('y');
  }
  /**
   * Calculate scrollbar size
   */
  ;

  _proto.getScrollbarSize = function getScrollbarSize(axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    if (!this.axis[axis].isOverflowing) {
      return 0;
    }

    var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];
    var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];
    var scrollbarSize;
    var scrollbarRatio = trackSize / contentSize; // Calculate new height/position of drag handle.

    scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);

    if (this.options.scrollbarMaxSize) {
      scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);
    }

    return scrollbarSize;
  };

  _proto.positionScrollbar = function positionScrollbar(axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    if (!this.axis[axis].isOverflowing) {
      return;
    }

    var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];
    var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];
    var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);
    var scrollbar = this.axis[axis].scrollbar;
    var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
    scrollOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted ? -scrollOffset : scrollOffset;
    var scrollPourcent = scrollOffset / (contentSize - hostSize);
    var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);
    handleOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted ? handleOffset + (trackSize - scrollbar.size) : handleOffset;
    scrollbar.el.style.transform = axis === 'x' ? "translate3d(" + handleOffset + "px, 0, 0)" : "translate3d(0, " + handleOffset + "px, 0)";
  };

  _proto.toggleTrackVisibility = function toggleTrackVisibility(axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    var track = this.axis[axis].track.el;
    var scrollbar = this.axis[axis].scrollbar.el;

    if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {
      track.style.visibility = 'visible';
      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';
    } else {
      track.style.visibility = 'hidden';
      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';
    } // Even if forceVisible is enabled, scrollbar itself should be hidden


    if (this.axis[axis].isOverflowing) {
      scrollbar.style.display = 'block';
    } else {
      scrollbar.style.display = 'none';
    }
  };

  _proto.hideNativeScrollbar = function hideNativeScrollbar() {
    this.offsetEl.style[this.isRtl ? 'left' : 'right'] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? "-" + this.scrollbarWidth + "px" : 0;
    this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? "-" + this.scrollbarWidth + "px" : 0;
  }
  /**
   * On scroll event handling
   */
  ;

  _proto.onMouseMoveForAxis = function onMouseMoveForAxis(axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    this.axis[axis].track.rect = this.axis[axis].track.el.getBoundingClientRect();
    this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();
    var isWithinScrollbarBoundsX = this.isWithinBounds(this.axis[axis].scrollbar.rect);

    if (isWithinScrollbarBoundsX) {
      this.axis[axis].scrollbar.el.classList.add(this.classNames.hover);
    } else {
      this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);
    }

    if (this.isWithinBounds(this.axis[axis].track.rect)) {
      this.showScrollbar(axis);
      this.axis[axis].track.el.classList.add(this.classNames.hover);
    } else {
      this.axis[axis].track.el.classList.remove(this.classNames.hover);
    }
  };

  _proto.onMouseLeaveForAxis = function onMouseLeaveForAxis(axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    this.axis[axis].track.el.classList.remove(this.classNames.hover);
    this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);
  };
  /**
   * Show scrollbar
   */


  _proto.showScrollbar = function showScrollbar(axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    var scrollbar = this.axis[axis].scrollbar.el;

    if (!this.axis[axis].isVisible) {
      scrollbar.classList.add(this.classNames.visible);
      this.axis[axis].isVisible = true;
    }

    if (this.options.autoHide) {
      this.hideScrollbars();
    }
  }
  /**
   * Hide Scrollbar
   */
  ;
  /**
   * on scrollbar handle drag movement starts
   */


  _proto.onDragStart = function onDragStart(e, axis) {
    if (axis === void 0) {
      axis = 'y';
    }

    var elDocument = getElementDocument(this.el);
    var elWindow = getElementWindow(this.el);
    var scrollbar = this.axis[axis].scrollbar; // Measure how far the user's mouse is from the top of the scrollbar drag handle.

    var eventOffset = axis === 'y' ? e.pageY : e.pageX;
    this.axis[axis].dragOffset = eventOffset - scrollbar.rect[this.axis[axis].offsetAttr];
    this.draggedAxis = axis;
    this.el.classList.add(this.classNames.dragging);
    elDocument.addEventListener('mousemove', this.drag, true);
    elDocument.addEventListener('mouseup', this.onEndDrag, true);

    if (this.removePreventClickId === null) {
      elDocument.addEventListener('click', this.preventClick, true);
      elDocument.addEventListener('dblclick', this.preventClick, true);
    } else {
      elWindow.clearTimeout(this.removePreventClickId);
      this.removePreventClickId = null;
    }
  }
  /**
   * Drag scrollbar handle
   */
  ;

  _proto.onTrackClick = function onTrackClick(e, axis) {
    var _this4 = this;

    if (axis === void 0) {
      axis = 'y';
    }

    if (!this.options.clickOnTrack) return;
    var elWindow = getElementWindow(this.el);
    this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();
    var scrollbar = this.axis[axis].scrollbar;
    var scrollbarOffset = scrollbar.rect[this.axis[axis].offsetAttr];
    var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);
    var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
    var t = axis === 'y' ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;
    var dir = t < 0 ? -1 : 1;
    var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;
    var speed = 40;

    var scrollTo = function scrollTo() {
      if (dir === -1) {
        if (scrolled > scrollSize) {
          var _this4$contentWrapper;

          scrolled -= speed;

          _this4.contentWrapperEl.scrollTo((_this4$contentWrapper = {}, _this4$contentWrapper[_this4.axis[axis].offsetAttr] = scrolled, _this4$contentWrapper));

          elWindow.requestAnimationFrame(scrollTo);
        }
      } else {
        if (scrolled < scrollSize) {
          var _this4$contentWrapper2;

          scrolled += speed;

          _this4.contentWrapperEl.scrollTo((_this4$contentWrapper2 = {}, _this4$contentWrapper2[_this4.axis[axis].offsetAttr] = scrolled, _this4$contentWrapper2));

          elWindow.requestAnimationFrame(scrollTo);
        }
      }
    };

    scrollTo();
  }
  /**
   * Getter for content element
   */
  ;

  _proto.getContentElement = function getContentElement() {
    return this.contentEl;
  }
  /**
   * Getter for original scrolling element
   */
  ;

  _proto.getScrollElement = function getScrollElement() {
    return this.contentWrapperEl;
  };

  _proto.getScrollbarWidth = function getScrollbarWidth() {
    // Try/catch for FF 56 throwing on undefined computedStyles
    try {
      // Detect browsers supporting CSS scrollbar styling and do not calculate
      if (getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar').display === 'none' || 'scrollbarWidth' in document.documentElement.style || '-ms-overflow-style' in document.documentElement.style) {
        return 0;
      } else {
        return scrollbarWidth();
      }
    } catch (e) {
      return scrollbarWidth();
    }
  };

  _proto.removeListeners = function removeListeners() {
    var _this5 = this;

    var elWindow = getElementWindow(this.el); // Event listeners

    if (this.options.autoHide) {
      this.el.removeEventListener('mouseenter', this.onMouseEnter);
    }

    ['mousedown', 'click', 'dblclick'].forEach(function (e) {
      _this5.el.removeEventListener(e, _this5.onPointerEvent, true);
    });
    ['touchstart', 'touchend', 'touchmove'].forEach(function (e) {
      _this5.el.removeEventListener(e, _this5.onPointerEvent, {
        capture: true,
        passive: true
      });
    });
    this.el.removeEventListener('mousemove', this.onMouseMove);
    this.el.removeEventListener('mouseleave', this.onMouseLeave);
    this.contentWrapperEl.removeEventListener('scroll', this.onScroll);
    elWindow.removeEventListener('resize', this.onWindowResize);
    this.mutationObserver.disconnect();
    this.resizeObserver.disconnect(); // Cancel all debounced functions

    this.recalculate.cancel();
    this.onMouseMove.cancel();
    this.hideScrollbars.cancel();
    this.onWindowResize.cancel();
  }
  /**
   * UnMount mutation observer and delete SimpleBar instance from DOM element
   */
  ;

  _proto.unMount = function unMount() {
    this.removeListeners();
    SimpleBar.instances["delete"](this.el);
  }
  /**
   * Check if mouse is within bounds
   */
  ;

  _proto.isWithinBounds = function isWithinBounds(bbox) {
    return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;
  }
  /**
   * Find element children matches query
   */
  ;

  _proto.findChild = function findChild(el, query) {
    var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;
    return Array.prototype.filter.call(el.children, function (child) {
      return matches.call(child, query);
    })[0];
  };

  return SimpleBar;
}();

SimpleBar.defaultOptions = {
  autoHide: true,
  forceVisible: false,
  clickOnTrack: true,
  classNames: {
    contentEl: 'simplebar-content',
    contentWrapper: 'simplebar-content-wrapper',
    offset: 'simplebar-offset',
    mask: 'simplebar-mask',
    wrapper: 'simplebar-wrapper',
    placeholder: 'simplebar-placeholder',
    scrollbar: 'simplebar-scrollbar',
    track: 'simplebar-track',
    heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',
    heightAutoObserverEl: 'simplebar-height-auto-observer',
    visible: 'simplebar-visible',
    horizontal: 'simplebar-horizontal',
    vertical: 'simplebar-vertical',
    hover: 'simplebar-hover',
    dragging: 'simplebar-dragging'
  },
  scrollbarMinSize: 25,
  scrollbarMaxSize: 0,
  timeout: 1000
};
SimpleBar.instances = new WeakMap();

SimpleBar.initDOMLoadedElements = function () {
  document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);
  window.removeEventListener('load', this.initDOMLoadedElements);
  Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]'), function (el) {
    if (el.getAttribute('data-simplebar') !== 'init' && !SimpleBar.instances.has(el)) new SimpleBar(el, getOptions(el.attributes));
  });
};

SimpleBar.removeObserver = function () {
  this.globalObserver.disconnect();
};

SimpleBar.initHtmlApi = function () {
  this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this); // MutationObserver is IE11+

  if (typeof MutationObserver !== 'undefined') {
    // Mutation observer to observe dynamically added elements
    this.globalObserver = new MutationObserver(SimpleBar.handleMutations);
    this.globalObserver.observe(document, {
      childList: true,
      subtree: true
    });
  } // Taken from jQuery `ready` function
  // Instantiate elements already present on the page


  if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay init
    window.setTimeout(this.initDOMLoadedElements);
  } else {
    document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);
    window.addEventListener('load', this.initDOMLoadedElements);
  }
};

SimpleBar.handleMutations = function (mutations) {
  mutations.forEach(function (mutation) {
    Array.prototype.forEach.call(mutation.addedNodes, function (addedNode) {
      if (addedNode.nodeType === 1) {
        if (addedNode.hasAttribute('data-simplebar')) {
          !SimpleBar.instances.has(addedNode) && new SimpleBar(addedNode, getOptions(addedNode.attributes));
        } else {
          Array.prototype.forEach.call(addedNode.querySelectorAll('[data-simplebar]'), function (el) {
            if (el.getAttribute('data-simplebar') !== 'init' && !SimpleBar.instances.has(el)) new SimpleBar(el, getOptions(el.attributes));
          });
        }
      }
    });
    Array.prototype.forEach.call(mutation.removedNodes, function (removedNode) {
      if (removedNode.nodeType === 1) {
        if (removedNode.hasAttribute('[data-simplebar="init"]')) {
          SimpleBar.instances.has(removedNode) && SimpleBar.instances.get(removedNode).unMount();
        } else {
          Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar="init"]'), function (el) {
            SimpleBar.instances.has(el) && SimpleBar.instances.get(el).unMount();
          });
        }
      }
    });
  });
};

SimpleBar.getOptions = getOptions;
/**
 * HTML API
 * Called only in a browser env.
 */

if (can_use_dom__WEBPACK_IMPORTED_MODULE_2___default.a) {
  SimpleBar.initHtmlApi();
}

/* harmony default export */ __webpack_exports__["default"] = (SimpleBar);

/***/ }),

/***/ "./node_modules/unidragger/unidragger.js":
/*!***********************************************!*\
  !*** ./node_modules/unidragger/unidragger.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Unidragger v2.3.1
 * Draggable base class
 * MIT license
 */

/*jshint browser: true, unused: true, undef: true, strict: true */
(function (window, factory) {
  // universal module definition

  /*jshint strict: false */

  /*globals define, module, require */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! unipointer/unipointer */ "./node_modules/unipointer/unipointer.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Unipointer) {
      return factory(window, Unipointer);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, Unipointer) {
  'use strict'; // -------------------------- Unidragger -------------------------- //

  function Unidragger() {} // inherit Unipointer & EvEmitter


  var proto = Unidragger.prototype = Object.create(Unipointer.prototype); // ----- bind start ----- //

  proto.bindHandles = function () {
    this._bindHandles(true);
  };

  proto.unbindHandles = function () {
    this._bindHandles(false);
  };
  /**
   * Add or remove start event
   * @param {Boolean} isAdd
   */


  proto._bindHandles = function (isAdd) {
    // munge isAdd, default to true
    isAdd = isAdd === undefined ? true : isAdd; // bind each handle

    var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';
    var touchAction = isAdd ? this._touchActionValue : '';

    for (var i = 0; i < this.handles.length; i++) {
      var handle = this.handles[i];

      this._bindStartEvent(handle, isAdd);

      handle[bindMethod]('click', this); // touch-action: none to override browser touch gestures. metafizzy/flickity#540

      if (window.PointerEvent) {
        handle.style.touchAction = touchAction;
      }
    }
  }; // prototype so it can be overwriteable by Flickity


  proto._touchActionValue = 'none'; // ----- start event ----- //

  /**
   * pointer start
   * @param {Event} event
   * @param {Event or Touch} pointer
   */

  proto.pointerDown = function (event, pointer) {
    var isOkay = this.okayPointerDown(event);

    if (!isOkay) {
      return;
    } // track start event position
    // Safari 9 overrides pageX and pageY. These values needs to be copied. flickity#842


    this.pointerDownPointer = {
      pageX: pointer.pageX,
      pageY: pointer.pageY
    };
    event.preventDefault();
    this.pointerDownBlur(); // bind move and end events

    this._bindPostStartEvents(event);

    this.emitEvent('pointerDown', [event, pointer]);
  }; // nodes that have text fields


  var cursorNodes = {
    TEXTAREA: true,
    INPUT: true,
    SELECT: true,
    OPTION: true
  }; // input types that do not have text fields

  var clickTypes = {
    radio: true,
    checkbox: true,
    button: true,
    submit: true,
    image: true,
    file: true
  }; // dismiss inputs with text fields. flickity#403, flickity#404

  proto.okayPointerDown = function (event) {
    var isCursorNode = cursorNodes[event.target.nodeName];
    var isClickType = clickTypes[event.target.type];
    var isOkay = !isCursorNode || isClickType;

    if (!isOkay) {
      this._pointerReset();
    }

    return isOkay;
  }; // kludge to blur previously focused input


  proto.pointerDownBlur = function () {
    var focused = document.activeElement; // do not blur body for IE10, metafizzy/flickity#117

    var canBlur = focused && focused.blur && focused != document.body;

    if (canBlur) {
      focused.blur();
    }
  }; // ----- move event ----- //

  /**
   * drag move
   * @param {Event} event
   * @param {Event or Touch} pointer
   */


  proto.pointerMove = function (event, pointer) {
    var moveVector = this._dragPointerMove(event, pointer);

    this.emitEvent('pointerMove', [event, pointer, moveVector]);

    this._dragMove(event, pointer, moveVector);
  }; // base pointer move logic


  proto._dragPointerMove = function (event, pointer) {
    var moveVector = {
      x: pointer.pageX - this.pointerDownPointer.pageX,
      y: pointer.pageY - this.pointerDownPointer.pageY
    }; // start drag if pointer has moved far enough to start drag

    if (!this.isDragging && this.hasDragStarted(moveVector)) {
      this._dragStart(event, pointer);
    }

    return moveVector;
  }; // condition if pointer has moved far enough to start drag


  proto.hasDragStarted = function (moveVector) {
    return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;
  }; // ----- end event ----- //

  /**
   * pointer up
   * @param {Event} event
   * @param {Event or Touch} pointer
   */


  proto.pointerUp = function (event, pointer) {
    this.emitEvent('pointerUp', [event, pointer]);

    this._dragPointerUp(event, pointer);
  };

  proto._dragPointerUp = function (event, pointer) {
    if (this.isDragging) {
      this._dragEnd(event, pointer);
    } else {
      // pointer didn't move enough for drag to start
      this._staticClick(event, pointer);
    }
  }; // -------------------------- drag -------------------------- //
  // dragStart


  proto._dragStart = function (event, pointer) {
    this.isDragging = true; // prevent clicks

    this.isPreventingClicks = true;
    this.dragStart(event, pointer);
  };

  proto.dragStart = function (event, pointer) {
    this.emitEvent('dragStart', [event, pointer]);
  }; // dragMove


  proto._dragMove = function (event, pointer, moveVector) {
    // do not drag if not dragging yet
    if (!this.isDragging) {
      return;
    }

    this.dragMove(event, pointer, moveVector);
  };

  proto.dragMove = function (event, pointer, moveVector) {
    event.preventDefault();
    this.emitEvent('dragMove', [event, pointer, moveVector]);
  }; // dragEnd


  proto._dragEnd = function (event, pointer) {
    // set flags
    this.isDragging = false; // re-enable clicking async

    setTimeout(function () {
      delete this.isPreventingClicks;
    }.bind(this));
    this.dragEnd(event, pointer);
  };

  proto.dragEnd = function (event, pointer) {
    this.emitEvent('dragEnd', [event, pointer]);
  }; // ----- onclick ----- //
  // handle all clicks and prevent clicks when dragging


  proto.onclick = function (event) {
    if (this.isPreventingClicks) {
      event.preventDefault();
    }
  }; // ----- staticClick ----- //
  // triggered after pointer down & up with no/tiny movement


  proto._staticClick = function (event, pointer) {
    // ignore emulated mouse up clicks
    if (this.isIgnoringMouseUp && event.type == 'mouseup') {
      return;
    }

    this.staticClick(event, pointer); // set flag for emulated clicks 300ms after touchend

    if (event.type != 'mouseup') {
      this.isIgnoringMouseUp = true; // reset flag after 300ms

      setTimeout(function () {
        delete this.isIgnoringMouseUp;
      }.bind(this), 400);
    }
  };

  proto.staticClick = function (event, pointer) {
    this.emitEvent('staticClick', [event, pointer]);
  }; // ----- utils ----- //


  Unidragger.getPointerPoint = Unipointer.getPointerPoint; // -----  ----- //

  return Unidragger;
});

/***/ }),

/***/ "./node_modules/unipointer/unipointer.js":
/*!***********************************************!*\
  !*** ./node_modules/unipointer/unipointer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Unipointer v2.3.0
 * base class for doing one thing with pointer event
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */
(function (window, factory) {
  // universal module definition

  /* jshint strict: false */

  /*global define, module, require */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter) {
      return factory(window, EvEmitter);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, function factory(window, EvEmitter) {
  'use strict';

  function noop() {}

  function Unipointer() {} // inherit EvEmitter


  var proto = Unipointer.prototype = Object.create(EvEmitter.prototype);

  proto.bindStartEvent = function (elem) {
    this._bindStartEvent(elem, true);
  };

  proto.unbindStartEvent = function (elem) {
    this._bindStartEvent(elem, false);
  };
  /**
   * Add or remove start event
   * @param {Boolean} isAdd - remove if falsey
   */


  proto._bindStartEvent = function (elem, isAdd) {
    // munge isAdd, default to true
    isAdd = isAdd === undefined ? true : isAdd;
    var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener'; // default to mouse events

    var startEvent = 'mousedown';

    if (window.PointerEvent) {
      // Pointer Events
      startEvent = 'pointerdown';
    } else if ('ontouchstart' in window) {
      // Touch Events. iOS Safari
      startEvent = 'touchstart';
    }

    elem[bindMethod](startEvent, this);
  }; // trigger handler methods for events


  proto.handleEvent = function (event) {
    var method = 'on' + event.type;

    if (this[method]) {
      this[method](event);
    }
  }; // returns the touch that we're keeping track of


  proto.getTouch = function (touches) {
    for (var i = 0; i < touches.length; i++) {
      var touch = touches[i];

      if (touch.identifier == this.pointerIdentifier) {
        return touch;
      }
    }
  }; // ----- start event ----- //


  proto.onmousedown = function (event) {
    // dismiss clicks from right or middle buttons
    var button = event.button;

    if (button && button !== 0 && button !== 1) {
      return;
    }

    this._pointerDown(event, event);
  };

  proto.ontouchstart = function (event) {
    this._pointerDown(event, event.changedTouches[0]);
  };

  proto.onpointerdown = function (event) {
    this._pointerDown(event, event);
  };
  /**
   * pointer start
   * @param {Event} event
   * @param {Event or Touch} pointer
   */


  proto._pointerDown = function (event, pointer) {
    // dismiss right click and other pointers
    // button = 0 is okay, 1-4 not
    if (event.button || this.isPointerDown) {
      return;
    }

    this.isPointerDown = true; // save pointer identifier to match up touch events

    this.pointerIdentifier = pointer.pointerId !== undefined ? // pointerId for pointer events, touch.indentifier for touch events
    pointer.pointerId : pointer.identifier;
    this.pointerDown(event, pointer);
  };

  proto.pointerDown = function (event, pointer) {
    this._bindPostStartEvents(event);

    this.emitEvent('pointerDown', [event, pointer]);
  }; // hash of events to be bound after start event


  var postStartEvents = {
    mousedown: ['mousemove', 'mouseup'],
    touchstart: ['touchmove', 'touchend', 'touchcancel'],
    pointerdown: ['pointermove', 'pointerup', 'pointercancel']
  };

  proto._bindPostStartEvents = function (event) {
    if (!event) {
      return;
    } // get proper events to match start event


    var events = postStartEvents[event.type]; // bind events to node

    events.forEach(function (eventName) {
      window.addEventListener(eventName, this);
    }, this); // save these arguments

    this._boundPointerEvents = events;
  };

  proto._unbindPostStartEvents = function () {
    // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)
    if (!this._boundPointerEvents) {
      return;
    }

    this._boundPointerEvents.forEach(function (eventName) {
      window.removeEventListener(eventName, this);
    }, this);

    delete this._boundPointerEvents;
  }; // ----- move event ----- //


  proto.onmousemove = function (event) {
    this._pointerMove(event, event);
  };

  proto.onpointermove = function (event) {
    if (event.pointerId == this.pointerIdentifier) {
      this._pointerMove(event, event);
    }
  };

  proto.ontouchmove = function (event) {
    var touch = this.getTouch(event.changedTouches);

    if (touch) {
      this._pointerMove(event, touch);
    }
  };
  /**
   * pointer move
   * @param {Event} event
   * @param {Event or Touch} pointer
   * @private
   */


  proto._pointerMove = function (event, pointer) {
    this.pointerMove(event, pointer);
  }; // public


  proto.pointerMove = function (event, pointer) {
    this.emitEvent('pointerMove', [event, pointer]);
  }; // ----- end event ----- //


  proto.onmouseup = function (event) {
    this._pointerUp(event, event);
  };

  proto.onpointerup = function (event) {
    if (event.pointerId == this.pointerIdentifier) {
      this._pointerUp(event, event);
    }
  };

  proto.ontouchend = function (event) {
    var touch = this.getTouch(event.changedTouches);

    if (touch) {
      this._pointerUp(event, touch);
    }
  };
  /**
   * pointer up
   * @param {Event} event
   * @param {Event or Touch} pointer
   * @private
   */


  proto._pointerUp = function (event, pointer) {
    this._pointerDone();

    this.pointerUp(event, pointer);
  }; // public


  proto.pointerUp = function (event, pointer) {
    this.emitEvent('pointerUp', [event, pointer]);
  }; // ----- pointer done ----- //
  // triggered on pointer up & pointer cancel


  proto._pointerDone = function () {
    this._pointerReset();

    this._unbindPostStartEvents();

    this.pointerDone();
  };

  proto._pointerReset = function () {
    // reset properties
    this.isPointerDown = false;
    delete this.pointerIdentifier;
  };

  proto.pointerDone = noop; // ----- pointer cancel ----- //

  proto.onpointercancel = function (event) {
    if (event.pointerId == this.pointerIdentifier) {
      this._pointerCancel(event, event);
    }
  };

  proto.ontouchcancel = function (event) {
    var touch = this.getTouch(event.changedTouches);

    if (touch) {
      this._pointerCancel(event, touch);
    }
  };
  /**
   * pointer cancel
   * @param {Event} event
   * @param {Event or Touch} pointer
   * @private
   */


  proto._pointerCancel = function (event, pointer) {
    this._pointerDone();

    this.pointerCancel(event, pointer);
  }; // public


  proto.pointerCancel = function (event, pointer) {
    this.emitEvent('pointerCancel', [event, pointer]);
  }; // -----  ----- //
  // utility function for getting x/y coords from event


  Unipointer.getPointerPoint = function (pointer) {
    return {
      x: pointer.pageX,
      y: pointer.pageY
    };
  }; // -----  ----- //


  return Unipointer;
});

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/assets/js/components/nav.js":
/*!*****************************************!*\
  !*** ./src/assets/js/components/nav.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var navTrigger = document.querySelector('nav p:nth-child(2)');
var about = document.querySelector('.container__about');
var button = document.querySelector('.container__about button');
var containerAbout = document.querySelector('.container__about');
window.addEventListener('DOMContentLoaded', function () {
  navTrigger.addEventListener('click', function () {
    about.classList.toggle('container__about--active');
    navTrigger.classList.toggle('nav__element--active');
  });
  /*
   * script for clicking outside of container
   * https://www.blustemy.io/detecting-a-click-outside-an-element-in-javascript/
   */

  containerAbout.addEventListener("click", function (evt) {
    var aboutMe = document.querySelector('.about__me');
    var targetElement = evt.target; // clicked element

    if (targetElement == aboutMe) {// true
    } else {
      about.classList.remove('container__about--active');
      navTrigger.classList.remove('nav__element--active');
    }
  });
});

/***/ }),

/***/ "./src/assets/js/components/project.js":
/*!*********************************************!*\
  !*** ./src/assets/js/components/project.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flickity */ "./node_modules/flickity/js/index.js");
/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flickity__WEBPACK_IMPORTED_MODULE_0__);

/*
 * https://codepen.io/chriscoyier/pen/XQpqZV
 */

var project = document.querySelector('.project__item');
var projects = document.querySelectorAll('.project__item');
var galleries = document.querySelectorAll('.wrapper__container__images');
var container = document.querySelector('.container'); // function flickity(item) {
//     let carousel = new Flickity('.container_images__gallery', {
//         adaptiveHeight: true,
//         lazyLoad: true,
//         pageDots: false
//     });
// }

var carousel = new flickity__WEBPACK_IMPORTED_MODULE_0___default.a('.container_images__gallery', {
  adaptiveHeight: true,
  lazyLoad: true,
  pageDots: false
});
/******************************************************
 * Script for both
 ******************************************************/

projects.forEach(function (project) {
  project.addEventListener('click', function (e) {
    e.preventDefault();
    removeActiveProject();
    addActiveProject(project);
    clickOutside(project);
  });
  project.addEventListener('mousemove', function (e) {
    e.preventDefault;
    removeHoverProject();
    removeImageHover();
    addHoverProject(project);
  });
  project.addEventListener('mouseout', function (e) {
    e.preventDefault;
    removeSomethingProject(project);
  });
});
/******************************************************
 * Remove Active State
 ******************************************************/

var removeActiveProject = function removeActiveProject() {
  projects.forEach(function (project) {
    project.classList.remove('is-active');
  });
  galleries.forEach(function (gallery) {
    gallery.classList.remove('is-active');
  });
};

var removeSomethingProject = function removeSomethingProject(project) {
  var href = project.getAttribute('href');
  var matchingSection = document.querySelector(href);

  if (project.classList.contains('is-hover')) {
    project.classList.remove('is-hover');
    matchingSection.classList.remove('is-hover');
    matchingSection.querySelector('.container_images__gallery').style.opacity = '0';
  }
};
/******************************************************
 * Add Active State
 ******************************************************/


var addActiveProject = function addActiveProject(project) {
  var href = project.getAttribute('href');
  var matchingSection = document.querySelector(href); // Project List

  project.classList.add('is-active');
  project.classList.remove('is-hover'); // Project Gallery Item

  matchingSection.classList.add('is-active');
  matchingSection.classList.remove('is-hover'); // Show Project Gallery Item

  matchingSection.querySelector('.container_images__info').style.opacity = '1';
  matchingSection.querySelector('.container_images__gallery').style.opacity = '1'; // Reduce Opacity On Main Container

  container.style.opacity = '0.1';
};

var clickOutside = function clickOutside(project) {
  var href = project.getAttribute('href');
  var matchingSection = document.querySelector(href);
  matchingSection.addEventListener("click", function (evt) {
    evt.preventDefault(); // this select the matchingSection child

    var flyoutElement = matchingSection.querySelector('.container_images__gallery'),
        targetElement = evt.target; // clicked element

    do {
      if (targetElement == flyoutElement) {
        // This is a click inside. Do nothing, just return.
        console.log('Clicked inside!');
        return;
      } // Go up the DOM


      targetElement = targetElement.parentNode;
    } while (targetElement); // This is a click outside.


    matchingSection.classList.remove('is-active');
    matchingSection.querySelector('.container_images__info').style.opacity = '0';
    matchingSection.querySelector('.container_images__gallery').style.opacity = '0';
    container.style.opacity = '1';
    project.classList.remove('is-active'); // reinitiate the carousel to the first slide for 1s delay

    setTimeout(function () {
      carousel.selectCell(0);
      console.log('flickity is reinitiate');
    }, 700);
  });
};
/******************************************************
 *  Remove Hover State
 ******************************************************/


var removeHoverProject = function removeHoverProject() {
  projects.forEach(function (project) {
    project.classList.remove('is-hover');
  });
  galleries.forEach(function (gallery) {
    gallery.classList.remove('is-hover');
    gallery.querySelector('.container_images__gallery').style.opacity = '0';
  });
};
/******************************************************
 * Add Hover State
 ******************************************************/


var addHoverProject = function addHoverProject(project) {
  project.classList.add('is-hover');
  var href = project.getAttribute('href');
  var matchingSection = document.querySelector(href);
  matchingSection.classList.add('is-hover');
  matchingSection.querySelector('.container_images__gallery').style.opacity = '0.3';
};

var removeImageHover = function removeImageHover() {
  var href = project.getAttribute('href');
  var matchingSection = document.querySelector(href);

  if (project.classList.contains('is-hover')) {
    project.classList.remove('is-hover');
    matchingSection.classList.remove('is-hover');
    matchingSection.querySelector('.container_images__gallery').style.opacity = '0';
  }
};

/***/ }),

/***/ "./src/assets/js/components/scrollBar.js":
/*!***********************************************!*\
  !*** ./src/assets/js/components/scrollBar.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var simplebar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplebar */ "./node_modules/simplebar/dist/simplebar.esm.js");
/*
 * plugin simpleBar : https://github.com/Grsmto/simplebar/tree/master/packages/simplebar
 * on stylise la bar de scroll avec la class .simplebar-scrollbar
 * .simplebar-scrollbar-thumb
 */

new simplebar__WEBPACK_IMPORTED_MODULE_0__["default"](document.querySelector('.container__projects'), {
  direction: 'rtl'
});

/***/ }),

/***/ "./src/assets/js/main.js":
/*!*******************************!*\
  !*** ./src/assets/js/main.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_nav__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/nav */ "./src/assets/js/components/nav.js");
/* harmony import */ var _components_nav__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_components_nav__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_scrollBar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/scrollBar */ "./src/assets/js/components/scrollBar.js");
/* harmony import */ var _components_project__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/project */ "./src/assets/js/components/project.js");




/***/ }),

/***/ 0:
/*!*************************************!*\
  !*** multi ./src/assets/js/main.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/ametthey/Local Sites/julia-garcin/app/public/wp-content/themes/_themename/src/assets/js/main.js */"./src/assets/js/main.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nhbi11c2UtZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL251bWJlci1wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtc3RpY2t5LWhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzYW5kcm8tbWF0Y2hlcy1zZWxlY3Rvci9tYXRjaGVzLXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldi1lbWl0dGVyL2V2LWVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zpenp5LXVpLXV0aWxzL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9hZGQtcmVtb3ZlLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL2FuaW1hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL2NlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL2RyYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL2ZsaWNraXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvbGF6eWxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL3BhZ2UtZG90cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvcGxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9wcmV2LW5leHQtYnV0dG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9zbGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLm1lbW9pemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9zY3JvbGxiYXItd2lkdGguanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uLi9zcmMvc2ltcGxlYmFyLmpzIiwid2VicGFjazovLy8uLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaWRyYWdnZXIvdW5pZHJhZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5pcG9pbnRlci91bmlwb2ludGVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9qcy9jb21wb25lbnRzL25hdi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2pzL2NvbXBvbmVudHMvcHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2pzL2NvbXBvbmVudHMvc2Nyb2xsQmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvanMvbWFpbi5qcyJdLCJuYW1lcyI6WyJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXQiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJpc09iamVjdCIsInJlcXVpcmUiLCJ3ZWxsS25vd25TeW1ib2wiLCJjcmVhdGUiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90b3R5cGUiLCJBcnJheSIsInByb3RvdHlwZSIsInVuZGVmaW5lZCIsImYiLCJjb25maWd1cmFibGUiLCJ2YWx1ZSIsImtleSIsImNoYXJBdCIsIlMiLCJpbmRleCIsInVuaWNvZGUiLCJsZW5ndGgiLCJDb25zdHJ1Y3RvciIsIm5hbWUiLCIkZm9yRWFjaCIsImZvckVhY2giLCJhcnJheU1ldGhvZElzU3RyaWN0IiwiYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgiLCJTVFJJQ1RfTUVUSE9EIiwiVVNFU19UT19MRU5HVEgiLCJjYWxsYmFja2ZuIiwiYXJndW1lbnRzIiwidG9JbmRleGVkT2JqZWN0IiwidG9MZW5ndGgiLCJ0b0Fic29sdXRlSW5kZXgiLCJjcmVhdGVNZXRob2QiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZWwiLCJmcm9tSW5kZXgiLCJPIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwiYmluZCIsIkluZGV4ZWRPYmplY3QiLCJ0b09iamVjdCIsImFycmF5U3BlY2llc0NyZWF0ZSIsInB1c2giLCJUWVBFIiwiSVNfTUFQIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIk5PX0hPTEVTIiwidGhhdCIsInNwZWNpZmljQ3JlYXRlIiwic2VsZiIsImJvdW5kRnVuY3Rpb24iLCJ0YXJnZXQiLCJyZXN1bHQiLCJjYWxsIiwibWFwIiwiZmlsdGVyIiwic29tZSIsImV2ZXJ5IiwiZmluZCIsImZpbmRJbmRleCIsImZhaWxzIiwiVjhfVkVSU0lPTiIsIlNQRUNJRVMiLCJNRVRIT0RfTkFNRSIsImFycmF5IiwiY29uc3RydWN0b3IiLCJmb28iLCJCb29sZWFuIiwiYXJndW1lbnQiLCJtZXRob2QiLCJERVNDUklQVE9SUyIsImhhcyIsImRlZmluZVByb3BlcnR5IiwiT2JqZWN0IiwiY2FjaGUiLCJ0aHJvd2VyIiwib3B0aW9ucyIsIkFDQ0VTU09SUyIsImFyZ3VtZW50MCIsImFyZ3VtZW50MSIsImVudW1lcmFibGUiLCJnZXQiLCJhRnVuY3Rpb24iLCJJU19SSUdIVCIsImFyZ3VtZW50c0xlbmd0aCIsIm1lbW8iLCJpIiwibGVmdCIsInJpZ2h0IiwiaXNBcnJheSIsIm9yaWdpbmFsQXJyYXkiLCJDIiwiYW5PYmplY3QiLCJpdGVyYXRvciIsImZuIiwiRU5UUklFUyIsImVycm9yIiwicmV0dXJuTWV0aG9kIiwiSVRFUkFUT1IiLCJTQUZFX0NMT1NJTkciLCJjYWxsZWQiLCJpdGVyYXRvcldpdGhSZXR1cm4iLCJuZXh0IiwiZG9uZSIsImZyb20iLCJleGVjIiwiU0tJUF9DTE9TSU5HIiwiSVRFUkFUSU9OX1NVUFBPUlQiLCJvYmplY3QiLCJ0b1N0cmluZyIsInNsaWNlIiwiVE9fU1RSSU5HX1RBR19TVVBQT1JUIiwiY2xhc3NvZlJhdyIsIlRPX1NUUklOR19UQUciLCJDT1JSRUNUX0FSR1VNRU5UUyIsInRyeUdldCIsInRhZyIsImNhbGxlZSIsInJlZGVmaW5lQWxsIiwiZ2V0V2Vha0RhdGEiLCJhbkluc3RhbmNlIiwiaXRlcmF0ZSIsIkFycmF5SXRlcmF0aW9uTW9kdWxlIiwiJGhhcyIsIkludGVybmFsU3RhdGVNb2R1bGUiLCJzZXRJbnRlcm5hbFN0YXRlIiwic2V0IiwiaW50ZXJuYWxTdGF0ZUdldHRlckZvciIsImdldHRlckZvciIsImlkIiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsInN0b3JlIiwiZnJvemVuIiwiVW5jYXVnaHRGcm96ZW5TdG9yZSIsImVudHJpZXMiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCJlbnRyeSIsInNwbGljZSIsImdldENvbnN0cnVjdG9yIiwid3JhcHBlciIsIkNPTlNUUlVDVE9SX05BTUUiLCJBRERFUiIsIml0ZXJhYmxlIiwidHlwZSIsImdldEludGVybmFsU3RhdGUiLCJkZWZpbmUiLCJzdGF0ZSIsImRhdGEiLCJhZGQiLCIkIiwiZ2xvYmFsIiwiaXNGb3JjZWQiLCJyZWRlZmluZSIsIkludGVybmFsTWV0YWRhdGFNb2R1bGUiLCJjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24iLCJzZXRUb1N0cmluZ1RhZyIsImluaGVyaXRJZlJlcXVpcmVkIiwiY29tbW9uIiwiSVNfV0VBSyIsIk5hdGl2ZUNvbnN0cnVjdG9yIiwiTmF0aXZlUHJvdG90eXBlIiwiZXhwb3J0ZWQiLCJmaXhNZXRob2QiLCJLRVkiLCJuYXRpdmVNZXRob2QiLCJSRVFVSVJFRCIsImluc3RhbmNlIiwiSEFTTlRfQ0hBSU5JTkciLCJUSFJPV1NfT05fUFJJTUlUSVZFUyIsIkFDQ0VQVF9JVEVSQUJMRVMiLCJCVUdHWV9aRVJPIiwiJGluc3RhbmNlIiwiZHVtbXkiLCJjbGVhciIsImZvcmNlZCIsInNldFN0cm9uZyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUiLCJzb3VyY2UiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRiIsImdldFByb3RvdHlwZU9mIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJJdGVyYXRvcnMiLCJyZXR1cm5UaGlzIiwiSXRlcmF0b3JDb25zdHJ1Y3RvciIsIk5BTUUiLCJiaXRtYXAiLCJ3cml0YWJsZSIsImNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IiLCJzZXRQcm90b3R5cGVPZiIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSIsIklTX1BVUkUiLCJJdGVyYXRvcnNDb3JlIiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyIsIktFWVMiLCJWQUxVRVMiLCJJdGVyYWJsZSIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCJnZXRJdGVyYXRpb25NZXRob2QiLCJLSU5EIiwiZGVmYXVsdEl0ZXJhdG9yIiwiSXRlcmFibGVQcm90b3R5cGUiLCJ2YWx1ZXMiLCJJTkNPUlJFQ1RfVkFMVUVTX05BTUUiLCJuYXRpdmVJdGVyYXRvciIsImFueU5hdGl2ZUl0ZXJhdG9yIiwiQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlIiwibWV0aG9kcyIsInByb3RvIiwiRVhJU1RTIiwiQ1NTUnVsZUxpc3QiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiQ1NTVmFsdWVMaXN0IiwiQ2xpZW50UmVjdExpc3QiLCJET01SZWN0TGlzdCIsIkRPTVN0cmluZ0xpc3QiLCJET01Ub2tlbkxpc3QiLCJEYXRhVHJhbnNmZXJJdGVtTGlzdCIsIkZpbGVMaXN0IiwiSFRNTEFsbENvbGxlY3Rpb24iLCJIVE1MQ29sbGVjdGlvbiIsIkhUTUxGb3JtRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiTWVkaWFMaXN0IiwiTWltZVR5cGVBcnJheSIsIk5hbWVkTm9kZU1hcCIsIk5vZGVMaXN0IiwiUGFpbnRSZXF1ZXN0TGlzdCIsIlBsdWdpbiIsIlBsdWdpbkFycmF5IiwiU1ZHTGVuZ3RoTGlzdCIsIlNWR051bWJlckxpc3QiLCJTVkdQYXRoU2VnTGlzdCIsIlNWR1BvaW50TGlzdCIsIlNWR1N0cmluZ0xpc3QiLCJTVkdUcmFuc2Zvcm1MaXN0IiwiU291cmNlQnVmZmVyTGlzdCIsIlN0eWxlU2hlZXRMaXN0IiwiVGV4dFRyYWNrQ3VlTGlzdCIsIlRleHRUcmFja0xpc3QiLCJUb3VjaExpc3QiLCJnZXRCdWlsdEluIiwidXNlckFnZW50IiwicHJvY2VzcyIsInZlcnNpb25zIiwidjgiLCJtYXRjaCIsInZlcnNpb24iLCJzcGxpdCIsInNldEdsb2JhbCIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJzdGF0IiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImRlc2NyaXB0b3IiLCJub1RhcmdldEdldCIsInNoYW0iLCJyZWdleHBFeGVjIiwiUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMiLCJyZSIsImdyb3VwcyIsImEiLCJyZXBsYWNlIiwiUkVQTEFDRV9LRUVQU18kMCIsIlJFUExBQ0UiLCJSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSIsIlNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyIsIm9yaWdpbmFsRXhlYyIsImFwcGx5IiwiU1lNQk9MIiwiREVMRUdBVEVTX1RPX1NZTUJPTCIsIkRFTEVHQVRFU19UT19FWEVDIiwiZXhlY0NhbGxlZCIsImZsYWdzIiwibmF0aXZlUmVnRXhwTWV0aG9kIiwicmVnZXhwIiwic3RyIiwiYXJnMiIsImZvcmNlU3RyaW5nTWV0aG9kIiwic3RyaW5nTWV0aG9kIiwicmVnZXhNZXRob2QiLCJSZWdFeHAiLCJzdHJpbmciLCJhcmciLCJpc0V4dGVuc2libGUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImIiLCJjIiwicGF0aCIsInZhcmlhYmxlIiwibmFtZXNwYWNlIiwiY2xhc3NvZiIsImNoZWNrIiwiTWF0aCIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJXcmFwcGVyIiwiTmV3VGFyZ2V0IiwiTmV3VGFyZ2V0UHJvdG90eXBlIiwiZnVuY3Rpb25Ub1N0cmluZyIsImluc3BlY3RTb3VyY2UiLCJoaWRkZW5LZXlzIiwidWlkIiwiRlJFRVpJTkciLCJNRVRBREFUQSIsInNldE1ldGFkYXRhIiwib2JqZWN0SUQiLCJ3ZWFrRGF0YSIsImZhc3RLZXkiLCJvbkZyZWV6ZSIsIm1ldGEiLCJOQVRJVkVfV0VBS19NQVAiLCJvYmplY3RIYXMiLCJzaGFyZWRLZXkiLCJXZWFrTWFwIiwiZW5mb3JjZSIsIndtZ2V0Iiwid21oYXMiLCJ3bXNldCIsIm1ldGFkYXRhIiwiU1RBVEUiLCJyZXBsYWNlbWVudCIsImZlYXR1cmUiLCJkZXRlY3Rpb24iLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInRvTG93ZXJDYXNlIiwiaXNBcnJheUl0ZXJhdG9yTWV0aG9kIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nIiwiUmVzdWx0Iiwic3RvcHBlZCIsIkFTX0VOVFJJRVMiLCJJU19JVEVSQVRPUiIsIml0ZXJGbiIsInN0ZXAiLCJzdG9wIiwiUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlIiwiYXJyYXlJdGVyYXRvciIsImdldE93blByb3BlcnR5U3ltYm9scyIsIlN5bWJvbCIsInRlc3QiLCJ0cmltIiwid2hpdGVzcGFjZXMiLCIkcGFyc2VJbnQiLCJwYXJzZUludCIsImhleCIsInJhZGl4Iiwib2JqZWN0S2V5cyIsImdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlIiwibmF0aXZlQXNzaWduIiwiYXNzaWduIiwiQSIsIkIiLCJzeW1ib2wiLCJhbHBoYWJldCIsImNociIsImpvaW4iLCJUIiwiY29uY2F0IiwiaiIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtQnVnS2V5cyIsImh0bWwiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJHVCIsIkxUIiwiUFJPVE9UWVBFIiwiU0NSSVBUIiwiSUVfUFJPVE8iLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwiTnVsbFByb3RvT2JqZWN0IiwiZG9tYWluIiwiQWN0aXZlWE9iamVjdCIsIlByb3BlcnRpZXMiLCJJRThfRE9NX0RFRklORSIsInRvUHJpbWl0aXZlIiwibmF0aXZlRGVmaW5lUHJvcGVydHkiLCJQIiwiQXR0cmlidXRlcyIsIm5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImludGVybmFsT2JqZWN0S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIiLCJPYmplY3RQcm90b3R5cGUiLCJuYW1lcyIsIm5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlIiwiTkFTSE9STl9CVUciLCJWIiwiYVBvc3NpYmxlUHJvdG90eXBlIiwiQ09SUkVDVF9TRVRURVIiLCJzZXR0ZXIiLCJfX3Byb3RvX18iLCJnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlIiwiZW5mb3JjZUludGVybmFsU3RhdGUiLCJURU1QTEFURSIsInVuc2FmZSIsInNpbXBsZSIsIlIiLCJyZWdleHBGbGFncyIsInN0aWNreUhlbHBlcnMiLCJuYXRpdmVFeGVjIiwibmF0aXZlUmVwbGFjZSIsInBhdGNoZWRFeGVjIiwiVVBEQVRFU19MQVNUX0lOREVYX1dST05HIiwicmUxIiwicmUyIiwibGFzdEluZGV4IiwiVU5TVVBQT1JURURfWSIsIkJST0tFTl9DQVJFVCIsIk5QQ0dfSU5DTFVERUQiLCJQQVRDSCIsInJlQ29weSIsInN0aWNreSIsImNoYXJzQWRkZWQiLCJzdHJDb3B5IiwibXVsdGlsaW5lIiwiaW5wdXQiLCJpZ25vcmVDYXNlIiwiZG90QWxsIiwiUkUiLCJzIiwiVEFHIiwic2hhcmVkIiwiU0hBUkVEIiwibW9kZSIsImNvcHlyaWdodCIsInRvSW50ZWdlciIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJDT05WRVJUX1RPX1NUUklORyIsInBvcyIsInBvc2l0aW9uIiwic2l6ZSIsImZpcnN0Iiwic2Vjb25kIiwiY2hhckNvZGVBdCIsImNvZGVBdCIsIndoaXRlc3BhY2UiLCJsdHJpbSIsInJ0cmltIiwic3RhcnQiLCJlbmQiLCJtYXgiLCJtaW4iLCJpbnRlZ2VyIiwiY2VpbCIsImZsb29yIiwiaXNOYU4iLCJQUkVGRVJSRURfU1RSSU5HIiwidmFsIiwidmFsdWVPZiIsInBvc3RmaXgiLCJyYW5kb20iLCJOQVRJVkVfU1lNQk9MIiwiVVNFX1NZTUJPTF9BU19VSUQiLCJXZWxsS25vd25TeW1ib2xzU3RvcmUiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwiJGZpbHRlciIsImFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQiLCJIQVNfU1BFQ0lFU19TVVBQT1JUIiwiYWRkVG9VbnNjb3BhYmxlcyIsImRlZmluZUl0ZXJhdG9yIiwiQVJSQVlfSVRFUkFUT1IiLCJpdGVyYXRlZCIsImtpbmQiLCJBcmd1bWVudHMiLCIkcmVkdWNlIiwicmVkdWNlIiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nIiwibmFtZVJFIiwicGFyc2VJbnRJbXBsZW1lbnRhdGlvbiIsIlNUUklOR19JVEVSQVRPUiIsInBvaW50IiwiZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMiLCJhZHZhbmNlU3RyaW5nSW5kZXgiLCJyZWdFeHBFeGVjIiwiTUFUQ0giLCJuYXRpdmVNYXRjaCIsIm1heWJlQ2FsbE5hdGl2ZSIsIm1hdGNoZXIiLCJyZXMiLCJyeCIsImZ1bGxVbmljb2RlIiwibiIsIm1hdGNoU3RyIiwiU1VCU1RJVFVUSU9OX1NZTUJPTFMiLCJTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCIsIm1heWJlVG9TdHJpbmciLCJyZWFzb24iLCJVTlNBRkVfU1VCU1RJVFVURSIsInNlYXJjaFZhbHVlIiwicmVwbGFjZVZhbHVlIiwicmVwbGFjZXIiLCJmdW5jdGlvbmFsUmVwbGFjZSIsInJlc3VsdHMiLCJhY2N1bXVsYXRlZFJlc3VsdCIsIm5leHRTb3VyY2VQb3NpdGlvbiIsIm1hdGNoZWQiLCJjYXB0dXJlcyIsIm5hbWVkQ2FwdHVyZXMiLCJyZXBsYWNlckFyZ3MiLCJnZXRTdWJzdGl0dXRpb24iLCJ0YWlsUG9zIiwibSIsInN5bWJvbHMiLCJjaCIsImNhcHR1cmUiLCJjb2xsZWN0aW9uIiwiY29sbGVjdGlvbldlYWsiLCJlbmZvcmNlSXRlcm5hbFN0YXRlIiwiSVNfSUUxMSIsIkludGVybmFsV2Vha01hcCIsImluaXQiLCIkV2Vha01hcCIsIldlYWtNYXBQcm90b3R5cGUiLCJuYXRpdmVEZWxldGUiLCJuYXRpdmVIYXMiLCJuYXRpdmVHZXQiLCJuYXRpdmVTZXQiLCJET01JdGVyYWJsZXMiLCJDT0xMRUNUSU9OX05BTUUiLCJDb2xsZWN0aW9uIiwiQ29sbGVjdGlvblByb3RvdHlwZSIsIkFycmF5SXRlcmF0b3JNZXRob2RzIiwiQXJyYXlWYWx1ZXMiLCJmYWN0b3J5IiwibWF0Y2hlc01ldGhvZCIsIkVsZW1Qcm90byIsIkVsZW1lbnQiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwicHJlZml4ZXMiLCJwcmVmaXgiLCJlbGVtIiwic2VsZWN0b3IiLCJFdkVtaXR0ZXIiLCJvbiIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwiZXZlbnRzIiwiX2V2ZW50cyIsImxpc3RlbmVycyIsIm9uY2UiLCJvbmNlRXZlbnRzIiwiX29uY2VFdmVudHMiLCJvbmNlTGlzdGVuZXJzIiwib2ZmIiwiZW1pdEV2ZW50IiwiYXJncyIsImlzT25jZSIsImFsbE9mZiIsInV0aWxzIiwiZXh0ZW5kIiwicHJvcCIsIm1vZHVsbyIsIm51bSIsImRpdiIsImFycmF5U2xpY2UiLCJtYWtlQXJyYXkiLCJvYmoiLCJpc0FycmF5TGlrZSIsInJlbW92ZUZyb20iLCJhcnkiLCJnZXRQYXJlbnQiLCJwYXJlbnROb2RlIiwiYm9keSIsImdldFF1ZXJ5RWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJoYW5kbGVFdmVudCIsImV2ZW50IiwiZmlsdGVyRmluZEVsZW1lbnRzIiwiZWxlbXMiLCJmZkVsZW1zIiwiSFRNTEVsZW1lbnQiLCJjaGlsZEVsZW1zIiwicXVlcnlTZWxlY3RvckFsbCIsImRlYm91bmNlTWV0aG9kIiwiX2NsYXNzIiwibWV0aG9kTmFtZSIsInRocmVzaG9sZCIsInRpbWVvdXROYW1lIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsIl90aGlzIiwic2V0VGltZW91dCIsImRvY1JlYWR5IiwiY2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRvRGFzaGVkIiwiJDEiLCIkMiIsImNvbnNvbGUiLCJodG1sSW5pdCIsIldpZGdldENsYXNzIiwiZGFzaGVkTmFtZXNwYWNlIiwiZGF0YUF0dHIiLCJkYXRhQXR0ckVsZW1zIiwianNEYXNoRWxlbXMiLCJkYXRhT3B0aW9uc0F0dHIiLCJqUXVlcnkiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwiSlNPTiIsInBhcnNlIiwiY2xhc3NOYW1lIiwiRmxpY2tpdHkiLCJnZXRDZWxsc0ZyYWdtZW50IiwiY2VsbHMiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJjZWxsIiwiZWxlbWVudCIsImluc2VydCIsIl9tYWtlQ2VsbHMiLCJsZW4iLCJpc0FwcGVuZCIsInNsaWRlciIsImluc2VydENlbGxFbGVtZW50IiwiaW5zZXJ0QmVmb3JlIiwiZW5kQ2VsbHMiLCJfc2l6ZUNlbGxzIiwiY2VsbENoYW5nZSIsImFwcGVuZCIsInByZXBlbmQiLCJyZW1vdmUiLCJnZXRDZWxscyIsIm1pbkNlbGxJbmRleCIsImNlbGxTaXplQ2hhbmdlIiwiZ2V0Q2VsbCIsImdldFNpemUiLCJjaGFuZ2VkQ2VsbEluZGV4IiwiaXNQb3NpdGlvbmluZ1NsaWRlciIsInByZXZTZWxlY3RlZEVsZW0iLCJzZWxlY3RlZEVsZW1lbnQiLCJfcG9zaXRpb25DZWxscyIsIl9nZXRXcmFwU2hpZnRDZWxscyIsInNldEdhbGxlcnlTaXplIiwic2VsZWN0ZWRJbmRleCIsImdldENlbGxTbGlkZUluZGV4Iiwic2xpZGVzIiwic2VsZWN0IiwicG9zaXRpb25TbGlkZXJBdFNlbGVjdGVkIiwic3RhcnRBbmltYXRpb24iLCJpc0FuaW1hdGluZyIsInJlc3RpbmdGcmFtZXMiLCJhbmltYXRlIiwiYXBwbHlEcmFnRm9yY2UiLCJhcHBseVNlbGVjdGVkQXR0cmFjdGlvbiIsInByZXZpb3VzWCIsIngiLCJpbnRlZ3JhdGVQaHlzaWNzIiwicG9zaXRpb25TbGlkZXIiLCJzZXR0bGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhbmltYXRlRnJhbWUiLCJ3cmFwQXJvdW5kIiwic2xpZGVhYmxlV2lkdGgiLCJzaGlmdFdyYXBDZWxscyIsInNldFRyYW5zbGF0ZVgiLCJkaXNwYXRjaFNjcm9sbEV2ZW50IiwiaXMzZCIsImN1cnNvclBvc2l0aW9uIiwicmlnaHRUb0xlZnQiLCJ0cmFuc2xhdGVYIiwiZ2V0UG9zaXRpb25WYWx1ZSIsInRyYW5zZm9ybSIsImZpcnN0U2xpZGUiLCJwb3NpdGlvblgiLCJwcm9ncmVzcyIsInNsaWRlc1dpZHRoIiwiZGlzcGF0Y2hFdmVudCIsInNlbGVjdGVkU2xpZGUiLCJ2ZWxvY2l0eSIsInBlcmNlbnRQb3NpdGlvbiIsInJvdW5kIiwiaW5uZXJXaWR0aCIsImlzUG9pbnRlckRvd24iLCJpc0ZyZWVTY3JvbGxpbmciLCJiZWZvcmVHYXAiLCJfc2hpZnRDZWxscyIsImJlZm9yZVNoaWZ0Q2VsbHMiLCJhZnRlckdhcCIsImFmdGVyU2hpZnRDZWxscyIsImdhcCIsInNoaWZ0IiwiY2VsbFNoaWZ0Iiwid3JhcFNoaWZ0Iiwib3V0ZXJXaWR0aCIsIl91bnNoaWZ0Q2VsbHMiLCJnZXRGcmljdGlvbkZhY3RvciIsImFwcGx5Rm9yY2UiLCJmb3JjZSIsImdldFJlc3RpbmdQb3NpdGlvbiIsImlzRHJhZ2dhYmxlIiwiZHJhZ1ZlbG9jaXR5IiwiZHJhZ1giLCJkcmFnRm9yY2UiLCJkcmFnRG93biIsImRpc3RhbmNlIiwic2VsZWN0ZWRBdHRyYWN0aW9uIiwiQ2VsbCIsInBhcmVudCIsInNldEF0dHJpYnV0ZSIsImRlc3Ryb3kiLCJ1bnNlbGVjdCIsInNpZGUiLCJvcmlnaW5TaWRlIiwic2V0UG9zaXRpb24iLCJ1cGRhdGVUYXJnZXQiLCJyZW5kZXJQb3NpdGlvbiIsInNldERlZmF1bHRUYXJnZXQiLCJtYXJnaW5Qcm9wZXJ0eSIsIndpZHRoIiwiY2VsbEFsaWduIiwiY2xhc3NMaXN0IiwicmVtb3ZlQXR0cmlidXRlIiwicmVtb3ZlQ2hpbGQiLCJVbmlkcmFnZ2VyIiwiZGVmYXVsdHMiLCJkcmFnZ2FibGUiLCJkcmFnVGhyZXNob2xkIiwiY3JlYXRlTWV0aG9kcyIsIl90b3VjaEFjdGlvblZhbHVlIiwiaXNUb3VjaCIsImlzVG91Y2htb3ZlU2Nyb2xsQ2FuY2VsZWQiLCJfY3JlYXRlRHJhZyIsIm9uQWN0aXZhdGVEcmFnIiwiX3VpQ2hhbmdlRHJhZyIsIm9uRGVhY3RpdmF0ZURyYWciLCJ1cGRhdGVEcmFnZ2FibGUiLCJoYW5kbGVzIiwidmlld3BvcnQiLCJiaW5kSGFuZGxlcyIsInVuYmluZEhhbmRsZXMiLCJiaW5kRHJhZyIsInVuYmluZERyYWciLCJwb2ludGVyRG93biIsInBvaW50ZXIiLCJfcG9pbnRlckRvd25EZWZhdWx0IiwiaXNPa2F5Iiwib2theVBvaW50ZXJEb3duIiwiX3BvaW50ZXJEb3duUHJldmVudERlZmF1bHQiLCJwb2ludGVyRG93bkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsInBvaW50ZXJEb3duQmx1ciIsInBvaW50ZXJEb3duU2Nyb2xsIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJwb2ludGVyRG93blBvaW50ZXIiLCJwYWdlWCIsInBhZ2VZIiwiX2JpbmRQb3N0U3RhcnRFdmVudHMiLCJmb2N1c05vZGVzIiwiSU5QVVQiLCJURVhUQVJFQSIsIlNFTEVDVCIsImlzRm9jdXNOb2RlIiwibm9kZU5hbWUiLCJmb2N1cyIsImlzVG91Y2hTdGFydCIsImlzVG91Y2hQb2ludGVyIiwicG9pbnRlclR5cGUiLCJwcmV2ZW50RGVmYXVsdCIsImhhc0RyYWdTdGFydGVkIiwibW92ZVZlY3RvciIsImFicyIsInBvaW50ZXJVcCIsImlzVG91Y2hTY3JvbGxpbmciLCJfZHJhZ1BvaW50ZXJVcCIsInBvaW50ZXJEb25lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRyYWdTdGFydCIsImRyYWdTdGFydFBvc2l0aW9uIiwicG9pbnRlck1vdmUiLCJfZHJhZ1BvaW50ZXJNb3ZlIiwiX2RyYWdNb3ZlIiwiZHJhZ01vdmUiLCJwcmV2aW91c0RyYWdYIiwiZGlyZWN0aW9uIiwib3JpZ2luQm91bmQiLCJlbmRCb3VuZCIsImdldExhc3RTbGlkZSIsImRyYWdNb3ZlVGltZSIsIkRhdGUiLCJkcmFnRW5kIiwiZnJlZVNjcm9sbCIsImRyYWdFbmRSZXN0aW5nU2VsZWN0IiwicmVzdGluZ1giLCJkcmFnRW5kQm9vc3RTZWxlY3QiLCJpc0RyYWdTZWxlY3QiLCJnZXRTbGlkZURpc3RhbmNlIiwicG9zaXRpdmVSZXN0aW5nIiwiX2dldENsb3Nlc3RSZXN0aW5nIiwibmVnYXRpdmVSZXN0aW5nIiwiaW5jcmVtZW50IiwibWluRGlzdGFuY2UiLCJJbmZpbml0eSIsImNvbmRpdGlvbiIsImNvbnRhaW4iLCJkIiwibWQiLCJpc1dyYXBBcm91bmQiLCJzbGlkZUluZGV4Iiwic2xpZGUiLCJ3cmFwIiwiZGVsdGEiLCJzdGF0aWNDbGljayIsImNsaWNrZWRDZWxsIiwiZ2V0UGFyZW50Q2VsbCIsImNlbGxFbGVtIiwiY2VsbEluZGV4Iiwib25zY3JvbGwiLCJzY3JvbGwiLCJzY3JvbGxNb3ZlWCIsInNjcm9sbE1vdmVZIiwieSIsIl9wb2ludGVyRG9uZSIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJTbGlkZSIsImFuaW1hdGVQcm90b3R5cGUiLCJnZXRDb21wdXRlZFN0eWxlIiwibW92ZUVsZW1lbnRzIiwidG9FbGVtIiwiR1VJRCIsImluc3RhbmNlcyIsInF1ZXJ5RWxlbWVudCIsImZsaWNraXR5R1VJRCIsIm9wdGlvbiIsIiRlbGVtZW50IiwiX2NyZWF0ZSIsImFjY2Vzc2liaWxpdHkiLCJmcmVlU2Nyb2xsRnJpY3Rpb24iLCJmcmljdGlvbiIsIm5hbWVzcGFjZUpRdWVyeUV2ZW50cyIsInJlc2l6ZSIsImd1aWQiLCJfY3JlYXRlU2xpZGVyIiwid2F0Y2hDU1MiLCJhY3RpdmF0ZSIsIm9wdHMiLCJpc0FjdGl2ZSIsImNlbGxFbGVtcyIsIl9maWx0ZXJGaW5kQ2VsbEVsZW1lbnRzIiwiY2hpbGRyZW4iLCJyZWxvYWRDZWxscyIsInRhYkluZGV4Iiwic2VsZWN0SW5pdGlhbEluZGV4IiwiaXNJbml0QWN0aXZhdGVkIiwiY2VsbFNlbGVjdG9yIiwicG9zaXRpb25DZWxscyIsImdldExhc3RDZWxsIiwibWF4Q2VsbEhlaWdodCIsImNlbGxYIiwic3RhcnRDZWxsIiwib3V0ZXJIZWlnaHQiLCJ1cGRhdGVTbGlkZXMiLCJfY29udGFpblNsaWRlcyIsImlzT3JpZ2luTGVmdCIsIm5leHRNYXJnaW4iLCJjYW5DZWxsRml0IiwiX2dldENhbkNlbGxGaXQiLCJhZGRDZWxsIiwic2xpZGVXaWR0aCIsImZpcnN0TWFyZ2luIiwidXBkYXRlU2VsZWN0ZWRTbGlkZSIsImdyb3VwQ2VsbHMiLCJudW1iZXIiLCJwZXJjZW50TWF0Y2giLCJwZXJjZW50IiwiX2luaXQiLCJyZXBvc2l0aW9uIiwic2V0Q2VsbEFsaWduIiwiY2VsbEFsaWduU2hvcnRoYW5kcyIsImNlbnRlciIsInNob3J0aGFuZCIsImhlaWdodCIsImFkYXB0aXZlSGVpZ2h0IiwiZ2FwWCIsIl9nZXRHYXBDZWxscyIsImlzUmlnaHRUb0xlZnQiLCJiZWdpbk1hcmdpbiIsImVuZE1hcmdpbiIsImNvbnRlbnRXaWR0aCIsImlzQ29udGVudFNtYWxsZXIiLCJiZWdpbkJvdW5kIiwiZW1pdEFyZ3MiLCIkZXZlbnQiLCJqUUV2ZW50IiwiRXZlbnQiLCJ0cmlnZ2VyIiwiaXNXcmFwIiwiaXNJbnN0YW50IiwiX3dyYXBTZWxlY3QiLCJwcmV2SW5kZXgiLCJpc1dyYXBwaW5nIiwid3JhcEluZGV4IiwiYmFja1dyYXBEZWx0YSIsImZvcmV3YXJkV3JhcERlbHRhIiwicHJldmlvdXMiLCJ1bnNlbGVjdFNlbGVjdGVkU2xpZGUiLCJzZWxlY3RlZENlbGxzIiwic2VsZWN0ZWRFbGVtZW50cyIsImdldENlbGxFbGVtZW50cyIsInNlbGVjdGVkQ2VsbCIsImluaXRpYWxJbmRleCIsInF1ZXJ5Q2VsbCIsInNlbGVjdENlbGwiLCJnZXRBZGphY2VudENlbGxFbGVtZW50cyIsImFkakNvdW50IiwidWlDaGFuZ2UiLCJjaGlsZFVJUG9pbnRlckRvd24iLCJvbnJlc2l6ZSIsIndhdGNoT3B0aW9uIiwiYWZ0ZXJDb250ZW50IiwiZGVhY3RpdmF0ZSIsIm9ua2V5ZG93biIsImlzTm90Rm9jdXNlZCIsImhhbmRsZXIiLCJrZXlib2FyZEhhbmRsZXJzIiwia2V5Q29kZSIsImxlZnRNZXRob2QiLCJyaWdodE1ldGhvZCIsInByZXZTY3JvbGxZIiwicHJldmVudFNjcm9sbCIsInNjcm9sbFRvIiwicmVtb3ZlRGF0YSIsImJyaWRnZXQiLCJzZXRKUXVlcnkiLCJqcSIsIl9jcmVhdGVMYXp5bG9hZCIsImxhenlMb2FkIiwibGF6eUltYWdlcyIsImxhenlDZWxsSW1hZ2VzIiwiZ2V0Q2VsbExhenlJbWFnZXMiLCJpbWciLCJMYXp5TG9hZGVyIiwibGF6eWxvYWRBdHRyIiwic3JjQXR0ciIsInNyY3NldEF0dHIiLCJsYXp5U2VsZWN0b3IiLCJpbWdzIiwiZmxpY2tpdHkiLCJsb2FkIiwic3Jjc2V0Iiwib25sb2FkIiwiY29tcGxldGUiLCJvbmVycm9yIiwiVW5pcG9pbnRlciIsIlBhZ2VEb3RzIiwiaG9sZGVyIiwiZG90cyIsImhhbmRsZUNsaWNrIiwib25DbGljayIsInNldERvdHMiLCJiaW5kU3RhcnRFdmVudCIsInVuYmluZFN0YXJ0RXZlbnQiLCJhZGREb3RzIiwicmVtb3ZlRG90cyIsImNvdW50IiwibmV3RG90cyIsImRvdCIsInVwZGF0ZVNlbGVjdGVkIiwic2VsZWN0ZWREb3QiLCJvblRhcCIsInBhZ2VEb3RzIiwiX2NyZWF0ZVBhZ2VEb3RzIiwiYWN0aXZhdGVQYWdlRG90cyIsInVwZGF0ZVNlbGVjdGVkUGFnZURvdHMiLCJ1cGRhdGVQYWdlRG90cyIsImRlYWN0aXZhdGVQYWdlRG90cyIsIlBsYXllciIsIm9uVmlzaWJpbGl0eUNoYW5nZSIsInZpc2liaWxpdHlDaGFuZ2UiLCJvblZpc2liaWxpdHlQbGF5IiwidmlzaWJpbGl0eVBsYXkiLCJwbGF5IiwiaXNQYWdlSGlkZGVuIiwiaGlkZGVuIiwidGljayIsInRpbWUiLCJhdXRvUGxheSIsInBhdXNlIiwidW5wYXVzZSIsInBhdXNlQXV0b1BsYXlPbkhvdmVyIiwiX2NyZWF0ZVBsYXllciIsInBsYXllciIsImFjdGl2YXRlUGxheWVyIiwic3RvcFBsYXllciIsImRlYWN0aXZhdGVQbGF5ZXIiLCJwbGF5UGxheWVyIiwicGF1c2VQbGF5ZXIiLCJ1bnBhdXNlUGxheWVyIiwib25tb3VzZWVudGVyIiwib25tb3VzZWxlYXZlIiwic3ZnVVJJIiwiUHJldk5leHRCdXR0b24iLCJpc0VuYWJsZWQiLCJpc1ByZXZpb3VzIiwibGVmdERpcmVjdGlvbiIsImlzTGVmdCIsImRpc2FibGUiLCJzdmciLCJjcmVhdGVTVkciLCJ1cGRhdGUiLCJjcmVhdGVFbGVtZW50TlMiLCJwYXRoTW92ZW1lbnRzIiwiZ2V0QXJyb3dNb3ZlbWVudHMiLCJhcnJvd1NoYXBlIiwic2hhcGUiLCJ4MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJvbmNsaWNrIiwiZW5hYmxlIiwiZGlzYWJsZWQiLCJib3VuZEluZGV4IiwicHJldk5leHRCdXR0b25zIiwiX2NyZWF0ZVByZXZOZXh0QnV0dG9ucyIsInByZXZCdXR0b24iLCJuZXh0QnV0dG9uIiwiYWN0aXZhdGVQcmV2TmV4dEJ1dHRvbnMiLCJkZWFjdGl2YXRlUHJldk5leHRCdXR0b25zIiwibGFzdENlbGwiLCJsYXN0TWFyZ2luIiwiZ2V0U3R5bGVTaXplIiwicGFyc2VGbG9hdCIsImlzVmFsaWQiLCJub29wIiwibG9nRXJyb3IiLCJtZXNzYWdlIiwibWVhc3VyZW1lbnRzIiwibWVhc3VyZW1lbnRzTGVuZ3RoIiwiZ2V0WmVyb1NpemUiLCJpbm5lckhlaWdodCIsIm1lYXN1cmVtZW50IiwiZ2V0U3R5bGUiLCJpc1NldHVwIiwiaXNCb3hTaXplT3V0ZXIiLCJzZXR1cCIsInBhZGRpbmciLCJib3JkZXJTdHlsZSIsImJvcmRlcldpZHRoIiwiYm94U2l6aW5nIiwiZG9jdW1lbnRFbGVtZW50Iiwibm9kZVR5cGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImlzQm9yZGVyQm94IiwicGFkZGluZ1dpZHRoIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nSGVpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJtYXJnaW5XaWR0aCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkhlaWdodCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJIZWlnaHQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiaXNCb3JkZXJCb3hTaXplT3V0ZXIiLCJzdHlsZVdpZHRoIiwic3R5bGVIZWlnaHQiLCJGVU5DX0VSUk9SX1RFWFQiLCJOQU4iLCJzeW1ib2xUYWciLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJvYmplY3RQcm90byIsIm9iamVjdFRvU3RyaW5nIiwibmF0aXZlTWF4IiwibmF0aXZlTWluIiwibm93IiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsInRyYWlsaW5nIiwidG9OdW1iZXIiLCJpbnZva2VGdW5jIiwidGhpc0FyZyIsImxlYWRpbmdFZGdlIiwidGltZXJFeHBpcmVkIiwicmVtYWluaW5nV2FpdCIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZVNpbmNlTGFzdEludm9rZSIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImlzT2JqZWN0TGlrZSIsImlzU3ltYm9sIiwib3RoZXIiLCJpc0JpbmFyeSIsIkhBU0hfVU5ERUZJTkVEIiwiZnVuY1RhZyIsImdlblRhZyIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImdldFZhbHVlIiwiaXNIb3N0T2JqZWN0IiwiZSIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJjb3JlSnNEYXRhIiwibWFza1NyY0tleSIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJNYXAiLCJnZXROYXRpdmUiLCJuYXRpdmVDcmVhdGUiLCJIYXNoIiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiTGlzdENhY2hlIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJhc3NvY0luZGV4T2YiLCJwb3AiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJNYXBDYWNoZSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsImdldE1hcERhdGEiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJlcSIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsImlzRnVuY3Rpb24iLCJ0b1NvdXJjZSIsImlzS2V5YWJsZSIsIm1lbW9pemUiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJ0aHJvdHRsZSIsIk1hcFNoaW0iLCJnZXRJbmRleCIsImFyciIsImNsYXNzXzEiLCJfX2VudHJpZXNfXyIsImN0eCIsIl9pIiwiX2EiLCJpc0Jyb3dzZXIiLCJnbG9iYWwkMSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSQxIiwidHJhaWxpbmdUaW1lb3V0IiwiZGVsYXkiLCJsZWFkaW5nQ2FsbCIsInRyYWlsaW5nQ2FsbCIsInJlc29sdmVQZW5kaW5nIiwicHJveHkiLCJ0aW1lb3V0Q2FsbGJhY2siLCJ0aW1lU3RhbXAiLCJSRUZSRVNIX0RFTEFZIiwidHJhbnNpdGlvbktleXMiLCJtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiTXV0YXRpb25PYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciIsImNvbm5lY3RlZF8iLCJtdXRhdGlvbkV2ZW50c0FkZGVkXyIsIm11dGF0aW9uc09ic2VydmVyXyIsIm9ic2VydmVyc18iLCJvblRyYW5zaXRpb25FbmRfIiwicmVmcmVzaCIsImFkZE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJjb25uZWN0XyIsInJlbW92ZU9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiZGlzY29ubmVjdF8iLCJjaGFuZ2VzRGV0ZWN0ZWQiLCJ1cGRhdGVPYnNlcnZlcnNfIiwiYWN0aXZlT2JzZXJ2ZXJzIiwiZ2F0aGVyQWN0aXZlIiwiaGFzQWN0aXZlIiwiYnJvYWRjYXN0QWN0aXZlIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwic3VidHJlZSIsImRpc2Nvbm5lY3QiLCJfYiIsInByb3BlcnR5TmFtZSIsImlzUmVmbG93UHJvcGVydHkiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlXyIsImRlZmluZUNvbmZpZ3VyYWJsZSIsInByb3BzIiwiZ2V0V2luZG93T2YiLCJvd25lckdsb2JhbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImVtcHR5UmVjdCIsImNyZWF0ZVJlY3RJbml0IiwidG9GbG9hdCIsImdldEJvcmRlcnNTaXplIiwic3R5bGVzIiwicG9zaXRpb25zIiwiZ2V0UGFkZGluZ3MiLCJwYWRkaW5ncyIsInBvc2l0aW9uc18xIiwiZ2V0U1ZHQ29udGVudFJlY3QiLCJiYm94IiwiZ2V0QkJveCIsImdldEhUTUxFbGVtZW50Q29udGVudFJlY3QiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImhvcml6UGFkIiwidmVydFBhZCIsInRvcCIsImJvdHRvbSIsImlzRG9jdW1lbnRFbGVtZW50IiwidmVydFNjcm9sbGJhciIsImhvcml6U2Nyb2xsYmFyIiwiaXNTVkdHcmFwaGljc0VsZW1lbnQiLCJTVkdHcmFwaGljc0VsZW1lbnQiLCJTVkdFbGVtZW50IiwiZ2V0Q29udGVudFJlY3QiLCJjcmVhdGVSZWFkT25seVJlY3QiLCJDb25zdHIiLCJET01SZWN0UmVhZE9ubHkiLCJyZWN0IiwiUmVzaXplT2JzZXJ2YXRpb24iLCJicm9hZGNhc3RXaWR0aCIsImJyb2FkY2FzdEhlaWdodCIsImNvbnRlbnRSZWN0XyIsImJyb2FkY2FzdFJlY3QiLCJSZXNpemVPYnNlcnZlckVudHJ5IiwicmVjdEluaXQiLCJjb250ZW50UmVjdCIsIlJlc2l6ZU9ic2VydmVyU1BJIiwiY29udHJvbGxlciIsImNhbGxiYWNrQ3R4IiwiYWN0aXZlT2JzZXJ2YXRpb25zXyIsIm9ic2VydmF0aW9uc18iLCJjYWxsYmFja18iLCJjb250cm9sbGVyXyIsImNhbGxiYWNrQ3R4XyIsIm9ic2VydmF0aW9ucyIsInVub2JzZXJ2ZSIsImNsZWFyQWN0aXZlIiwib2JzZXJ2YXRpb24iLCJSZXNpemVPYnNlcnZlciIsImNhY2hlZFNjcm9sbGJhcldpZHRoIiwiY2FjaGVkRGV2aWNlUGl4ZWxSYXRpbyIsImJveCIsImdldE9wdGlvbnMiLCJhdHRyaWJ1dGUiLCJhY2MiLCJTaW1wbGVCYXIiLCJlbFdpbmRvdyIsImdldEVsZW1lbnRXaW5kb3ciLCJpc1dpdGhpblRyYWNrWEJvdW5kcyIsImlzV2l0aGluVHJhY2tZQm91bmRzIiwidHJhY2siLCJ0cmFja1NpemUiLCJzY3JvbGxiYXIiLCJjb250ZW50U2l6ZSIsImhvc3RTaXplIiwiZXZlbnRPZmZzZXQiLCJkcmFnUG9zIiwiZHJhZ1BlcmMiLCJzY3JvbGxQb3MiLCJlbERvY3VtZW50IiwiZ2V0RWxlbWVudERvY3VtZW50Iiwic2Nyb2xsT2Zmc2V0QXR0ciIsInNpemVBdHRyIiwic2Nyb2xsU2l6ZUF0dHIiLCJvZmZzZXRTaXplQXR0ciIsIm9mZnNldEF0dHIiLCJvdmVyZmxvd0F0dHIiLCJkcmFnT2Zmc2V0IiwiaXNPdmVyZmxvd2luZyIsImlzVmlzaWJsZSIsImZvcmNlVmlzaWJsZSIsImdldFJ0bEhlbHBlcnMiLCJkdW1teURpdiIsInNjcm9sbGJhckR1bW15RWwiLCJkdW1teUNvbnRhaW5lckNoaWxkIiwiZHVtbXlDb250YWluZXJPZmZzZXQiLCJkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0IiwiZHVtbXlDb250YWluZXJTY3JvbGxPZmZzZXRBZnRlclNjcm9sbCIsImlzUnRsU2Nyb2xsaW5nSW52ZXJ0ZWQiLCJpc1J0bFNjcm9sbGJhckludmVydGVkIiwiZ2V0T2Zmc2V0IiwiaW5pdERPTSIsImNoaWxkIiwiaW5pdExpc3RlbmVycyIsInBhc3NpdmUiLCJyZXNpemVPYnNlcnZlclN0YXJ0ZWQiLCJyZXNpemVPYnNlcnZlciIsInJlY2FsY3VsYXRlIiwiY29udGVudEVsT2Zmc2V0V2lkdGgiLCJpc0hlaWdodEF1dG8iLCJpc1dpZHRoQXV0byIsImNvbnRlbnRXcmFwcGVyRWxPZmZzZXRXaWR0aCIsImVsT3ZlcmZsb3dYIiwiZWxPdmVyZmxvd1kiLCJjb250ZW50RWxTY3JvbGxIZWlnaHQiLCJjb250ZW50RWxTY3JvbGxXaWR0aCIsImNvbnRlbnRXcmFwcGVyRWxPZmZzZXRIZWlnaHQiLCJvZmZzZXRGb3JYU2Nyb2xsYmFyIiwib2Zmc2V0Rm9yWVNjcm9sbGJhciIsImdldFNjcm9sbGJhclNpemUiLCJheGlzIiwic2Nyb2xsYmFyUmF0aW8iLCJzY3JvbGxiYXJTaXplIiwicG9zaXRpb25TY3JvbGxiYXIiLCJzY3JvbGxPZmZzZXQiLCJzY3JvbGxQb3VyY2VudCIsImhhbmRsZU9mZnNldCIsInRvZ2dsZVRyYWNrVmlzaWJpbGl0eSIsImhpZGVOYXRpdmVTY3JvbGxiYXIiLCJvbk1vdXNlTW92ZUZvckF4aXMiLCJpc1dpdGhpblNjcm9sbGJhckJvdW5kc1giLCJvbk1vdXNlTGVhdmVGb3JBeGlzIiwic2hvd1Njcm9sbGJhciIsIm9uRHJhZ1N0YXJ0Iiwib25UcmFja0NsaWNrIiwic2Nyb2xsYmFyT2Zmc2V0Iiwic2Nyb2xsZWQiLCJ0IiwiZGlyIiwic2Nyb2xsU2l6ZSIsInNwZWVkIiwiZ2V0Q29udGVudEVsZW1lbnQiLCJnZXRTY3JvbGxFbGVtZW50IiwiZ2V0U2Nyb2xsYmFyV2lkdGgiLCJzY3JvbGxiYXJXaWR0aCIsInJlbW92ZUxpc3RlbmVycyIsInVuTW91bnQiLCJpc1dpdGhpbkJvdW5kcyIsImZpbmRDaGlsZCIsImRlZmF1bHRPcHRpb25zIiwiYXV0b0hpZGUiLCJjbGlja09uVHJhY2siLCJjbGFzc05hbWVzIiwiY29udGVudEVsIiwiY29udGVudFdyYXBwZXIiLCJvZmZzZXQiLCJtYXNrIiwicGxhY2Vob2xkZXIiLCJoZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwiLCJoZWlnaHRBdXRvT2JzZXJ2ZXJFbCIsInZpc2libGUiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJob3ZlciIsImRyYWdnaW5nIiwic2Nyb2xsYmFyTWluU2l6ZSIsInNjcm9sbGJhck1heFNpemUiLCJtdXRhdGlvbnMiLCJtdXRhdGlvbiIsImFkZGVkTm9kZSIsInJlbW92ZWROb2RlIiwiX2JpbmRIYW5kbGVzIiwiaXNBZGQiLCJiaW5kTWV0aG9kIiwidG91Y2hBY3Rpb24iLCJoYW5kbGUiLCJfYmluZFN0YXJ0RXZlbnQiLCJQb2ludGVyRXZlbnQiLCJjdXJzb3JOb2RlcyIsIk9QVElPTiIsImNsaWNrVHlwZXMiLCJyYWRpbyIsImNoZWNrYm94IiwiYnV0dG9uIiwic3VibWl0IiwiaW1hZ2UiLCJmaWxlIiwiaXNDdXJzb3JOb2RlIiwiaXNDbGlja1R5cGUiLCJfcG9pbnRlclJlc2V0IiwiZm9jdXNlZCIsImNhbkJsdXIiLCJibHVyIiwiaXNEcmFnZ2luZyIsIl9kcmFnU3RhcnQiLCJfZHJhZ0VuZCIsIl9zdGF0aWNDbGljayIsImlzUHJldmVudGluZ0NsaWNrcyIsImlzSWdub3JpbmdNb3VzZVVwIiwiZ2V0UG9pbnRlclBvaW50Iiwic3RhcnRFdmVudCIsImdldFRvdWNoIiwidG91Y2hlcyIsInRvdWNoIiwiaWRlbnRpZmllciIsInBvaW50ZXJJZGVudGlmaWVyIiwib25tb3VzZWRvd24iLCJfcG9pbnRlckRvd24iLCJvbnRvdWNoc3RhcnQiLCJjaGFuZ2VkVG91Y2hlcyIsIm9ucG9pbnRlcmRvd24iLCJwb2ludGVySWQiLCJwb3N0U3RhcnRFdmVudHMiLCJtb3VzZWRvd24iLCJ0b3VjaHN0YXJ0IiwicG9pbnRlcmRvd24iLCJfYm91bmRQb2ludGVyRXZlbnRzIiwiX3VuYmluZFBvc3RTdGFydEV2ZW50cyIsIm9ubW91c2Vtb3ZlIiwiX3BvaW50ZXJNb3ZlIiwib25wb2ludGVybW92ZSIsIm9udG91Y2htb3ZlIiwib25tb3VzZXVwIiwiX3BvaW50ZXJVcCIsIm9ucG9pbnRlcnVwIiwib250b3VjaGVuZCIsIm9ucG9pbnRlcmNhbmNlbCIsIl9wb2ludGVyQ2FuY2VsIiwib250b3VjaGNhbmNlbCIsInBvaW50ZXJDYW5jZWwiLCJnIiwibmF2VHJpZ2dlciIsImFib3V0IiwiY29udGFpbmVyQWJvdXQiLCJ0b2dnbGUiLCJldnQiLCJhYm91dE1lIiwidGFyZ2V0RWxlbWVudCIsInByb2plY3QiLCJwcm9qZWN0cyIsImdhbGxlcmllcyIsImNvbnRhaW5lciIsImNhcm91c2VsIiwicmVtb3ZlQWN0aXZlUHJvamVjdCIsImFkZEFjdGl2ZVByb2plY3QiLCJjbGlja091dHNpZGUiLCJyZW1vdmVIb3ZlclByb2plY3QiLCJyZW1vdmVJbWFnZUhvdmVyIiwiYWRkSG92ZXJQcm9qZWN0IiwicmVtb3ZlU29tZXRoaW5nUHJvamVjdCIsImdhbGxlcnkiLCJocmVmIiwibWF0Y2hpbmdTZWN0aW9uIiwiY29udGFpbnMiLCJvcGFjaXR5IiwiZmx5b3V0RWxlbWVudCIsImxvZyJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtR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LGlEQUFKLENBQWNqekMsUUFBUSxDQUFDbW1CLGFBQVQsQ0FBdUIsc0JBQXZCLENBQWQsRUFBOEQ7QUFDMURtTixXQUFTLEVBQUU7QUFEK0MsQ0FBOUQsRTs7Ozs7Ozs7Ozs7O0FDUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsInZhciBjYW5Vc2VET00gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93LmRvY3VtZW50ICYmXG4gIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhblVzZURPTTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aCcpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2ZvckVhY2gnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdmb3JFYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxubW9kdWxlLmV4cG9ydHMgPSAoIVNUUklDVF9NRVRIT0QgfHwgIVVTRVNfVE9fTEVOR1RIKSA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0gOiBbXS5mb3JFYWNoO1xuIiwidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcbiIsInZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXggfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoLmNhbGwodGFyZ2V0LCB2YWx1ZSk7IC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7ICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KVxufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcbiAgcmV0dXJuIFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgIGNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZm9vOiAxIH07XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbFxuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY2FjaGUgPSB7fTtcblxudmFyIHRocm93ZXIgPSBmdW5jdGlvbiAoaXQpIHsgdGhyb3cgaXQ7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBvcHRpb25zKSB7XG4gIGlmIChoYXMoY2FjaGUsIE1FVEhPRF9OQU1FKSkgcmV0dXJuIGNhY2hlW01FVEhPRF9OQU1FXTtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHZhciBBQ0NFU1NPUlMgPSBoYXMob3B0aW9ucywgJ0FDQ0VTU09SUycpID8gb3B0aW9ucy5BQ0NFU1NPUlMgOiBmYWxzZTtcbiAgdmFyIGFyZ3VtZW50MCA9IGhhcyhvcHRpb25zLCAwKSA/IG9wdGlvbnNbMF0gOiB0aHJvd2VyO1xuICB2YXIgYXJndW1lbnQxID0gaGFzKG9wdGlvbnMsIDEpID8gb3B0aW9uc1sxXSA6IHVuZGVmaW5lZDtcblxuICByZXR1cm4gY2FjaGVbTUVUSE9EX05BTUVdID0gISFtZXRob2QgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoQUNDRVNTT1JTICYmICFERVNDUklQVE9SUykgcmV0dXJuIHRydWU7XG4gICAgdmFyIE8gPSB7IGxlbmd0aDogLTEgfTtcblxuICAgIGlmIChBQ0NFU1NPUlMpIGRlZmluZVByb3BlcnR5KE8sIDEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiB0aHJvd2VyIH0pO1xuICAgIGVsc2UgT1sxXSA9IDE7XG5cbiAgICBtZXRob2QuY2FsbChPLCBhcmd1bWVudDAsIGFyZ3VtZW50MSk7XG4gIH0pO1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICBsZWZ0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIG5ldyAoQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2Vha0RhdGEgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKS5nZXRXZWFrRGF0YTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgQXJyYXlJdGVyYXRpb25Nb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xudmFyIGZpbmQgPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kO1xudmFyIGZpbmRJbmRleCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmRJbmRleDtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xuXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG59O1xuXG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGZpbmQoc3RvcmUuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblxuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGlkOiBpZCsrLFxuICAgICAgICBmcm96ZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcbiAgICB9KTtcblxuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgZWxzZSBkYXRhW3N0YXRlLmlkXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCBzdGF0ZS5pZCkgJiYgZGVsZXRlIGRhdGFbc3RhdGUuaWRdO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCBzdGF0ZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmdldChrZXkpO1xuICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YVtzdGF0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQztcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xuICB2YXIgSVNfTUFQID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdNYXAnKSAhPT0gLTE7XG4gIHZhciBJU19XRUFLID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdXZWFrJykgIT09IC0xO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWxbQ09OU1RSVUNUT1JfTkFNRV07XG4gIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBDb25zdHJ1Y3RvciA9IE5hdGl2ZUNvbnN0cnVjdG9yO1xuICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBuYXRpdmVNZXRob2QgPSBOYXRpdmVQcm90b3R5cGVbS0VZXTtcbiAgICByZWRlZmluZShOYXRpdmVQcm90b3R5cGUsIEtFWSxcbiAgICAgIEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSA6IEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyB1bmRlZmluZWQgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgaWYgKGlzRm9yY2VkKENPTlNUUlVDVE9SX05BTUUsIHR5cGVvZiBOYXRpdmVDb25zdHJ1Y3RvciAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xuICAgIEludGVybmFsTWV0YWRhdGFNb2R1bGUuUkVRVUlSRUQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzRm9yY2VkKENPTlNUUlVDVE9SX05BTUUsIHRydWUpKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcblxuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLCBkdW1teSwgQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE5hdGl2ZVByb3RvdHlwZTtcbiAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cblxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuXG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XG4gIH1cblxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yIH0sIGV4cG9ydGVkKTtcblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSXRlcmF0b3JzQ29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpOyB9O1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IsIGRlZmF1bHRJdGVyYXRvcik7XG4gIH1cbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSArIG1hdGNoWzFdO1xufSBlbHNlIGlmICh1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb24gJiYgK3ZlcnNpb247XG4iLCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICByZWRlZmluZSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbi8vIElFIDw9IDExIHJlcGxhY2VzICQwIHdpdGggdGhlIHdob2xlIG1hdGNoLCBhcyBpZiBpdCB3YXMgJCZcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwMjQ2NjYvZ2V0dGluZy1pZS10by1yZXBsYWNlLWEtcmVnZXgtd2l0aC10aGUtbGl0ZXJhbC1zdHJpbmctMFxudmFyIFJFUExBQ0VfS0VFUFNfJDAgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ2EnLnJlcGxhY2UoLy4vLCAnJDAnKSA9PT0gJyQwJztcbn0pKCk7XG5cbnZhciBSRVBMQUNFID0gd2VsbEtub3duU3ltYm9sKCdyZXBsYWNlJyk7XG4vLyBTYWZhcmkgPD0gMTMuMC4zKD8pIHN1YnN0aXR1dGVzIG50aCBjYXB0dXJlIHdoZXJlIG4+bSB3aXRoIGFuIGVtcHR5IHN0cmluZ1xudmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKC8uL1tSRVBMQUNFXSkge1xuICAgIHJldHVybiAvLi9bUkVQTEFDRV0oJ2EnLCAnJDAnKSA9PT0gJyc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkoKTtcblxuLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4vLyBXZWV4IEpTIGhhcyBmcm96ZW4gYnVpbHQtaW4gcHJvdG90eXBlcywgc28gdXNlIHRyeSAvIGNhdGNoIHdyYXBwZXJcbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggIT09IDIgfHwgcmVzdWx0WzBdICE9PSAnYScgfHwgcmVzdWx0WzFdICE9PSAnYic7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMsIHNoYW0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgICAgcmUuZmxhZ3MgPSAnJztcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcbiAgICB9XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhKFxuICAgICAgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgJiZcbiAgICAgIFJFUExBQ0VfS0VFUFNfJDAgJiZcbiAgICAgICFSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRVxuICAgICkpIHx8XG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgfSwge1xuICAgICAgUkVQTEFDRV9LRUVQU18kMDogUkVQTEFDRV9LRUVQU18kMCxcbiAgICAgIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFOiBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRVxuICAgIH0pO1xuICAgIHZhciBzdHJpbmdNZXRob2QgPSBtZXRob2RzWzBdO1xuICAgIHZhciByZWdleE1ldGhvZCA9IG1ldGhvZHNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmluZ01ldGhvZCk7XG4gICAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cblxuICBpZiAoc2hhbSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFJlZ0V4cC5wcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XG4gICAgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIHR5cGVvZiAoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZztcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGAzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICh0eXBlb2Ygc3RvcmUuaW5zcGVjdFNvdXJjZSAhPSAnZnVuY3Rpb24nKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuIiwidmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG5cbnZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xudmFyIGlkID0gMDtcblxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBzZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHsgdmFsdWU6IHtcbiAgICBvYmplY3RJRDogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgd2Vha0RhdGE6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBhIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xufTtcblxudmFyIGdldFdlYWtEYXRhID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xufTtcblxuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaSU5HICYmIG1ldGEuUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUkVRVUlSRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIG9iamVjdEhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVApIHtcbiAgdmFyIHN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgaXRlcmF0ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBmbiwgdGhhdCwgQVNfRU5UUklFUywgSVNfSVRFUkFUT1IpIHtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGZuLCB0aGF0LCBBU19FTlRSSUVTID8gMiA6IDEpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gQVNfRU5UUklFU1xuICAgICAgICAgID8gYm91bmRGdW5jdGlvbihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSlcbiAgICAgICAgICA6IGJvdW5kRnVuY3Rpb24oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IG5leHQuY2FsbChpdGVyYXRvcikpLmRvbmUpIHtcbiAgICByZXN1bHQgPSBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBib3VuZEZ1bmN0aW9uLCBzdGVwLnZhbHVlLCBBU19FTlRSSUVTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbml0ZXJhdGUuc3RvcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgcmVzdWx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG5pZiAoSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuaWYgKCFJU19QVVJFICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiAhU3RyaW5nKFN5bWJvbCgpKTtcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgJHBhcnNlSW50ID0gZ2xvYmFsLnBhcnNlSW50O1xudmFyIGhleCA9IC9eWystXT8wW1h4XS87XG52YXIgRk9SQ0VEID0gJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzB4MTYnKSAhPT0gMjI7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcbm1vZHVsZS5leHBvcnRzID0gRk9SQ0VEID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkge1xuICB2YXIgUyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICByZXR1cm4gJHBhcnNlSW50KFMsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KFMpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG5cbnZhciBuYXRpdmVBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG5tb2R1bGUuZXhwb3J0cyA9ICFuYXRpdmVBc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgbmF0aXZlQXNzaWduKHsgYjogMSB9LCBuYXRpdmVBc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gbmF0aXZlQXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyhuYXRpdmVBc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogbmF0aXZlQXNzaWduO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL2NsYXNzb2YtcmF3Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vcmVnZXhwLWV4ZWMnKTtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuXG4gIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL3JlZ2V4cC1mbGFncycpO1xudmFyIHN0aWNreUhlbHBlcnMgPSByZXF1aXJlKCcuL3JlZ2V4cC1zdGlja3ktaGVscGVycycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5VTlNVUFBPUlRFRF9ZIHx8IHN0aWNreUhlbHBlcnMuQlJPS0VOX0NBUkVUO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRCB8fCBVTlNVUFBPUlRFRF9ZO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gcmVnZXhwRmxhZ3MuY2FsbChyZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoJ3knLCAnJyk7XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZignZycpID09PSAtMSkge1xuICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICB9XG5cbiAgICAgIHN0ckNvcHkgPSBTdHJpbmcoc3RyKS5zbGljZShyZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgc3RyW3JlLmxhc3RJbmRleCAtIDFdICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwoc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gbWF0Y2guaW5wdXQuc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vZmFpbHMnKTtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3IsXG4vLyBzbyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUkUocywgZikge1xuICByZXR1cm4gUmVnRXhwKHMsIGYpO1xufVxuXG5leHBvcnRzLlVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG4gIHZhciByZSA9IFJFKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbmV4cG9ydHMuQlJPS0VOX0NBUkVUID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NzM2ODdcbiAgdmFyIHJlID0gUkUoJ15yJywgJ2d5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdzdHInKSAhPSBudWxsO1xufSk7XG4iLCIvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuIiwidmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuNi41JyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIwIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IGNvZGVQb2ludEF0LCBhdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKTtcblxudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcbiIsIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCJ2YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcbn07XG4iLCJ2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgJiYgIVN5bWJvbC5zaGFtXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbCwgbmFtZSkpIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICBlbHNlIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcbiIsIi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbHRlcjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgYXJyYXlNZXRob2RVc2VzVG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoJyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7XG4vLyBFZGdlIDE0LSBpc3N1ZVxudmFyIFVTRVNfVE9fTEVOR1RIID0gYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgoJ2ZpbHRlcicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfHwgIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gZm9yRWFjaCB9LCB7XG4gIGZvckVhY2g6IGZvckVhY2hcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2UnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdyZWR1Y2UnLCB7IDE6IDAgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIHx8ICFVU0VTX1RPX0xFTkdUSCB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nID0gRnVuY3Rpb25Qcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1pbnN0YW5jZXMtbmFtZVxuaWYgKERFU0NSSVBUT1JTICYmICEoTkFNRSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcbiAgZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25Qcm90b3R5cGUsIE5BTUUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZy5jYWxsKHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gIHJlZGVmaW5lKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlSW50SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbnVtYmVyLXBhcnNlLWludCcpO1xuXG4vLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IHBhcnNlSW50SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUludDogcGFyc2VJbnRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBleGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbiQoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAvLi8uZXhlYyAhPT0gZXhlYyB9LCB7XG4gIGV4ZWM6IGV4ZWNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoYXJBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlJykuY2hhckF0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcblxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogU3RyaW5nKGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChNQVRDSCwgbmF0aXZlTWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLm1hdGNoXG4gICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgbWF0Y2hlciA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIG1hdGNoZXIgIT09IHVuZGVmaW5lZCA/IG1hdGNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdFeHBFeGVjKHJ4LCBTKTtcblxuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJidgXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoUkVQTEFDRSwgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlLCByZWFzb24pIHtcbiAgdmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gcmVhc29uLlJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFO1xuICB2YXIgUkVQTEFDRV9LRUVQU18kMCA9IHJlYXNvbi5SRVBMQUNFX0tFRVBTXyQwO1xuICB2YXIgVU5TQUZFX1NVQlNUSVRVVEUgPSBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA/ICckJyA6ICckMCc7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIHJlcGxhY2VyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogbmF0aXZlUmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgaWYgKFxuICAgICAgICAoIVJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFICYmIFJFUExBQ0VfS0VFUFNfJDApIHx8XG4gICAgICAgICh0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnc3RyaW5nJyAmJiByZXBsYWNlVmFsdWUuaW5kZXhPZihVTlNBRkVfU1VCU1RJVFVURSkgPT09IC0xKVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFN0cmluZyhyZXBsYWNlVmFsdWUuYXBwbHkodW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbik7XG4gICAgfVxuICBdO1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVwbGFjZS5jYWxsKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG4gICAgICB2YXIgY2FwdHVyZTtcbiAgICAgIHN3aXRjaCAoY2guY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0ci5zbGljZSh0YWlsUG9zKTtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gXFxkXFxkP1xuICAgICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgaWYgKG4gPiBtKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICB9KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKTtcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24nKTtcbnZhciBjb2xsZWN0aW9uV2VhayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBlbmZvcmNlSXRlcm5hbFN0YXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJykuZW5mb3JjZTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwJyk7XG5cbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciBJbnRlcm5hbFdlYWtNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG4vLyBgV2Vha01hcGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdlYWttYXAtY29uc3RydWN0b3JcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gY29sbGVjdGlvbignV2Vha01hcCcsIHdyYXBwZXIsIGNvbGxlY3Rpb25XZWFrKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuLy8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDg1XG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiAgSW50ZXJuYWxXZWFrTWFwID0gY29sbGVjdGlvbldlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgJ1dlYWtNYXAnLCB0cnVlKTtcbiAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5SRVFVSVJFRCA9IHRydWU7XG4gIHZhciBXZWFrTWFwUHJvdG90eXBlID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlRGVsZXRlID0gV2Vha01hcFByb3RvdHlwZVsnZGVsZXRlJ107XG4gIHZhciBuYXRpdmVIYXMgPSBXZWFrTWFwUHJvdG90eXBlLmhhcztcbiAgdmFyIG5hdGl2ZUdldCA9IFdlYWtNYXBQcm90b3R5cGUuZ2V0O1xuICB2YXIgbmF0aXZlU2V0ID0gV2Vha01hcFByb3RvdHlwZS5zZXQ7XG4gIHJlZGVmaW5lQWxsKFdlYWtNYXBQcm90b3R5cGUsIHtcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVEZWxldGUuY2FsbCh0aGlzLCBrZXkpIHx8IHN0YXRlLmZyb3plblsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIH0gcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XG4gICAgICB9IHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgPyBuYXRpdmVHZXQuY2FsbCh0aGlzLCBrZXkpIDogc3RhdGUuZnJvemVuLmdldChrZXkpO1xuICAgICAgfSByZXR1cm4gbmF0aXZlR2V0LmNhbGwodGhpcywga2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpID8gbmF0aXZlU2V0LmNhbGwodGhpcywga2V5LCB2YWx1ZSkgOiBzdGF0ZS5mcm96ZW4uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIG5hdGl2ZVNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCAhPT0gZm9yRWFjaCkgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgJ2ZvckVhY2gnLCBmb3JFYWNoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggPSBmb3JFYWNoO1xuICB9XG59XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogbWF0Y2hlc1NlbGVjdG9yIHYyLjAuMlxuICogbWF0Y2hlc1NlbGVjdG9yKCBlbGVtZW50LCAnLnNlbGVjdG9yJyApXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIG1vZHVsZTogZmFsc2UgKi9cbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lm1hdGNoZXNTZWxlY3RvciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbWF0Y2hlc01ldGhvZCA9ICggZnVuY3Rpb24oKSB7XG4gICAgdmFyIEVsZW1Qcm90byA9IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZTtcbiAgICAvLyBjaGVjayBmb3IgdGhlIHN0YW5kYXJkIG1ldGhvZCBuYW1lIGZpcnN0XG4gICAgaWYgKCBFbGVtUHJvdG8ubWF0Y2hlcyApIHtcbiAgICAgIHJldHVybiAnbWF0Y2hlcyc7XG4gICAgfVxuICAgIC8vIGNoZWNrIHVuLXByZWZpeGVkXG4gICAgaWYgKCBFbGVtUHJvdG8ubWF0Y2hlc1NlbGVjdG9yICkge1xuICAgICAgcmV0dXJuICdtYXRjaGVzU2VsZWN0b3InO1xuICAgIH1cbiAgICAvLyBjaGVjayB2ZW5kb3IgcHJlZml4ZXNcbiAgICB2YXIgcHJlZml4ZXMgPSBbICd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nIF07XG5cbiAgICBmb3IgKCB2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcHJlZml4ICsgJ01hdGNoZXNTZWxlY3Rvcic7XG4gICAgICBpZiAoIEVsZW1Qcm90b1sgbWV0aG9kIF0gKSB7XG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoIGVsZW0sIHNlbGVjdG9yICkge1xuICAgIHJldHVybiBlbGVtWyBtYXRjaGVzTWV0aG9kIF0oIHNlbGVjdG9yICk7XG4gIH07XG5cbn0pKTtcbiIsIi8qKlxuICogRXZFbWl0dGVyIHYxLjEuMFxuICogTGlsJyBldmVudCBlbWl0dGVyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qIGpzaGludCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgd2luZG93ICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG52YXIgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKSA9PSAtMSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgdmFyIG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjb3B5IG92ZXIgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGlmIC5vZmYoKSBpbiBsaXN0ZW5lclxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCk7XG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAvLyBvbmNlIHN0dWZmXG4gIHZhciBvbmNlTGlzdGVuZXJzID0gdGhpcy5fb25jZUV2ZW50cyAmJiB0aGlzLl9vbmNlRXZlbnRzWyBldmVudE5hbWUgXTtcblxuICBmb3IgKCB2YXIgaT0wOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXVxuICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgaWYgKCBpc09uY2UgKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgdGhpcy5vZmYoIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgICAgIC8vIHVuc2V0IG9uY2UgZmxhZ1xuICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hbGxPZmYgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgZGVsZXRlIHRoaXMuX29uY2VFdmVudHM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59KSk7XG4iLCIvKipcbiAqIEZpenp5IFVJIHV0aWxzIHYyLjAuN1xuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLypqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ2Rlc2FuZHJvLW1hdGNoZXMtc2VsZWN0b3IvbWF0Y2hlcy1zZWxlY3RvcidcbiAgICBdLCBmdW5jdGlvbiggbWF0Y2hlc1NlbGVjdG9yICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdkZXNhbmRyby1tYXRjaGVzLXNlbGVjdG9yJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmZpenp5VUlVdGlscyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cubWF0Y2hlc1NlbGVjdG9yXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHt9O1xuXG4vLyAtLS0tLSBleHRlbmQgLS0tLS0gLy9cblxuLy8gZXh0ZW5kcyBvYmplY3RzXG51dGlscy5leHRlbmQgPSBmdW5jdGlvbiggYSwgYiApIHtcbiAgZm9yICggdmFyIHByb3AgaW4gYiApIHtcbiAgICBhWyBwcm9wIF0gPSBiWyBwcm9wIF07XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vLyAtLS0tLSBtb2R1bG8gLS0tLS0gLy9cblxudXRpbHMubW9kdWxvID0gZnVuY3Rpb24oIG51bSwgZGl2ICkge1xuICByZXR1cm4gKCAoIG51bSAlIGRpdiApICsgZGl2ICkgJSBkaXY7XG59O1xuXG4vLyAtLS0tLSBtYWtlQXJyYXkgLS0tLS0gLy9cblxudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8vIHR1cm4gZWxlbWVudCBvciBub2RlTGlzdCBpbnRvIGFuIGFycmF5XG51dGlscy5tYWtlQXJyYXkgPSBmdW5jdGlvbiggb2JqICkge1xuICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuICAgIC8vIHVzZSBvYmplY3QgaWYgYWxyZWFkeSBhbiBhcnJheVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgLy8gcmV0dXJuIGVtcHR5IGFycmF5IGlmIHVuZGVmaW5lZCBvciBudWxsLiAjNlxuICBpZiAoIG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgaXNBcnJheUxpa2UgPSB0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInO1xuICBpZiAoIGlzQXJyYXlMaWtlICkge1xuICAgIC8vIGNvbnZlcnQgbm9kZUxpc3QgdG8gYXJyYXlcbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKCBvYmogKTtcbiAgfVxuXG4gIC8vIGFycmF5IG9mIHNpbmdsZSBpbmRleFxuICByZXR1cm4gWyBvYmogXTtcbn07XG5cbi8vIC0tLS0tIHJlbW92ZUZyb20gLS0tLS0gLy9cblxudXRpbHMucmVtb3ZlRnJvbSA9IGZ1bmN0aW9uKCBhcnksIG9iaiApIHtcbiAgdmFyIGluZGV4ID0gYXJ5LmluZGV4T2YoIG9iaiApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGFyeS5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIGdldFBhcmVudCAtLS0tLSAvL1xuXG51dGlscy5nZXRQYXJlbnQgPSBmdW5jdGlvbiggZWxlbSwgc2VsZWN0b3IgKSB7XG4gIHdoaWxlICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0gIT0gZG9jdW1lbnQuYm9keSApIHtcbiAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBnZXRRdWVyeUVsZW1lbnQgLS0tLS0gLy9cblxuLy8gdXNlIGVsZW1lbnQgYXMgc2VsZWN0b3Igc3RyaW5nXG51dGlscy5nZXRRdWVyeUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgaWYgKCB0eXBlb2YgZWxlbSA9PSAnc3RyaW5nJyApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbSApO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gLS0tLS0gaGFuZGxlRXZlbnQgLS0tLS0gLy9cblxuLy8gZW5hYmxlIC5vbnR5cGUgdG8gdHJpZ2dlciBmcm9tIC5hZGRFdmVudExpc3RlbmVyKCBlbGVtLCAndHlwZScgKVxudXRpbHMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gZmlsdGVyRmluZEVsZW1lbnRzIC0tLS0tIC8vXG5cbnV0aWxzLmZpbHRlckZpbmRFbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcywgc2VsZWN0b3IgKSB7XG4gIC8vIG1ha2UgYXJyYXkgb2YgZWxlbXNcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBmZkVsZW1zID0gW107XG5cbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgLy8gY2hlY2sgdGhhdCBlbGVtIGlzIGFuIGFjdHVhbCBlbGVtZW50XG4gICAgaWYgKCAhKCBlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWRkIGVsZW0gaWYgbm8gc2VsZWN0b3JcbiAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgIGZmRWxlbXMucHVzaCggZWxlbSApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBmaWx0ZXIgJiBmaW5kIGl0ZW1zIGlmIHdlIGhhdmUgYSBzZWxlY3RvclxuICAgIC8vIGZpbHRlclxuICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBlbGVtICk7XG4gICAgfVxuICAgIC8vIGZpbmQgY2hpbGRyZW5cbiAgICB2YXIgY2hpbGRFbGVtcyA9IGVsZW0ucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKTtcbiAgICAvLyBjb25jYXQgY2hpbGRFbGVtcyB0byBmaWx0ZXJGb3VuZCBhcnJheVxuICAgIGZvciAoIHZhciBpPTA7IGkgPCBjaGlsZEVsZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBjaGlsZEVsZW1zW2ldICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmZFbGVtcztcbn07XG5cbi8vIC0tLS0tIGRlYm91bmNlTWV0aG9kIC0tLS0tIC8vXG5cbnV0aWxzLmRlYm91bmNlTWV0aG9kID0gZnVuY3Rpb24oIF9jbGFzcywgbWV0aG9kTmFtZSwgdGhyZXNob2xkICkge1xuICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMTAwO1xuICAvLyBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG1ldGhvZCA9IF9jbGFzcy5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXTtcbiAgdmFyIHRpbWVvdXROYW1lID0gbWV0aG9kTmFtZSArICdUaW1lb3V0JztcblxuICBfY2xhc3MucHJvdG90eXBlWyBtZXRob2ROYW1lIF0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXNbIHRpbWVvdXROYW1lIF07XG4gICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXNbIHRpbWVvdXROYW1lIF0gPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgIG1ldGhvZC5hcHBseSggX3RoaXMsIGFyZ3MgKTtcbiAgICAgIGRlbGV0ZSBfdGhpc1sgdGltZW91dE5hbWUgXTtcbiAgICB9LCB0aHJlc2hvbGQgKTtcbiAgfTtcbn07XG5cbi8vIC0tLS0tIGRvY1JlYWR5IC0tLS0tIC8vXG5cbnV0aWxzLmRvY1JlYWR5ID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICB2YXIgcmVhZHlTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGU7XG4gIGlmICggcmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnIHx8IHJlYWR5U3RhdGUgPT0gJ2ludGVyYWN0aXZlJyApIHtcbiAgICAvLyBkbyBhc3luYyB0byBhbGxvdyBmb3Igb3RoZXIgc2NyaXB0cyB0byBydW4uIG1ldGFmaXp6eS9mbGlja2l0eSM0NDFcbiAgICBzZXRUaW1lb3V0KCBjYWxsYmFjayApO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2sgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gaHRtbEluaXQgLS0tLS0gLy9cblxuLy8gaHR0cDovL2phbWVzcm9iZXJ0cy5uYW1lL2Jsb2cvMjAxMC8wMi8yMi9zdHJpbmctZnVuY3Rpb25zLWZvci1qYXZhc2NyaXB0LXRyaW0tdG8tY2FtZWwtY2FzZS10by1kYXNoZWQtYW5kLXRvLXVuZGVyc2NvcmUvXG51dGlscy50b0Rhc2hlZCA9IGZ1bmN0aW9uKCBzdHIgKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSggLyguKShbQS1aXSkvZywgZnVuY3Rpb24oIG1hdGNoLCAkMSwgJDIgKSB7XG4gICAgcmV0dXJuICQxICsgJy0nICsgJDI7XG4gIH0pLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuLyoqXG4gKiBhbGxvdyB1c2VyIHRvIGluaXRpYWxpemUgY2xhc3NlcyB2aWEgW2RhdGEtbmFtZXNwYWNlXSBvciAuanMtbmFtZXNwYWNlIGNsYXNzXG4gKiBodG1sSW5pdCggV2lkZ2V0LCAnd2lkZ2V0TmFtZScgKVxuICogb3B0aW9ucyBhcmUgcGFyc2VkIGZyb20gZGF0YS1uYW1lc3BhY2Utb3B0aW9uc1xuICovXG51dGlscy5odG1sSW5pdCA9IGZ1bmN0aW9uKCBXaWRnZXRDbGFzcywgbmFtZXNwYWNlICkge1xuICB1dGlscy5kb2NSZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhc2hlZE5hbWVzcGFjZSA9IHV0aWxzLnRvRGFzaGVkKCBuYW1lc3BhY2UgKTtcbiAgICB2YXIgZGF0YUF0dHIgPSAnZGF0YS0nICsgZGFzaGVkTmFtZXNwYWNlO1xuICAgIHZhciBkYXRhQXR0ckVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ1snICsgZGF0YUF0dHIgKyAnXScgKTtcbiAgICB2YXIganNEYXNoRWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCAnLmpzLScgKyBkYXNoZWROYW1lc3BhY2UgKTtcbiAgICB2YXIgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGRhdGFBdHRyRWxlbXMgKVxuICAgICAgLmNvbmNhdCggdXRpbHMubWFrZUFycmF5KCBqc0Rhc2hFbGVtcyApICk7XG4gICAgdmFyIGRhdGFPcHRpb25zQXR0ciA9IGRhdGFBdHRyICsgJy1vcHRpb25zJztcbiAgICB2YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcblxuICAgIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgdmFyIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggZGF0YUF0dHIgKSB8fFxuICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggZGF0YU9wdGlvbnNBdHRyICk7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wdGlvbnMgPSBhdHRyICYmIEpTT04ucGFyc2UoIGF0dHIgKTtcbiAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICAgICAgLy8gbG9nIGVycm9yLCBkbyBub3QgaW5pdGlhbGl6ZVxuICAgICAgICBpZiAoIGNvbnNvbGUgKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvciggJ0Vycm9yIHBhcnNpbmcgJyArIGRhdGFBdHRyICsgJyBvbiAnICsgZWxlbS5jbGFzc05hbWUgK1xuICAgICAgICAgICc6ICcgKyBlcnJvciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBXaWRnZXRDbGFzcyggZWxlbSwgb3B0aW9ucyApO1xuICAgICAgLy8gbWFrZSBhdmFpbGFibGUgdmlhICQoKS5kYXRhKCduYW1lc3BhY2UnKVxuICAgICAgaWYgKCBqUXVlcnkgKSB7XG4gICAgICAgIGpRdWVyeS5kYXRhKCBlbGVtLCBuYW1lc3BhY2UsIGluc3RhbmNlICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSk7XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIHV0aWxzO1xuXG59KSk7XG4iLCIvLyBhZGQsIHJlbW92ZSBjZWxsXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJy4vZmxpY2tpdHknLFxuICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGlja2l0eSwgdXRpbHMgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgdXRpbHMgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJy4vZmxpY2tpdHknKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5GbGlja2l0eSxcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHNcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgdXRpbHMgKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gYXBwZW5kIGNlbGxzIHRvIGEgZG9jdW1lbnQgZnJhZ21lbnRcbmZ1bmN0aW9uIGdldENlbGxzRnJhZ21lbnQoIGNlbGxzICkge1xuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIGNlbGxzLmZvckVhY2goIGZ1bmN0aW9uKCBjZWxsICkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCBjZWxsLmVsZW1lbnQgKTtcbiAgfSk7XG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYWRkL3JlbW92ZSBjZWxsIHByb3RvdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgcHJvdG8gPSBGbGlja2l0eS5wcm90b3R5cGU7XG5cbi8qKlxuICogSW5zZXJ0LCBwcmVwZW5kLCBvciBhcHBlbmQgY2VsbHNcbiAqIEBwYXJhbSB7RWxlbWVudCwgQXJyYXksIE5vZGVMaXN0fSBlbGVtc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleFxuICovXG5wcm90by5pbnNlcnQgPSBmdW5jdGlvbiggZWxlbXMsIGluZGV4ICkge1xuICB2YXIgY2VsbHMgPSB0aGlzLl9tYWtlQ2VsbHMoIGVsZW1zICk7XG4gIGlmICggIWNlbGxzIHx8ICFjZWxscy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZW4gPSB0aGlzLmNlbGxzLmxlbmd0aDtcbiAgLy8gZGVmYXVsdCB0byBhcHBlbmRcbiAgaW5kZXggPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gbGVuIDogaW5kZXg7XG4gIC8vIGFkZCBjZWxscyB3aXRoIGRvY3VtZW50IGZyYWdtZW50XG4gIHZhciBmcmFnbWVudCA9IGdldENlbGxzRnJhZ21lbnQoIGNlbGxzICk7XG4gIC8vIGFwcGVuZCB0byBzbGlkZXJcbiAgdmFyIGlzQXBwZW5kID0gaW5kZXggPT0gbGVuO1xuICBpZiAoIGlzQXBwZW5kICkge1xuICAgIHRoaXMuc2xpZGVyLmFwcGVuZENoaWxkKCBmcmFnbWVudCApO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnNlcnRDZWxsRWxlbWVudCA9IHRoaXMuY2VsbHNbIGluZGV4IF0uZWxlbWVudDtcbiAgICB0aGlzLnNsaWRlci5pbnNlcnRCZWZvcmUoIGZyYWdtZW50LCBpbnNlcnRDZWxsRWxlbWVudCApO1xuICB9XG4gIC8vIGFkZCB0byB0aGlzLmNlbGxzXG4gIGlmICggaW5kZXggPT09IDAgKSB7XG4gICAgLy8gcHJlcGVuZCwgYWRkIHRvIHN0YXJ0XG4gICAgdGhpcy5jZWxscyA9IGNlbGxzLmNvbmNhdCggdGhpcy5jZWxscyApO1xuICB9IGVsc2UgaWYgKCBpc0FwcGVuZCApIHtcbiAgICAvLyBhcHBlbmQsIGFkZCB0byBlbmRcbiAgICB0aGlzLmNlbGxzID0gdGhpcy5jZWxscy5jb25jYXQoIGNlbGxzICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW5zZXJ0IGluIHRoaXMuY2VsbHNcbiAgICB2YXIgZW5kQ2VsbHMgPSB0aGlzLmNlbGxzLnNwbGljZSggaW5kZXgsIGxlbiAtIGluZGV4ICk7XG4gICAgdGhpcy5jZWxscyA9IHRoaXMuY2VsbHMuY29uY2F0KCBjZWxscyApLmNvbmNhdCggZW5kQ2VsbHMgKTtcbiAgfVxuXG4gIHRoaXMuX3NpemVDZWxscyggY2VsbHMgKTtcbiAgdGhpcy5jZWxsQ2hhbmdlKCBpbmRleCwgdHJ1ZSApO1xufTtcblxucHJvdG8uYXBwZW5kID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB0aGlzLmluc2VydCggZWxlbXMsIHRoaXMuY2VsbHMubGVuZ3RoICk7XG59O1xuXG5wcm90by5wcmVwZW5kID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB0aGlzLmluc2VydCggZWxlbXMsIDAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGNlbGxzXG4gKiBAcGFyYW0ge0VsZW1lbnQsIEFycmF5LCBOb2RlTGlzdH0gZWxlbXNcbiAqL1xucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgY2VsbHMgPSB0aGlzLmdldENlbGxzKCBlbGVtcyApO1xuICBpZiAoICFjZWxscyB8fCAhY2VsbHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtaW5DZWxsSW5kZXggPSB0aGlzLmNlbGxzLmxlbmd0aCAtIDE7XG4gIC8vIHJlbW92ZSBjZWxscyBmcm9tIGNvbGxlY3Rpb24gJiBET01cbiAgY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgY2VsbC5yZW1vdmUoKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNlbGxzLmluZGV4T2YoIGNlbGwgKTtcbiAgICBtaW5DZWxsSW5kZXggPSBNYXRoLm1pbiggaW5kZXgsIG1pbkNlbGxJbmRleCApO1xuICAgIHV0aWxzLnJlbW92ZUZyb20oIHRoaXMuY2VsbHMsIGNlbGwgKTtcbiAgfSwgdGhpcyApO1xuXG4gIHRoaXMuY2VsbENoYW5nZSggbWluQ2VsbEluZGV4LCB0cnVlICk7XG59O1xuXG4vKipcbiAqIGxvZ2ljIHRvIGJlIHJ1biBhZnRlciBhIGNlbGwncyBzaXplIGNoYW5nZXNcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIGNlbGwncyBlbGVtZW50XG4gKi9cbnByb3RvLmNlbGxTaXplQ2hhbmdlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKCBlbGVtICk7XG4gIGlmICggIWNlbGwgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNlbGwuZ2V0U2l6ZSgpO1xuXG4gIHZhciBpbmRleCA9IHRoaXMuY2VsbHMuaW5kZXhPZiggY2VsbCApO1xuICB0aGlzLmNlbGxDaGFuZ2UoIGluZGV4ICk7XG59O1xuXG4vKipcbiAqIGxvZ2ljIGFueSB0aW1lIGEgY2VsbCBpcyBjaGFuZ2VkOiBhZGRlZCwgcmVtb3ZlZCwgb3Igc2l6ZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGNoYW5nZWRDZWxsSW5kZXggLSBpbmRleCBvZiB0aGUgY2hhbmdlZCBjZWxsLCBvcHRpb25hbFxuICovXG5wcm90by5jZWxsQ2hhbmdlID0gZnVuY3Rpb24oIGNoYW5nZWRDZWxsSW5kZXgsIGlzUG9zaXRpb25pbmdTbGlkZXIgKSB7XG4gIHZhciBwcmV2U2VsZWN0ZWRFbGVtID0gdGhpcy5zZWxlY3RlZEVsZW1lbnQ7XG4gIHRoaXMuX3Bvc2l0aW9uQ2VsbHMoIGNoYW5nZWRDZWxsSW5kZXggKTtcbiAgdGhpcy5fZ2V0V3JhcFNoaWZ0Q2VsbHMoKTtcbiAgdGhpcy5zZXRHYWxsZXJ5U2l6ZSgpO1xuICAvLyB1cGRhdGUgc2VsZWN0ZWRJbmRleFxuICAvLyB0cnkgdG8gbWFpbnRhaW4gcG9zaXRpb24gJiBzZWxlY3QgcHJldmlvdXMgc2VsZWN0ZWQgZWxlbWVudFxuICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCggcHJldlNlbGVjdGVkRWxlbSApO1xuICBpZiAoIGNlbGwgKSB7XG4gICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5nZXRDZWxsU2xpZGVJbmRleCggY2VsbCApO1xuICB9XG4gIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKCB0aGlzLnNsaWRlcy5sZW5ndGggLSAxLCB0aGlzLnNlbGVjdGVkSW5kZXggKTtcblxuICB0aGlzLmVtaXRFdmVudCggJ2NlbGxDaGFuZ2UnLCBbIGNoYW5nZWRDZWxsSW5kZXggXSApO1xuICAvLyBwb3NpdGlvbiBzbGlkZXJcbiAgdGhpcy5zZWxlY3QoIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuICAvLyBkbyBub3QgcG9zaXRpb24gc2xpZGVyIGFmdGVyIGxhenkgbG9hZFxuICBpZiAoIGlzUG9zaXRpb25pbmdTbGlkZXIgKSB7XG4gICAgdGhpcy5wb3NpdGlvblNsaWRlckF0U2VsZWN0ZWQoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBGbGlja2l0eTtcblxufSkpO1xuIiwiLy8gYW5pbWF0ZVxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscydcbiAgICBdLCBmdW5jdGlvbiggdXRpbHMgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCB1dGlscyApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuRmxpY2tpdHkgPSB3aW5kb3cuRmxpY2tpdHkgfHwge307XG4gICAgd2luZG93LkZsaWNraXR5LmFuaW1hdGVQcm90b3R5cGUgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LmZpenp5VUlVdGlsc1xuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIHV0aWxzICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGFuaW1hdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIHByb3RvID0ge307XG5cbnByb3RvLnN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5pc0FuaW1hdGluZyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgdGhpcy5yZXN0aW5nRnJhbWVzID0gMDtcbiAgdGhpcy5hbmltYXRlKCk7XG59O1xuXG5wcm90by5hbmltYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYXBwbHlEcmFnRm9yY2UoKTtcbiAgdGhpcy5hcHBseVNlbGVjdGVkQXR0cmFjdGlvbigpO1xuXG4gIHZhciBwcmV2aW91c1ggPSB0aGlzLng7XG5cbiAgdGhpcy5pbnRlZ3JhdGVQaHlzaWNzKCk7XG4gIHRoaXMucG9zaXRpb25TbGlkZXIoKTtcbiAgdGhpcy5zZXR0bGUoIHByZXZpb3VzWCApO1xuICAvLyBhbmltYXRlIG5leHQgZnJhbWVcbiAgaWYgKCB0aGlzLmlzQW5pbWF0aW5nICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbiBhbmltYXRlRnJhbWUoKSB7XG4gICAgICBfdGhpcy5hbmltYXRlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnByb3RvLnBvc2l0aW9uU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcy54O1xuICAvLyB3cmFwIHBvc2l0aW9uIGFyb3VuZFxuICBpZiAoIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kICYmIHRoaXMuY2VsbHMubGVuZ3RoID4gMSApIHtcbiAgICB4ID0gdXRpbHMubW9kdWxvKCB4LCB0aGlzLnNsaWRlYWJsZVdpZHRoICk7XG4gICAgeCA9IHggLSB0aGlzLnNsaWRlYWJsZVdpZHRoO1xuICAgIHRoaXMuc2hpZnRXcmFwQ2VsbHMoIHggKTtcbiAgfVxuXG4gIHRoaXMuc2V0VHJhbnNsYXRlWCggeCwgdGhpcy5pc0FuaW1hdGluZyApO1xuICB0aGlzLmRpc3BhdGNoU2Nyb2xsRXZlbnQoKTtcbn07XG5cbnByb3RvLnNldFRyYW5zbGF0ZVggPSBmdW5jdGlvbiggeCwgaXMzZCApIHtcbiAgeCArPSB0aGlzLmN1cnNvclBvc2l0aW9uO1xuICAvLyByZXZlcnNlIGlmIHJpZ2h0LXRvLWxlZnQgYW5kIHVzaW5nIHRyYW5zZm9ybVxuICB4ID0gdGhpcy5vcHRpb25zLnJpZ2h0VG9MZWZ0ID8gLXggOiB4O1xuICB2YXIgdHJhbnNsYXRlWCA9IHRoaXMuZ2V0UG9zaXRpb25WYWx1ZSggeCApO1xuICAvLyB1c2UgM0QgdHJhbmZvcm1zIGZvciBoYXJkd2FyZSBhY2NlbGVyYXRpb24gb24gaU9TXG4gIC8vIGJ1dCB1c2UgMkQgd2hlbiBzZXR0bGVkLCBmb3IgYmV0dGVyIGZvbnQtcmVuZGVyaW5nXG4gIHRoaXMuc2xpZGVyLnN0eWxlLnRyYW5zZm9ybSA9IGlzM2QgP1xuICAgICd0cmFuc2xhdGUzZCgnICsgdHJhbnNsYXRlWCArICcsMCwwKScgOiAndHJhbnNsYXRlWCgnICsgdHJhbnNsYXRlWCArICcpJztcbn07XG5cbnByb3RvLmRpc3BhdGNoU2Nyb2xsRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpcnN0U2xpZGUgPSB0aGlzLnNsaWRlc1swXTtcbiAgaWYgKCAhZmlyc3RTbGlkZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBvc2l0aW9uWCA9IC10aGlzLnggLSBmaXJzdFNsaWRlLnRhcmdldDtcbiAgdmFyIHByb2dyZXNzID0gcG9zaXRpb25YIC8gdGhpcy5zbGlkZXNXaWR0aDtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnc2Nyb2xsJywgbnVsbCwgWyBwcm9ncmVzcywgcG9zaXRpb25YIF0gKTtcbn07XG5cbnByb3RvLnBvc2l0aW9uU2xpZGVyQXRTZWxlY3RlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLmNlbGxzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy54ID0gLXRoaXMuc2VsZWN0ZWRTbGlkZS50YXJnZXQ7XG4gIHRoaXMudmVsb2NpdHkgPSAwOyAvLyBzdG9wIHdvYmJsZVxuICB0aGlzLnBvc2l0aW9uU2xpZGVyKCk7XG59O1xuXG5wcm90by5nZXRQb3NpdGlvblZhbHVlID0gZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuICBpZiAoIHRoaXMub3B0aW9ucy5wZXJjZW50UG9zaXRpb24gKSB7XG4gICAgLy8gcGVyY2VudCBwb3NpdGlvbiwgcm91bmQgdG8gMiBkaWdpdHMsIGxpa2UgMTIuMzQlXG4gICAgcmV0dXJuICggTWF0aC5yb3VuZCggKCBwb3NpdGlvbiAvIHRoaXMuc2l6ZS5pbm5lcldpZHRoICkgKiAxMDAwMCApICogMC4wMSApKyAnJSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcGl4ZWwgcG9zaXRpb25pbmdcbiAgICByZXR1cm4gTWF0aC5yb3VuZCggcG9zaXRpb24gKSArICdweCc7XG4gIH1cbn07XG5cbnByb3RvLnNldHRsZSA9IGZ1bmN0aW9uKCBwcmV2aW91c1ggKSB7XG4gIC8vIGtlZXAgdHJhY2sgb2YgZnJhbWVzIHdoZXJlIHggaGFzbid0IG1vdmVkXG4gIGlmICggIXRoaXMuaXNQb2ludGVyRG93biAmJiBNYXRoLnJvdW5kKCB0aGlzLnggKiAxMDAgKSA9PSBNYXRoLnJvdW5kKCBwcmV2aW91c1ggKiAxMDAgKSApIHtcbiAgICB0aGlzLnJlc3RpbmdGcmFtZXMrKztcbiAgfVxuICAvLyBzdG9wIGFuaW1hdGluZyBpZiByZXN0aW5nIGZvciAzIG9yIG1vcmUgZnJhbWVzXG4gIGlmICggdGhpcy5yZXN0aW5nRnJhbWVzID4gMiApIHtcbiAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMuaXNGcmVlU2Nyb2xsaW5nO1xuICAgIC8vIHJlbmRlciBwb3NpdGlvbiB3aXRoIHRyYW5zbGF0ZVggd2hlbiBzZXR0bGVkXG4gICAgdGhpcy5wb3NpdGlvblNsaWRlcigpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3NldHRsZScsIG51bGwsIFsgdGhpcy5zZWxlY3RlZEluZGV4IF0gKTtcbiAgfVxufTtcblxucHJvdG8uc2hpZnRXcmFwQ2VsbHMgPSBmdW5jdGlvbiggeCApIHtcbiAgLy8gc2hpZnQgYmVmb3JlIGNlbGxzXG4gIHZhciBiZWZvcmVHYXAgPSB0aGlzLmN1cnNvclBvc2l0aW9uICsgeDtcbiAgdGhpcy5fc2hpZnRDZWxscyggdGhpcy5iZWZvcmVTaGlmdENlbGxzLCBiZWZvcmVHYXAsIC0xICk7XG4gIC8vIHNoaWZ0IGFmdGVyIGNlbGxzXG4gIHZhciBhZnRlckdhcCA9IHRoaXMuc2l6ZS5pbm5lcldpZHRoIC0gKCB4ICsgdGhpcy5zbGlkZWFibGVXaWR0aCArIHRoaXMuY3Vyc29yUG9zaXRpb24gKTtcbiAgdGhpcy5fc2hpZnRDZWxscyggdGhpcy5hZnRlclNoaWZ0Q2VsbHMsIGFmdGVyR2FwLCAxICk7XG59O1xuXG5wcm90by5fc2hpZnRDZWxscyA9IGZ1bmN0aW9uKCBjZWxscywgZ2FwLCBzaGlmdCApIHtcbiAgZm9yICggdmFyIGk9MDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBjZWxsID0gY2VsbHNbaV07XG4gICAgdmFyIGNlbGxTaGlmdCA9IGdhcCA+IDAgPyBzaGlmdCA6IDA7XG4gICAgY2VsbC53cmFwU2hpZnQoIGNlbGxTaGlmdCApO1xuICAgIGdhcCAtPSBjZWxsLnNpemUub3V0ZXJXaWR0aDtcbiAgfVxufTtcblxucHJvdG8uX3Vuc2hpZnRDZWxscyA9IGZ1bmN0aW9uKCBjZWxscyApIHtcbiAgaWYgKCAhY2VsbHMgfHwgIWNlbGxzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICggdmFyIGk9MDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrICkge1xuICAgIGNlbGxzW2ldLndyYXBTaGlmdCggMCApO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwaHlzaWNzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLmludGVncmF0ZVBoeXNpY3MgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54ICs9IHRoaXMudmVsb2NpdHk7XG4gIHRoaXMudmVsb2NpdHkgKj0gdGhpcy5nZXRGcmljdGlvbkZhY3RvcigpO1xufTtcblxucHJvdG8uYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcbiAgdGhpcy52ZWxvY2l0eSArPSBmb3JjZTtcbn07XG5cbnByb3RvLmdldEZyaWN0aW9uRmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxIC0gdGhpcy5vcHRpb25zWyB0aGlzLmlzRnJlZVNjcm9sbGluZyA/ICdmcmVlU2Nyb2xsRnJpY3Rpb24nIDogJ2ZyaWN0aW9uJyBdO1xufTtcblxucHJvdG8uZ2V0UmVzdGluZ1Bvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIC8vIG15IHRoYW5rcyB0byBTdGV2ZW4gV2l0dGVucywgd2hvIHNpbXBsaWZpZWQgdGhpcyBtYXRoIGdyZWF0bHlcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMudmVsb2NpdHkgLyAoIDEgLSB0aGlzLmdldEZyaWN0aW9uRmFjdG9yKCkgKTtcbn07XG5cbnByb3RvLmFwcGx5RHJhZ0ZvcmNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuaXNEcmFnZ2FibGUgfHwgIXRoaXMuaXNQb2ludGVyRG93biApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gY2hhbmdlIHRoZSBwb3NpdGlvbiB0byBkcmFnIHBvc2l0aW9uIGJ5IGFwcGx5aW5nIGZvcmNlXG4gIHZhciBkcmFnVmVsb2NpdHkgPSB0aGlzLmRyYWdYIC0gdGhpcy54O1xuICB2YXIgZHJhZ0ZvcmNlID0gZHJhZ1ZlbG9jaXR5IC0gdGhpcy52ZWxvY2l0eTtcbiAgdGhpcy5hcHBseUZvcmNlKCBkcmFnRm9yY2UgKTtcbn07XG5cbnByb3RvLmFwcGx5U2VsZWN0ZWRBdHRyYWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIG5vdCBhdHRyYWN0IGlmIHBvaW50ZXIgZG93biBvciBubyBzbGlkZXNcbiAgdmFyIGRyYWdEb3duID0gdGhpcy5pc0RyYWdnYWJsZSAmJiB0aGlzLmlzUG9pbnRlckRvd247XG4gIGlmICggZHJhZ0Rvd24gfHwgdGhpcy5pc0ZyZWVTY3JvbGxpbmcgfHwgIXRoaXMuc2xpZGVzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRpc3RhbmNlID0gdGhpcy5zZWxlY3RlZFNsaWRlLnRhcmdldCAqIC0xIC0gdGhpcy54O1xuICB2YXIgZm9yY2UgPSBkaXN0YW5jZSAqIHRoaXMub3B0aW9ucy5zZWxlY3RlZEF0dHJhY3Rpb247XG4gIHRoaXMuYXBwbHlGb3JjZSggZm9yY2UgKTtcbn07XG5cbnJldHVybiBwcm90bztcblxufSkpO1xuIiwiLy8gRmxpY2tpdHkuQ2VsbFxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZSdcbiAgICBdLCBmdW5jdGlvbiggZ2V0U2l6ZSApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LkZsaWNraXR5ID0gd2luZG93LkZsaWNraXR5IHx8IHt9O1xuICAgIHdpbmRvdy5GbGlja2l0eS5DZWxsID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5nZXRTaXplXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgZ2V0U2l6ZSApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBDZWxsKCBlbGVtLCBwYXJlbnQgKSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW07XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbnZhciBwcm90byA9IENlbGwucHJvdG90eXBlO1xuXG5wcm90by5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSggJ2FyaWEtaGlkZGVuJywgJ3RydWUnICk7XG4gIHRoaXMueCA9IDA7XG4gIHRoaXMuc2hpZnQgPSAwO1xufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZXNldCBzdHlsZVxuICB0aGlzLnVuc2VsZWN0KCk7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICB2YXIgc2lkZSA9IHRoaXMucGFyZW50Lm9yaWdpblNpZGU7XG4gIHRoaXMuZWxlbWVudC5zdHlsZVsgc2lkZSBdID0gJyc7XG59O1xuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xufTtcblxucHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiggeCApIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy51cGRhdGVUYXJnZXQoKTtcbiAgdGhpcy5yZW5kZXJQb3NpdGlvbiggeCApO1xufTtcblxuLy8gc2V0RGVmYXVsdFRhcmdldCB2MSBtZXRob2QsIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCByZW1vdmUgaW4gdjNcbnByb3RvLnVwZGF0ZVRhcmdldCA9IHByb3RvLnNldERlZmF1bHRUYXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1hcmdpblByb3BlcnR5ID0gdGhpcy5wYXJlbnQub3JpZ2luU2lkZSA9PSAnbGVmdCcgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnO1xuICB0aGlzLnRhcmdldCA9IHRoaXMueCArIHRoaXMuc2l6ZVsgbWFyZ2luUHJvcGVydHkgXSArXG4gICAgdGhpcy5zaXplLndpZHRoICogdGhpcy5wYXJlbnQuY2VsbEFsaWduO1xufTtcblxucHJvdG8ucmVuZGVyUG9zaXRpb24gPSBmdW5jdGlvbiggeCApIHtcbiAgLy8gcmVuZGVyIHBvc2l0aW9uIG9mIGNlbGwgd2l0aCBpbiBzbGlkZXJcbiAgdmFyIHNpZGUgPSB0aGlzLnBhcmVudC5vcmlnaW5TaWRlO1xuICB0aGlzLmVsZW1lbnQuc3R5bGVbIHNpZGUgXSA9IHRoaXMucGFyZW50LmdldFBvc2l0aW9uVmFsdWUoIHggKTtcbn07XG5cbnByb3RvLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaXMtc2VsZWN0ZWQnKTtcbiAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbn07XG5cbnByb3RvLnVuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1zZWxlY3RlZCcpO1xuICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfSBmYWN0b3IgLSAwLCAxLCBvciAtMVxuKiovXG5wcm90by53cmFwU2hpZnQgPSBmdW5jdGlvbiggc2hpZnQgKSB7XG4gIHRoaXMuc2hpZnQgPSBzaGlmdDtcbiAgdGhpcy5yZW5kZXJQb3NpdGlvbiggdGhpcy54ICsgdGhpcy5wYXJlbnQuc2xpZGVhYmxlV2lkdGggKiBzaGlmdCApO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cbnJldHVybiBDZWxsO1xuXG59KSk7XG4iLCIvLyBkcmFnXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJy4vZmxpY2tpdHknLFxuICAgICAgJ3VuaWRyYWdnZXIvdW5pZHJhZ2dlcicsXG4gICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnXG4gICAgXSwgZnVuY3Rpb24oIEZsaWNraXR5LCBVbmlkcmFnZ2VyLCB1dGlscyApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCBVbmlkcmFnZ2VyLCB1dGlscyApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnLi9mbGlja2l0eScpLFxuICAgICAgcmVxdWlyZSgndW5pZHJhZ2dlcicpLFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuRmxpY2tpdHkgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LkZsaWNraXR5LFxuICAgICAgd2luZG93LlVuaWRyYWdnZXIsXG4gICAgICB3aW5kb3cuZml6enlVSVV0aWxzXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRmxpY2tpdHksIFVuaWRyYWdnZXIsIHV0aWxzICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tIGRlZmF1bHRzIC0tLS0tIC8vXG5cbnV0aWxzLmV4dGVuZCggRmxpY2tpdHkuZGVmYXVsdHMsIHtcbiAgZHJhZ2dhYmxlOiAnPjEnLFxuICBkcmFnVGhyZXNob2xkOiAzLFxufSk7XG5cbi8vIC0tLS0tIGNyZWF0ZSAtLS0tLSAvL1xuXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzLnB1c2goJ19jcmVhdGVEcmFnJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRyYWcgcHJvdG90eXBlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBwcm90byA9IEZsaWNraXR5LnByb3RvdHlwZTtcbnV0aWxzLmV4dGVuZCggcHJvdG8sIFVuaWRyYWdnZXIucHJvdG90eXBlICk7XG5wcm90by5fdG91Y2hBY3Rpb25WYWx1ZSA9ICdwYW4teSc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgaXNUb3VjaCA9ICdjcmVhdGVUb3VjaCcgaW4gZG9jdW1lbnQ7XG52YXIgaXNUb3VjaG1vdmVTY3JvbGxDYW5jZWxlZCA9IGZhbHNlO1xuXG5wcm90by5fY3JlYXRlRHJhZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9uKCAnYWN0aXZhdGUnLCB0aGlzLm9uQWN0aXZhdGVEcmFnICk7XG4gIHRoaXMub24oICd1aUNoYW5nZScsIHRoaXMuX3VpQ2hhbmdlRHJhZyApO1xuICB0aGlzLm9uKCAnZGVhY3RpdmF0ZScsIHRoaXMub25EZWFjdGl2YXRlRHJhZyApO1xuICB0aGlzLm9uKCAnY2VsbENoYW5nZScsIHRoaXMudXBkYXRlRHJhZ2dhYmxlICk7XG4gIC8vIFRPRE8gdXBkYXRlRHJhZ2dhYmxlIG9uIHJlc2l6ZT8gaWYgZ3JvdXBDZWxscyAmIHNsaWRlcyBjaGFuZ2VcbiAgLy8gSEFDSyAtIGFkZCBzZWVtaW5nbHkgaW5ub2N1b3VzIGhhbmRsZXIgdG8gZml4IGlPUyAxMCBzY3JvbGwgYmVoYXZpb3JcbiAgLy8gIzQ1NywgUnViYVhhL1NvcnRhYmxlIzk3M1xuICBpZiAoIGlzVG91Y2ggJiYgIWlzVG91Y2htb3ZlU2Nyb2xsQ2FuY2VsZWQgKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBmdW5jdGlvbigpIHt9KTtcbiAgICBpc1RvdWNobW92ZVNjcm9sbENhbmNlbGVkID0gdHJ1ZTtcbiAgfVxufTtcblxucHJvdG8ub25BY3RpdmF0ZURyYWcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYW5kbGVzID0gWyB0aGlzLnZpZXdwb3J0IF07XG4gIHRoaXMuYmluZEhhbmRsZXMoKTtcbiAgdGhpcy51cGRhdGVEcmFnZ2FibGUoKTtcbn07XG5cbnByb3RvLm9uRGVhY3RpdmF0ZURyYWcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy51bmJpbmRIYW5kbGVzKCk7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kcmFnZ2FibGUnKTtcbn07XG5cbnByb3RvLnVwZGF0ZURyYWdnYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkaXNhYmxlIGRyYWdnaW5nIGlmIGxlc3MgdGhhbiAyIHNsaWRlcy4gIzI3OFxuICBpZiAoIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPT0gJz4xJyApIHtcbiAgICB0aGlzLmlzRHJhZ2dhYmxlID0gdGhpcy5zbGlkZXMubGVuZ3RoID4gMTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcbiAgfVxuICBpZiAoIHRoaXMuaXNEcmFnZ2FibGUgKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLWRyYWdnYWJsZScpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kcmFnZ2FibGUnKTtcbiAgfVxufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbnByb3RvLmJpbmREcmFnID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xuICB0aGlzLnVwZGF0ZURyYWdnYWJsZSgpO1xufTtcblxucHJvdG8udW5iaW5kRHJhZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlRHJhZ2dhYmxlKCk7XG59O1xuXG5wcm90by5fdWlDaGFuZ2VEcmFnID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLmlzRnJlZVNjcm9sbGluZztcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHBvaW50ZXIgZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRHJhZ2dhYmxlICkge1xuICAgIHRoaXMuX3BvaW50ZXJEb3duRGVmYXVsdCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzT2theSA9IHRoaXMub2theVBvaW50ZXJEb3duKCBldmVudCApO1xuICBpZiAoICFpc09rYXkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcG9pbnRlckRvd25QcmV2ZW50RGVmYXVsdCggZXZlbnQgKTtcbiAgdGhpcy5wb2ludGVyRG93bkZvY3VzKCBldmVudCApO1xuICAvLyBibHVyXG4gIGlmICggZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmVsZW1lbnQgKSB7XG4gICAgLy8gZG8gbm90IGJsdXIgaWYgYWxyZWFkeSBmb2N1c2VkXG4gICAgdGhpcy5wb2ludGVyRG93bkJsdXIoKTtcbiAgfVxuXG4gIC8vIHN0b3AgaWYgaXQgd2FzIG1vdmluZ1xuICB0aGlzLmRyYWdYID0gdGhpcy54O1xuICB0aGlzLnZpZXdwb3J0LmNsYXNzTGlzdC5hZGQoJ2lzLXBvaW50ZXItZG93bicpO1xuICAvLyB0cmFjayBzY3JvbGxpbmdcbiAgdGhpcy5wb2ludGVyRG93blNjcm9sbCA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcyApO1xuXG4gIHRoaXMuX3BvaW50ZXJEb3duRGVmYXVsdCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIGRlZmF1bHQgcG9pbnRlckRvd24gbG9naWMsIHVzZWQgZm9yIHN0YXRpY0NsaWNrXG5wcm90by5fcG9pbnRlckRvd25EZWZhdWx0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyB0cmFjayBzdGFydCBldmVudCBwb3NpdGlvblxuICAvLyBTYWZhcmkgOSBvdmVycmlkZXMgcGFnZVggYW5kIHBhZ2VZLiBUaGVzZSB2YWx1ZXMgbmVlZHMgdG8gYmUgY29waWVkLiAjNzc5XG4gIHRoaXMucG9pbnRlckRvd25Qb2ludGVyID0ge1xuICAgIHBhZ2VYOiBwb2ludGVyLnBhZ2VYLFxuICAgIHBhZ2VZOiBwb2ludGVyLnBhZ2VZLFxuICB9O1xuICAvLyBiaW5kIG1vdmUgYW5kIGVuZCBldmVudHNcbiAgdGhpcy5fYmluZFBvc3RTdGFydEV2ZW50cyggZXZlbnQgKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAncG9pbnRlckRvd24nLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbn07XG5cbnZhciBmb2N1c05vZGVzID0ge1xuICBJTlBVVDogdHJ1ZSxcbiAgVEVYVEFSRUE6IHRydWUsXG4gIFNFTEVDVDogdHJ1ZSxcbn07XG5cbnByb3RvLnBvaW50ZXJEb3duRm9jdXMgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBpc0ZvY3VzTm9kZSA9IGZvY3VzTm9kZXNbIGV2ZW50LnRhcmdldC5ub2RlTmFtZSBdO1xuICBpZiAoICFpc0ZvY3VzTm9kZSApIHtcbiAgICB0aGlzLmZvY3VzKCk7XG4gIH1cbn07XG5cbnByb3RvLl9wb2ludGVyRG93blByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB2YXIgaXNUb3VjaFN0YXJ0ID0gZXZlbnQudHlwZSA9PSAndG91Y2hzdGFydCc7XG4gIHZhciBpc1RvdWNoUG9pbnRlciA9IGV2ZW50LnBvaW50ZXJUeXBlID09ICd0b3VjaCc7XG4gIHZhciBpc0ZvY3VzTm9kZSA9IGZvY3VzTm9kZXNbIGV2ZW50LnRhcmdldC5ub2RlTmFtZSBdO1xuICBpZiAoICFpc1RvdWNoU3RhcnQgJiYgIWlzVG91Y2hQb2ludGVyICYmICFpc0ZvY3VzTm9kZSApIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBtb3ZlIC0tLS0tIC8vXG5cbnByb3RvLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XG4gIHJldHVybiBNYXRoLmFicyggbW92ZVZlY3Rvci54ICkgPiB0aGlzLm9wdGlvbnMuZHJhZ1RocmVzaG9sZDtcbn07XG5cbi8vIC0tLS0tIHVwIC0tLS0tIC8vXG5cbnByb3RvLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgZGVsZXRlIHRoaXMuaXNUb3VjaFNjcm9sbGluZztcbiAgdGhpcy52aWV3cG9ydC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1wb2ludGVyLWRvd24nKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAncG9pbnRlclVwJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG4gIHRoaXMuX2RyYWdQb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5wb2ludGVyRG9uZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Njcm9sbCcsIHRoaXMgKTtcbiAgZGVsZXRlIHRoaXMucG9pbnRlckRvd25TY3JvbGw7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnZ2luZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5wcm90by5kcmFnU3RhcnQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIGlmICggIXRoaXMuaXNEcmFnZ2FibGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZHJhZ1N0YXJ0UG9zaXRpb24gPSB0aGlzLng7XG4gIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzY3JvbGwnLCB0aGlzICk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdTdGFydCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xufTtcblxucHJvdG8ucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHZhciBtb3ZlVmVjdG9yID0gdGhpcy5fZHJhZ1BvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdwb2ludGVyTW92ZScsIGV2ZW50LCBbIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xuICB0aGlzLl9kcmFnTW92ZSggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKTtcbn07XG5cbnByb3RvLmRyYWdNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xuICBpZiAoICF0aGlzLmlzRHJhZ2dhYmxlICkge1xuICAgIHJldHVybjtcbiAgfVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMucHJldmlvdXNEcmFnWCA9IHRoaXMuZHJhZ1g7XG4gIC8vIHJldmVyc2UgaWYgcmlnaHQtdG8tbGVmdFxuICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLnJpZ2h0VG9MZWZ0ID8gLTEgOiAxO1xuICBpZiAoIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kICkge1xuICAgIC8vIHdyYXAgYXJvdW5kIG1vdmUuICM1ODlcbiAgICBtb3ZlVmVjdG9yLnggPSBtb3ZlVmVjdG9yLnggJSB0aGlzLnNsaWRlYWJsZVdpZHRoO1xuICB9XG4gIHZhciBkcmFnWCA9IHRoaXMuZHJhZ1N0YXJ0UG9zaXRpb24gKyBtb3ZlVmVjdG9yLnggKiBkaXJlY3Rpb247XG5cbiAgaWYgKCAhdGhpcy5vcHRpb25zLndyYXBBcm91bmQgJiYgdGhpcy5zbGlkZXMubGVuZ3RoICkge1xuICAgIC8vIHNsb3cgZHJhZ1xuICAgIHZhciBvcmlnaW5Cb3VuZCA9IE1hdGgubWF4KCAtdGhpcy5zbGlkZXNbMF0udGFyZ2V0LCB0aGlzLmRyYWdTdGFydFBvc2l0aW9uICk7XG4gICAgZHJhZ1ggPSBkcmFnWCA+IG9yaWdpbkJvdW5kID8gKCBkcmFnWCArIG9yaWdpbkJvdW5kICkgKiAwLjUgOiBkcmFnWDtcbiAgICB2YXIgZW5kQm91bmQgPSBNYXRoLm1pbiggLXRoaXMuZ2V0TGFzdFNsaWRlKCkudGFyZ2V0LCB0aGlzLmRyYWdTdGFydFBvc2l0aW9uICk7XG4gICAgZHJhZ1ggPSBkcmFnWCA8IGVuZEJvdW5kID8gKCBkcmFnWCArIGVuZEJvdW5kICkgKiAwLjUgOiBkcmFnWDtcbiAgfVxuXG4gIHRoaXMuZHJhZ1ggPSBkcmFnWDtcblxuICB0aGlzLmRyYWdNb3ZlVGltZSA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdNb3ZlJywgZXZlbnQsIFsgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XG59O1xuXG5wcm90by5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRHJhZ2dhYmxlICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIHRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsICkge1xuICAgIHRoaXMuaXNGcmVlU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgfVxuICAvLyBzZXQgc2VsZWN0ZWRJbmRleCBiYXNlZCBvbiB3aGVyZSBmbGljayB3aWxsIGVuZCB1cFxuICB2YXIgaW5kZXggPSB0aGlzLmRyYWdFbmRSZXN0aW5nU2VsZWN0KCk7XG5cbiAgaWYgKCB0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCAmJiAhdGhpcy5vcHRpb25zLndyYXBBcm91bmQgKSB7XG4gICAgLy8gaWYgZnJlZS1zY3JvbGwgJiBub3Qgd3JhcCBhcm91bmRcbiAgICAvLyBkbyBub3QgZnJlZS1zY3JvbGwgaWYgZ29pbmcgb3V0c2lkZSBvZiBib3VuZGluZyBzbGlkZXNcbiAgICAvLyBzbyBib3VuZGluZyBzbGlkZXMgY2FuIGF0dHJhY3Qgc2xpZGVyLCBhbmQga2VlcCBpdCBpbiBib3VuZHNcbiAgICB2YXIgcmVzdGluZ1ggPSB0aGlzLmdldFJlc3RpbmdQb3NpdGlvbigpO1xuICAgIHRoaXMuaXNGcmVlU2Nyb2xsaW5nID0gLXJlc3RpbmdYID4gdGhpcy5zbGlkZXNbMF0udGFyZ2V0ICYmXG4gICAgICAtcmVzdGluZ1ggPCB0aGlzLmdldExhc3RTbGlkZSgpLnRhcmdldDtcbiAgfSBlbHNlIGlmICggIXRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsICYmIGluZGV4ID09IHRoaXMuc2VsZWN0ZWRJbmRleCApIHtcbiAgICAvLyBib29zdCBzZWxlY3Rpb24gaWYgc2VsZWN0ZWQgaW5kZXggaGFzIG5vdCBjaGFuZ2VkXG4gICAgaW5kZXggKz0gdGhpcy5kcmFnRW5kQm9vc3RTZWxlY3QoKTtcbiAgfVxuICBkZWxldGUgdGhpcy5wcmV2aW91c0RyYWdYO1xuICAvLyBhcHBseSBzZWxlY3Rpb25cbiAgLy8gVE9ETyByZWZhY3RvciB0aGlzLCBzZWxlY3RpbmcgaGVyZSBmZWVscyB3ZWlyZFxuICAvLyBIQUNLLCBzZXQgZmxhZyBzbyBkcmFnZ2luZyBzdGF5cyBpbiBjb3JyZWN0IGRpcmVjdGlvblxuICB0aGlzLmlzRHJhZ1NlbGVjdCA9IHRoaXMub3B0aW9ucy53cmFwQXJvdW5kO1xuICB0aGlzLnNlbGVjdCggaW5kZXggKTtcbiAgZGVsZXRlIHRoaXMuaXNEcmFnU2VsZWN0O1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnRW5kJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG5wcm90by5kcmFnRW5kUmVzdGluZ1NlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdGluZ1ggPSB0aGlzLmdldFJlc3RpbmdQb3NpdGlvbigpO1xuICAvLyBob3cgZmFyIGF3YXkgZnJvbSBzZWxlY3RlZCBzbGlkZVxuICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyggdGhpcy5nZXRTbGlkZURpc3RhbmNlKCAtcmVzdGluZ1gsIHRoaXMuc2VsZWN0ZWRJbmRleCApICk7XG4gIC8vIGdldCBjbG9zZXQgcmVzdGluZyBnb2luZyB1cCBhbmQgZ29pbmcgZG93blxuICB2YXIgcG9zaXRpdmVSZXN0aW5nID0gdGhpcy5fZ2V0Q2xvc2VzdFJlc3RpbmcoIHJlc3RpbmdYLCBkaXN0YW5jZSwgMSApO1xuICB2YXIgbmVnYXRpdmVSZXN0aW5nID0gdGhpcy5fZ2V0Q2xvc2VzdFJlc3RpbmcoIHJlc3RpbmdYLCBkaXN0YW5jZSwgLTEgKTtcbiAgLy8gdXNlIGNsb3NlciByZXN0aW5nIGZvciB3cmFwLWFyb3VuZFxuICB2YXIgaW5kZXggPSBwb3NpdGl2ZVJlc3RpbmcuZGlzdGFuY2UgPCBuZWdhdGl2ZVJlc3RpbmcuZGlzdGFuY2UgP1xuICAgIHBvc2l0aXZlUmVzdGluZy5pbmRleCA6IG5lZ2F0aXZlUmVzdGluZy5pbmRleDtcbiAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBnaXZlbiByZXN0aW5nIFggYW5kIGRpc3RhbmNlIHRvIHNlbGVjdGVkIGNlbGxcbiAqIGdldCB0aGUgZGlzdGFuY2UgYW5kIGluZGV4IG9mIHRoZSBjbG9zZXN0IGNlbGxcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXN0aW5nWCAtIGVzdGltYXRlZCBwb3N0LWZsaWNrIHJlc3RpbmcgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSAtIGRpc3RhbmNlIHRvIHNlbGVjdGVkIGNlbGxcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5jcmVtZW50IC0gKzEgb3IgLTEsIGdvaW5nIHVwIG9yIGRvd25cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0geyBkaXN0YW5jZToge051bWJlcn0sIGluZGV4OiB7SW50ZWdlcn0gfVxuICovXG5wcm90by5fZ2V0Q2xvc2VzdFJlc3RpbmcgPSBmdW5jdGlvbiggcmVzdGluZ1gsIGRpc3RhbmNlLCBpbmNyZW1lbnQgKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgdmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gIHZhciBjb25kaXRpb24gPSB0aGlzLm9wdGlvbnMuY29udGFpbiAmJiAhdGhpcy5vcHRpb25zLndyYXBBcm91bmQgP1xuICAgIC8vIGlmIGNvbnRhaW4sIGtlZXAgZ29pbmcgaWYgZGlzdGFuY2UgaXMgZXF1YWwgdG8gbWluRGlzdGFuY2VcbiAgICBmdW5jdGlvbiggZCwgbWQgKSB7IHJldHVybiBkIDw9IG1kOyB9IDogZnVuY3Rpb24oIGQsIG1kICkgeyByZXR1cm4gZCA8IG1kOyB9O1xuICB3aGlsZSAoIGNvbmRpdGlvbiggZGlzdGFuY2UsIG1pbkRpc3RhbmNlICkgKSB7XG4gICAgLy8gbWVhc3VyZSBkaXN0YW5jZSB0byBuZXh0IGNlbGxcbiAgICBpbmRleCArPSBpbmNyZW1lbnQ7XG4gICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBkaXN0YW5jZSA9IHRoaXMuZ2V0U2xpZGVEaXN0YW5jZSggLXJlc3RpbmdYLCBpbmRleCApO1xuICAgIGlmICggZGlzdGFuY2UgPT09IG51bGwgKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRpc3RhbmNlOiBtaW5EaXN0YW5jZSxcbiAgICAvLyBzZWxlY3RlZCB3YXMgcHJldmlvdXMgaW5kZXhcbiAgICBpbmRleDogaW5kZXggLSBpbmNyZW1lbnRcbiAgfTtcbn07XG5cbi8qKlxuICogbWVhc3VyZSBkaXN0YW5jZSBiZXR3ZWVuIHggYW5kIGEgc2xpZGUgdGFyZ2V0XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCAtIHNsaWRlIGluZGV4XG4gKi9cbnByb3RvLmdldFNsaWRlRGlzdGFuY2UgPSBmdW5jdGlvbiggeCwgaW5kZXggKSB7XG4gIHZhciBsZW4gPSB0aGlzLnNsaWRlcy5sZW5ndGg7XG4gIC8vIHdyYXAgYXJvdW5kIGlmIGF0IGxlYXN0IDIgc2xpZGVzXG4gIHZhciBpc1dyYXBBcm91bmQgPSB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCAmJiBsZW4gPiAxO1xuICB2YXIgc2xpZGVJbmRleCA9IGlzV3JhcEFyb3VuZCA/IHV0aWxzLm1vZHVsbyggaW5kZXgsIGxlbiApIDogaW5kZXg7XG4gIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzWyBzbGlkZUluZGV4IF07XG4gIGlmICggIXNsaWRlICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGFkZCBkaXN0YW5jZSBmb3Igd3JhcC1hcm91bmQgc2xpZGVzXG4gIHZhciB3cmFwID0gaXNXcmFwQXJvdW5kID8gdGhpcy5zbGlkZWFibGVXaWR0aCAqIE1hdGguZmxvb3IoIGluZGV4IC8gbGVuICkgOiAwO1xuICByZXR1cm4geCAtICggc2xpZGUudGFyZ2V0ICsgd3JhcCApO1xufTtcblxucHJvdG8uZHJhZ0VuZEJvb3N0U2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIG5vdCBib29zdCBpZiBubyBwcmV2aW91c0RyYWdYIG9yIGRyYWdNb3ZlVGltZVxuICBpZiAoIHRoaXMucHJldmlvdXNEcmFnWCA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmRyYWdNb3ZlVGltZSB8fFxuICAgIC8vIG9yIGlmIGRyYWcgd2FzIGhlbGQgZm9yIDEwMCBtc1xuICAgIG5ldyBEYXRlKCkgLSB0aGlzLmRyYWdNb3ZlVGltZSA+IDEwMCApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXN0YW5jZSA9IHRoaXMuZ2V0U2xpZGVEaXN0YW5jZSggLXRoaXMuZHJhZ1gsIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuICB2YXIgZGVsdGEgPSB0aGlzLnByZXZpb3VzRHJhZ1ggLSB0aGlzLmRyYWdYO1xuICBpZiAoIGRpc3RhbmNlID4gMCAmJiBkZWx0YSA+IDAgKSB7XG4gICAgLy8gYm9vc3QgdG8gbmV4dCBpZiBtb3ZpbmcgdG93YXJkcyB0aGUgcmlnaHQsIGFuZCBwb3NpdGl2ZSB2ZWxvY2l0eVxuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKCBkaXN0YW5jZSA8IDAgJiYgZGVsdGEgPCAwICkge1xuICAgIC8vIGJvb3N0IHRvIHByZXZpb3VzIGlmIG1vdmluZyB0b3dhcmRzIHRoZSBsZWZ0LCBhbmQgbmVnYXRpdmUgdmVsb2NpdHlcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG4vLyAtLS0tLSBzdGF0aWNDbGljayAtLS0tLSAvL1xuXG5wcm90by5zdGF0aWNDbGljayA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgLy8gZ2V0IGNsaWNrZWRDZWxsLCBpZiBjZWxsIHdhcyBjbGlja2VkXG4gIHZhciBjbGlja2VkQ2VsbCA9IHRoaXMuZ2V0UGFyZW50Q2VsbCggZXZlbnQudGFyZ2V0ICk7XG4gIHZhciBjZWxsRWxlbSA9IGNsaWNrZWRDZWxsICYmIGNsaWNrZWRDZWxsLmVsZW1lbnQ7XG4gIHZhciBjZWxsSW5kZXggPSBjbGlja2VkQ2VsbCAmJiB0aGlzLmNlbGxzLmluZGV4T2YoIGNsaWNrZWRDZWxsICk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3N0YXRpY0NsaWNrJywgZXZlbnQsIFsgcG9pbnRlciwgY2VsbEVsZW0sIGNlbGxJbmRleCBdICk7XG59O1xuXG4vLyAtLS0tLSBzY3JvbGwgLS0tLS0gLy9cblxucHJvdG8ub25zY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNjcm9sbCA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gIHZhciBzY3JvbGxNb3ZlWCA9IHRoaXMucG9pbnRlckRvd25TY3JvbGwueCAtIHNjcm9sbC54O1xuICB2YXIgc2Nyb2xsTW92ZVkgPSB0aGlzLnBvaW50ZXJEb3duU2Nyb2xsLnkgLSBzY3JvbGwueTtcbiAgLy8gY2FuY2VsIGNsaWNrL3RhcCBpZiBzY3JvbGwgaXMgdG9vIG11Y2hcbiAgaWYgKCBNYXRoLmFicyggc2Nyb2xsTW92ZVggKSA+IDMgfHwgTWF0aC5hYnMoIHNjcm9sbE1vdmVZICkgPiAzICkge1xuICAgIHRoaXMuX3BvaW50ZXJEb25lKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIHV0aWxzIC0tLS0tIC8vXG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfTtcbn1cblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBGbGlja2l0eTtcblxufSkpO1xuIiwiLy8gRmxpY2tpdHkgbWFpblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscycsXG4gICAgICAnLi9jZWxsJyxcbiAgICAgICcuL3NsaWRlJyxcbiAgICAgICcuL2FuaW1hdGUnXG4gICAgXSwgZnVuY3Rpb24oIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIENlbGwsIFNsaWRlLCBhbmltYXRlUHJvdG90eXBlICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgQ2VsbCwgU2xpZGUsIGFuaW1hdGVQcm90b3R5cGUgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpLFxuICAgICAgcmVxdWlyZSgnLi9jZWxsJyksXG4gICAgICByZXF1aXJlKCcuL3NsaWRlJyksXG4gICAgICByZXF1aXJlKCcuL2FuaW1hdGUnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB2YXIgX0ZsaWNraXR5ID0gd2luZG93LkZsaWNraXR5O1xuXG4gICAgd2luZG93LkZsaWNraXR5ID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXIsXG4gICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHMsXG4gICAgICBfRmxpY2tpdHkuQ2VsbCxcbiAgICAgIF9GbGlja2l0eS5TbGlkZSxcbiAgICAgIF9GbGlja2l0eS5hbmltYXRlUHJvdG90eXBlXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLFxuICB1dGlscywgQ2VsbCwgU2xpZGUsIGFuaW1hdGVQcm90b3R5cGUgKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gdmFyc1xudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG52YXIgZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlO1xudmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcblxuZnVuY3Rpb24gbW92ZUVsZW1lbnRzKCBlbGVtcywgdG9FbGVtICkge1xuICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgd2hpbGUgKCBlbGVtcy5sZW5ndGggKSB7XG4gICAgdG9FbGVtLmFwcGVuZENoaWxkKCBlbGVtcy5zaGlmdCgpICk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRmxpY2tpdHkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXJzXG52YXIgR1VJRCA9IDA7XG4vLyBpbnRlcm5hbCBzdG9yZSBvZiBhbGwgRmxpY2tpdHkgaW50YW5jZXNcbnZhciBpbnN0YW5jZXMgPSB7fTtcblxuZnVuY3Rpb24gRmxpY2tpdHkoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIHZhciBxdWVyeUVsZW1lbnQgPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgaWYgKCAhcXVlcnlFbGVtZW50ICkge1xuICAgIGlmICggY29uc29sZSApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdCYWQgZWxlbWVudCBmb3IgRmxpY2tpdHk6ICcgKyAoIHF1ZXJ5RWxlbWVudCB8fCBlbGVtZW50ICkgKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZWxlbWVudCA9IHF1ZXJ5RWxlbWVudDtcbiAgLy8gZG8gbm90IGluaXRpYWxpemUgdHdpY2Ugb24gc2FtZSBlbGVtZW50XG4gIGlmICggdGhpcy5lbGVtZW50LmZsaWNraXR5R1VJRCApIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbIHRoaXMuZWxlbWVudC5mbGlja2l0eUdVSUQgXTtcbiAgICBpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvLyBhZGQgalF1ZXJ5XG4gIGlmICggalF1ZXJ5ICkge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICB9XG4gIC8vIG9wdGlvbnNcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKCB7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cyApO1xuICB0aGlzLm9wdGlvbiggb3B0aW9ucyApO1xuXG4gIC8vIGtpY2sgdGhpbmdzIG9mZlxuICB0aGlzLl9jcmVhdGUoKTtcbn1cblxuRmxpY2tpdHkuZGVmYXVsdHMgPSB7XG4gIGFjY2Vzc2liaWxpdHk6IHRydWUsXG4gIC8vIGFkYXB0aXZlSGVpZ2h0OiBmYWxzZSxcbiAgY2VsbEFsaWduOiAnY2VudGVyJyxcbiAgLy8gY2VsbFNlbGVjdG9yOiB1bmRlZmluZWQsXG4gIC8vIGNvbnRhaW46IGZhbHNlLFxuICBmcmVlU2Nyb2xsRnJpY3Rpb246IDAuMDc1LCAvLyBmcmljdGlvbiB3aGVuIGZyZWUtc2Nyb2xsaW5nXG4gIGZyaWN0aW9uOiAwLjI4LCAvLyBmcmljdGlvbiB3aGVuIHNlbGVjdGluZ1xuICBuYW1lc3BhY2VKUXVlcnlFdmVudHM6IHRydWUsXG4gIC8vIGluaXRpYWxJbmRleDogMCxcbiAgcGVyY2VudFBvc2l0aW9uOiB0cnVlLFxuICByZXNpemU6IHRydWUsXG4gIHNlbGVjdGVkQXR0cmFjdGlvbjogMC4wMjUsXG4gIHNldEdhbGxlcnlTaXplOiB0cnVlXG4gIC8vIHdhdGNoQ1NTOiBmYWxzZSxcbiAgLy8gd3JhcEFyb3VuZDogZmFsc2Vcbn07XG5cbi8vIGhhc2ggb2YgbWV0aG9kcyB0cmlnZ2VyZWQgb24gX2NyZWF0ZSgpXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzID0gW107XG5cbnZhciBwcm90byA9IEZsaWNraXR5LnByb3RvdHlwZTtcbi8vIGluaGVyaXQgRXZlbnRFbWl0dGVyXG51dGlscy5leHRlbmQoIHByb3RvLCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gYWRkIGlkIGZvciBGbGlja2l0eS5kYXRhXG4gIHZhciBpZCA9IHRoaXMuZ3VpZCA9ICsrR1VJRDtcbiAgdGhpcy5lbGVtZW50LmZsaWNraXR5R1VJRCA9IGlkOyAvLyBleHBhbmRvXG4gIGluc3RhbmNlc1sgaWQgXSA9IHRoaXM7IC8vIGFzc29jaWF0ZSB2aWEgaWRcbiAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gIHRoaXMuc2VsZWN0ZWRJbmRleCA9IDA7XG4gIC8vIGhvdyBtYW55IGZyYW1lcyBzbGlkZXIgaGFzIGJlZW4gaW4gc2FtZSBwb3NpdGlvblxuICB0aGlzLnJlc3RpbmdGcmFtZXMgPSAwO1xuICAvLyBpbml0aWFsIHBoeXNpY3MgcHJvcGVydGllc1xuICB0aGlzLnggPSAwO1xuICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgdGhpcy5vcmlnaW5TaWRlID0gdGhpcy5vcHRpb25zLnJpZ2h0VG9MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgLy8gY3JlYXRlIHZpZXdwb3J0ICYgc2xpZGVyXG4gIHRoaXMudmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy52aWV3cG9ydC5jbGFzc05hbWUgPSAnZmxpY2tpdHktdmlld3BvcnQnO1xuICB0aGlzLl9jcmVhdGVTbGlkZXIoKTtcblxuICBpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgfHwgdGhpcy5vcHRpb25zLndhdGNoQ1NTICkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcyApO1xuICB9XG5cbiAgLy8gYWRkIGxpc3RlbmVycyBmcm9tIG9uIG9wdGlvblxuICBmb3IgKCB2YXIgZXZlbnROYW1lIGluIHRoaXMub3B0aW9ucy5vbiApIHtcbiAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLm9wdGlvbnMub25bIGV2ZW50TmFtZSBdO1xuICAgIHRoaXMub24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgfVxuXG4gIEZsaWNraXR5LmNyZWF0ZU1ldGhvZHMuZm9yRWFjaCggZnVuY3Rpb24oIG1ldGhvZCApIHtcbiAgICB0aGlzWyBtZXRob2QgXSgpO1xuICB9LCB0aGlzICk7XG5cbiAgaWYgKCB0aGlzLm9wdGlvbnMud2F0Y2hDU1MgKSB7XG4gICAgdGhpcy53YXRjaENTUygpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIHNldCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5wcm90by5vcHRpb24gPSBmdW5jdGlvbiggb3B0cyApIHtcbiAgdXRpbHMuZXh0ZW5kKCB0aGlzLm9wdGlvbnMsIG9wdHMgKTtcbn07XG5cbnByb3RvLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5pc0FjdGl2ZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmbGlja2l0eS1lbmFibGVkJyk7XG4gIGlmICggdGhpcy5vcHRpb25zLnJpZ2h0VG9MZWZ0ICkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmbGlja2l0eS1ydGwnKTtcbiAgfVxuXG4gIHRoaXMuZ2V0U2l6ZSgpO1xuICAvLyBtb3ZlIGluaXRpYWwgY2VsbCBlbGVtZW50cyBzbyB0aGV5IGNhbiBiZSBsb2FkZWQgYXMgY2VsbHNcbiAgdmFyIGNlbGxFbGVtcyA9IHRoaXMuX2ZpbHRlckZpbmRDZWxsRWxlbWVudHMoIHRoaXMuZWxlbWVudC5jaGlsZHJlbiApO1xuICBtb3ZlRWxlbWVudHMoIGNlbGxFbGVtcywgdGhpcy5zbGlkZXIgKTtcbiAgdGhpcy52aWV3cG9ydC5hcHBlbmRDaGlsZCggdGhpcy5zbGlkZXIgKTtcbiAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLnZpZXdwb3J0ICk7XG4gIC8vIGdldCBjZWxscyBmcm9tIGNoaWxkcmVuXG4gIHRoaXMucmVsb2FkQ2VsbHMoKTtcblxuICBpZiAoIHRoaXMub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ICkge1xuICAgIC8vIGFsbG93IGVsZW1lbnQgdG8gZm9jdXNhYmxlXG4gICAgdGhpcy5lbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICAvLyBsaXN0ZW4gZm9yIGtleSBwcmVzc2VzXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgdGhpcyApO1xuICB9XG5cbiAgdGhpcy5lbWl0RXZlbnQoJ2FjdGl2YXRlJyk7XG4gIHRoaXMuc2VsZWN0SW5pdGlhbEluZGV4KCk7XG4gIC8vIGZsYWcgZm9yIGluaXRpYWwgYWN0aXZhdGlvbiwgZm9yIHVzaW5nIGluaXRpYWxJbmRleFxuICB0aGlzLmlzSW5pdEFjdGl2YXRlZCA9IHRydWU7XG4gIC8vIHJlYWR5IGV2ZW50LiAjNDkzXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVhZHknKTtcbn07XG5cbi8vIHNsaWRlciBwb3NpdGlvbnMgdGhlIGNlbGxzXG5wcm90by5fY3JlYXRlU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNsaWRlciBlbGVtZW50IGRvZXMgYWxsIHRoZSBwb3NpdGlvbmluZ1xuICB2YXIgc2xpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNsaWRlci5jbGFzc05hbWUgPSAnZmxpY2tpdHktc2xpZGVyJztcbiAgc2xpZGVyLnN0eWxlWyB0aGlzLm9yaWdpblNpZGUgXSA9IDA7XG4gIHRoaXMuc2xpZGVyID0gc2xpZGVyO1xufTtcblxucHJvdG8uX2ZpbHRlckZpbmRDZWxsRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHJldHVybiB1dGlscy5maWx0ZXJGaW5kRWxlbWVudHMoIGVsZW1zLCB0aGlzLm9wdGlvbnMuY2VsbFNlbGVjdG9yICk7XG59O1xuXG4vLyBnb2VzIHRocm91Z2ggYWxsIGNoaWxkcmVuXG5wcm90by5yZWxvYWRDZWxscyA9IGZ1bmN0aW9uKCkge1xuICAvLyBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAgdGhpcy5jZWxscyA9IHRoaXMuX21ha2VDZWxscyggdGhpcy5zbGlkZXIuY2hpbGRyZW4gKTtcbiAgdGhpcy5wb3NpdGlvbkNlbGxzKCk7XG4gIHRoaXMuX2dldFdyYXBTaGlmdENlbGxzKCk7XG4gIHRoaXMuc2V0R2FsbGVyeVNpemUoKTtcbn07XG5cbi8qKlxuICogdHVybiBlbGVtZW50cyBpbnRvIEZsaWNraXR5LkNlbGxzXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIGNvbGxlY3Rpb24gb2YgbmV3IEZsaWNraXR5IENlbGxzXG4gKi9cbnByb3RvLl9tYWtlQ2VsbHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBjZWxsRWxlbXMgPSB0aGlzLl9maWx0ZXJGaW5kQ2VsbEVsZW1lbnRzKCBlbGVtcyApO1xuXG4gIC8vIGNyZWF0ZSBuZXcgRmxpY2tpdHkgZm9yIGNvbGxlY3Rpb25cbiAgdmFyIGNlbGxzID0gY2VsbEVsZW1zLm1hcCggZnVuY3Rpb24oIGNlbGxFbGVtICkge1xuICAgIHJldHVybiBuZXcgQ2VsbCggY2VsbEVsZW0sIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuXG4gIHJldHVybiBjZWxscztcbn07XG5cbnByb3RvLmdldExhc3RDZWxsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNlbGxzWyB0aGlzLmNlbGxzLmxlbmd0aCAtIDEgXTtcbn07XG5cbnByb3RvLmdldExhc3RTbGlkZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zbGlkZXNbIHRoaXMuc2xpZGVzLmxlbmd0aCAtIDEgXTtcbn07XG5cbi8vIHBvc2l0aW9ucyBhbGwgY2VsbHNcbnByb3RvLnBvc2l0aW9uQ2VsbHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2l6ZSBhbGwgY2VsbHNcbiAgdGhpcy5fc2l6ZUNlbGxzKCB0aGlzLmNlbGxzICk7XG4gIC8vIHBvc2l0aW9uIGFsbCBjZWxsc1xuICB0aGlzLl9wb3NpdGlvbkNlbGxzKCAwICk7XG59O1xuXG4vKipcbiAqIHBvc2l0aW9uIGNlcnRhaW4gY2VsbHNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggLSB3aGljaCBjZWxsIHRvIHN0YXJ0IHdpdGhcbiAqL1xucHJvdG8uX3Bvc2l0aW9uQ2VsbHMgPSBmdW5jdGlvbiggaW5kZXggKSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgLy8gYWxzbyBtZWFzdXJlIG1heENlbGxIZWlnaHRcbiAgLy8gc3RhcnQgMCBpZiBwb3NpdGlvbmluZyBhbGwgY2VsbHNcbiAgdGhpcy5tYXhDZWxsSGVpZ2h0ID0gaW5kZXggPyB0aGlzLm1heENlbGxIZWlnaHQgfHwgMCA6IDA7XG4gIHZhciBjZWxsWCA9IDA7XG4gIC8vIGdldCBjZWxsWFxuICBpZiAoIGluZGV4ID4gMCApIHtcbiAgICB2YXIgc3RhcnRDZWxsID0gdGhpcy5jZWxsc1sgaW5kZXggLSAxIF07XG4gICAgY2VsbFggPSBzdGFydENlbGwueCArIHN0YXJ0Q2VsbC5zaXplLm91dGVyV2lkdGg7XG4gIH1cbiAgdmFyIGxlbiA9IHRoaXMuY2VsbHMubGVuZ3RoO1xuICBmb3IgKCB2YXIgaT1pbmRleDsgaSA8IGxlbjsgaSsrICkge1xuICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1tpXTtcbiAgICBjZWxsLnNldFBvc2l0aW9uKCBjZWxsWCApO1xuICAgIGNlbGxYICs9IGNlbGwuc2l6ZS5vdXRlcldpZHRoO1xuICAgIHRoaXMubWF4Q2VsbEhlaWdodCA9IE1hdGgubWF4KCBjZWxsLnNpemUub3V0ZXJIZWlnaHQsIHRoaXMubWF4Q2VsbEhlaWdodCApO1xuICB9XG4gIC8vIGtlZXAgdHJhY2sgb2YgY2VsbFggZm9yIHdyYXAtYXJvdW5kXG4gIHRoaXMuc2xpZGVhYmxlV2lkdGggPSBjZWxsWDtcbiAgLy8gc2xpZGVzXG4gIHRoaXMudXBkYXRlU2xpZGVzKCk7XG4gIC8vIGNvbnRhaW4gc2xpZGVzIHRhcmdldFxuICB0aGlzLl9jb250YWluU2xpZGVzKCk7XG4gIC8vIHVwZGF0ZSBzbGlkZXNXaWR0aFxuICB0aGlzLnNsaWRlc1dpZHRoID0gbGVuID8gdGhpcy5nZXRMYXN0U2xpZGUoKS50YXJnZXQgLSB0aGlzLnNsaWRlc1swXS50YXJnZXQgOiAwO1xufTtcblxuLyoqXG4gKiBjZWxsLmdldFNpemUoKSBvbiBtdWx0aXBsZSBjZWxsc1xuICogQHBhcmFtIHtBcnJheX0gY2VsbHNcbiAqL1xucHJvdG8uX3NpemVDZWxscyA9IGZ1bmN0aW9uKCBjZWxscyApIHtcbiAgY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgY2VsbC5nZXRTaXplKCk7XG4gIH0pO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLnVwZGF0ZVNsaWRlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNsaWRlcyA9IFtdO1xuICBpZiAoICF0aGlzLmNlbGxzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2xpZGUgPSBuZXcgU2xpZGUoIHRoaXMgKTtcbiAgdGhpcy5zbGlkZXMucHVzaCggc2xpZGUgKTtcbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMub3JpZ2luU2lkZSA9PSAnbGVmdCc7XG4gIHZhciBuZXh0TWFyZ2luID0gaXNPcmlnaW5MZWZ0ID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5MZWZ0JztcblxuICB2YXIgY2FuQ2VsbEZpdCA9IHRoaXMuX2dldENhbkNlbGxGaXQoKTtcblxuICB0aGlzLmNlbGxzLmZvckVhY2goIGZ1bmN0aW9uKCBjZWxsLCBpICkge1xuICAgIC8vIGp1c3QgYWRkIGNlbGwgaWYgZmlyc3QgY2VsbCBpbiBzbGlkZVxuICAgIGlmICggIXNsaWRlLmNlbGxzLmxlbmd0aCApIHtcbiAgICAgIHNsaWRlLmFkZENlbGwoIGNlbGwgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2xpZGVXaWR0aCA9ICggc2xpZGUub3V0ZXJXaWR0aCAtIHNsaWRlLmZpcnN0TWFyZ2luICkgK1xuICAgICAgKCBjZWxsLnNpemUub3V0ZXJXaWR0aCAtIGNlbGwuc2l6ZVsgbmV4dE1hcmdpbiBdICk7XG5cbiAgICBpZiAoIGNhbkNlbGxGaXQuY2FsbCggdGhpcywgaSwgc2xpZGVXaWR0aCApICkge1xuICAgICAgc2xpZGUuYWRkQ2VsbCggY2VsbCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2Vzbid0IGZpdCwgbmV3IHNsaWRlXG4gICAgICBzbGlkZS51cGRhdGVUYXJnZXQoKTtcblxuICAgICAgc2xpZGUgPSBuZXcgU2xpZGUoIHRoaXMgKTtcbiAgICAgIHRoaXMuc2xpZGVzLnB1c2goIHNsaWRlICk7XG4gICAgICBzbGlkZS5hZGRDZWxsKCBjZWxsICk7XG4gICAgfVxuICB9LCB0aGlzICk7XG4gIC8vIGxhc3Qgc2xpZGVcbiAgc2xpZGUudXBkYXRlVGFyZ2V0KCk7XG4gIC8vIHVwZGF0ZSAuc2VsZWN0ZWRTbGlkZVxuICB0aGlzLnVwZGF0ZVNlbGVjdGVkU2xpZGUoKTtcbn07XG5cbnByb3RvLl9nZXRDYW5DZWxsRml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBncm91cENlbGxzID0gdGhpcy5vcHRpb25zLmdyb3VwQ2VsbHM7XG4gIGlmICggIWdyb3VwQ2VsbHMgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBncm91cENlbGxzID09ICdudW1iZXInICkge1xuICAgIC8vIGdyb3VwIGJ5IG51bWJlci4gMyAtPiBbMCwxLDJdLCBbMyw0LDVdLCAuLi5cbiAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQoIGdyb3VwQ2VsbHMsIDEwICk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBpICkge1xuICAgICAgcmV0dXJuICggaSAlIG51bWJlciApICE9PSAwO1xuICAgIH07XG4gIH1cbiAgLy8gZGVmYXVsdCwgZ3JvdXAgYnkgd2lkdGggb2Ygc2xpZGVcbiAgLy8gcGFyc2UgJzc1JVxuICB2YXIgcGVyY2VudE1hdGNoID0gdHlwZW9mIGdyb3VwQ2VsbHMgPT0gJ3N0cmluZycgJiZcbiAgICBncm91cENlbGxzLm1hdGNoKC9eKFxcZCspJSQvKTtcbiAgdmFyIHBlcmNlbnQgPSBwZXJjZW50TWF0Y2ggPyBwYXJzZUludCggcGVyY2VudE1hdGNoWzFdLCAxMCApIC8gMTAwIDogMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBpLCBzbGlkZVdpZHRoICkge1xuICAgIHJldHVybiBzbGlkZVdpZHRoIDw9ICggdGhpcy5zaXplLmlubmVyV2lkdGggKyAxICkgKiBwZXJjZW50O1xuICB9O1xufTtcblxuLy8gYWxpYXMgX2luaXQgZm9yIGpRdWVyeSBwbHVnaW4gLmZsaWNraXR5KClcbnByb3RvLl9pbml0ID1cbnByb3RvLnJlcG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wb3NpdGlvbkNlbGxzKCk7XG4gIHRoaXMucG9zaXRpb25TbGlkZXJBdFNlbGVjdGVkKCk7XG59O1xuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xuICB0aGlzLnNldENlbGxBbGlnbigpO1xuICB0aGlzLmN1cnNvclBvc2l0aW9uID0gdGhpcy5zaXplLmlubmVyV2lkdGggKiB0aGlzLmNlbGxBbGlnbjtcbn07XG5cbnZhciBjZWxsQWxpZ25TaG9ydGhhbmRzID0ge1xuICAvLyBjZWxsIGFsaWduLCB0aGVuIGJhc2VkIG9uIG9yaWdpbiBzaWRlXG4gIGNlbnRlcjoge1xuICAgIGxlZnQ6IDAuNSxcbiAgICByaWdodDogMC41XG4gIH0sXG4gIGxlZnQ6IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAxXG4gIH0sXG4gIHJpZ2h0OiB7XG4gICAgcmlnaHQ6IDAsXG4gICAgbGVmdDogMVxuICB9XG59O1xuXG5wcm90by5zZXRDZWxsQWxpZ24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNob3J0aGFuZCA9IGNlbGxBbGlnblNob3J0aGFuZHNbIHRoaXMub3B0aW9ucy5jZWxsQWxpZ24gXTtcbiAgdGhpcy5jZWxsQWxpZ24gPSBzaG9ydGhhbmQgPyBzaG9ydGhhbmRbIHRoaXMub3JpZ2luU2lkZSBdIDogdGhpcy5vcHRpb25zLmNlbGxBbGlnbjtcbn07XG5cbnByb3RvLnNldEdhbGxlcnlTaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5vcHRpb25zLnNldEdhbGxlcnlTaXplICkge1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgJiYgdGhpcy5zZWxlY3RlZFNsaWRlID9cbiAgICAgIHRoaXMuc2VsZWN0ZWRTbGlkZS5oZWlnaHQgOiB0aGlzLm1heENlbGxIZWlnaHQ7XG4gICAgdGhpcy52aWV3cG9ydC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG59O1xuXG5wcm90by5fZ2V0V3JhcFNoaWZ0Q2VsbHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gb25seSBmb3Igd3JhcC1hcm91bmRcbiAgaWYgKCAhdGhpcy5vcHRpb25zLndyYXBBcm91bmQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHVuc2hpZnQgcHJldmlvdXMgY2VsbHNcbiAgdGhpcy5fdW5zaGlmdENlbGxzKCB0aGlzLmJlZm9yZVNoaWZ0Q2VsbHMgKTtcbiAgdGhpcy5fdW5zaGlmdENlbGxzKCB0aGlzLmFmdGVyU2hpZnRDZWxscyApO1xuICAvLyBnZXQgYmVmb3JlIGNlbGxzXG4gIC8vIGluaXRpYWwgZ2FwXG4gIHZhciBnYXBYID0gdGhpcy5jdXJzb3JQb3NpdGlvbjtcbiAgdmFyIGNlbGxJbmRleCA9IHRoaXMuY2VsbHMubGVuZ3RoIC0gMTtcbiAgdGhpcy5iZWZvcmVTaGlmdENlbGxzID0gdGhpcy5fZ2V0R2FwQ2VsbHMoIGdhcFgsIGNlbGxJbmRleCwgLTEgKTtcbiAgLy8gZ2V0IGFmdGVyIGNlbGxzXG4gIC8vIGVuZGluZyBnYXAgYmV0d2VlbiBsYXN0IGNlbGwgYW5kIGVuZCBvZiBnYWxsZXJ5IHZpZXdwb3J0XG4gIGdhcFggPSB0aGlzLnNpemUuaW5uZXJXaWR0aCAtIHRoaXMuY3Vyc29yUG9zaXRpb247XG4gIC8vIHN0YXJ0IGNsb25pbmcgYXQgZmlyc3QgY2VsbCwgd29ya2luZyBmb3J3YXJkc1xuICB0aGlzLmFmdGVyU2hpZnRDZWxscyA9IHRoaXMuX2dldEdhcENlbGxzKCBnYXBYLCAwLCAxICk7XG59O1xuXG5wcm90by5fZ2V0R2FwQ2VsbHMgPSBmdW5jdGlvbiggZ2FwWCwgY2VsbEluZGV4LCBpbmNyZW1lbnQgKSB7XG4gIC8vIGtlZXAgYWRkaW5nIGNlbGxzIHVudGlsIHRoZSBjb3ZlciB0aGUgaW5pdGlhbCBnYXBcbiAgdmFyIGNlbGxzID0gW107XG4gIHdoaWxlICggZ2FwWCA+IDAgKSB7XG4gICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWyBjZWxsSW5kZXggXTtcbiAgICBpZiAoICFjZWxsICkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNlbGxzLnB1c2goIGNlbGwgKTtcbiAgICBjZWxsSW5kZXggKz0gaW5jcmVtZW50O1xuICAgIGdhcFggLT0gY2VsbC5zaXplLm91dGVyV2lkdGg7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufTtcblxuLy8gLS0tLS0gY29udGFpbiAtLS0tLSAvL1xuXG4vLyBjb250YWluIGNlbGwgdGFyZ2V0cyBzbyBubyBleGNlc3Mgc2xpZGluZ1xucHJvdG8uX2NvbnRhaW5TbGlkZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5vcHRpb25zLmNvbnRhaW4gfHwgdGhpcy5vcHRpb25zLndyYXBBcm91bmQgfHwgIXRoaXMuY2VsbHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaXNSaWdodFRvTGVmdCA9IHRoaXMub3B0aW9ucy5yaWdodFRvTGVmdDtcbiAgdmFyIGJlZ2luTWFyZ2luID0gaXNSaWdodFRvTGVmdCA/ICdtYXJnaW5SaWdodCcgOiAnbWFyZ2luTGVmdCc7XG4gIHZhciBlbmRNYXJnaW4gPSBpc1JpZ2h0VG9MZWZ0ID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0JztcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IHRoaXMuc2xpZGVhYmxlV2lkdGggLSB0aGlzLmdldExhc3RDZWxsKCkuc2l6ZVsgZW5kTWFyZ2luIF07XG4gIC8vIGNvbnRlbnQgaXMgbGVzcyB0aGFuIGdhbGxlcnkgc2l6ZVxuICB2YXIgaXNDb250ZW50U21hbGxlciA9IGNvbnRlbnRXaWR0aCA8IHRoaXMuc2l6ZS5pbm5lcldpZHRoO1xuICAvLyBib3VuZHNcbiAgdmFyIGJlZ2luQm91bmQgPSB0aGlzLmN1cnNvclBvc2l0aW9uICsgdGhpcy5jZWxsc1swXS5zaXplWyBiZWdpbk1hcmdpbiBdO1xuICB2YXIgZW5kQm91bmQgPSBjb250ZW50V2lkdGggLSB0aGlzLnNpemUuaW5uZXJXaWR0aCAqICggMSAtIHRoaXMuY2VsbEFsaWduICk7XG4gIC8vIGNvbnRhaW4gZWFjaCBjZWxsIHRhcmdldFxuICB0aGlzLnNsaWRlcy5mb3JFYWNoKCBmdW5jdGlvbiggc2xpZGUgKSB7XG4gICAgaWYgKCBpc0NvbnRlbnRTbWFsbGVyICkge1xuICAgICAgLy8gYWxsIGNlbGxzIGZpdCBpbnNpZGUgZ2FsbGVyeVxuICAgICAgc2xpZGUudGFyZ2V0ID0gY29udGVudFdpZHRoICogdGhpcy5jZWxsQWxpZ247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnRhaW4gdG8gYm91bmRzXG4gICAgICBzbGlkZS50YXJnZXQgPSBNYXRoLm1heCggc2xpZGUudGFyZ2V0LCBiZWdpbkJvdW5kICk7XG4gICAgICBzbGlkZS50YXJnZXQgPSBNYXRoLm1pbiggc2xpZGUudGFyZ2V0LCBlbmRCb3VuZCApO1xuICAgIH1cbiAgfSwgdGhpcyApO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbi8qKlxuICogZW1pdHMgZXZlbnRzIHZpYSBldmVudEVtaXR0ZXIgYW5kIGpRdWVyeSBldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gbmFtZSBvZiBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBvcmlnaW5hbCBldmVudFxuICogQHBhcmFtIHtBcnJheX0gYXJncyAtIGV4dHJhIGFyZ3VtZW50c1xuICovXG5wcm90by5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xuICB2YXIgZW1pdEFyZ3MgPSBldmVudCA/IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKSA6IGFyZ3M7XG4gIHRoaXMuZW1pdEV2ZW50KCB0eXBlLCBlbWl0QXJncyApO1xuXG4gIGlmICggalF1ZXJ5ICYmIHRoaXMuJGVsZW1lbnQgKSB7XG4gICAgLy8gZGVmYXVsdCB0cmlnZ2VyIHdpdGggdHlwZSBpZiBubyBldmVudFxuICAgIHR5cGUgKz0gdGhpcy5vcHRpb25zLm5hbWVzcGFjZUpRdWVyeUV2ZW50cyA/ICcuZmxpY2tpdHknIDogJyc7XG4gICAgdmFyICRldmVudCA9IHR5cGU7XG4gICAgaWYgKCBldmVudCApIHtcbiAgICAgIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcbiAgICAgIHZhciBqUUV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xuICAgICAgalFFdmVudC50eXBlID0gdHlwZTtcbiAgICAgICRldmVudCA9IGpRRXZlbnQ7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggJGV2ZW50LCBhcmdzICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNlbGVjdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggLSBpbmRleCBvZiB0aGUgc2xpZGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNXcmFwIC0gd2lsbCB3cmFwLWFyb3VuZCB0byBsYXN0L2ZpcnN0IGlmIGF0IHRoZSBlbmRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnN0YW50IC0gd2lsbCBpbW1lZGlhdGVseSBzZXQgcG9zaXRpb24gYXQgc2VsZWN0ZWQgY2VsbFxuICovXG5wcm90by5zZWxlY3QgPSBmdW5jdGlvbiggaW5kZXgsIGlzV3JhcCwgaXNJbnN0YW50ICkge1xuICBpZiAoICF0aGlzLmlzQWN0aXZlICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpbmRleCA9IHBhcnNlSW50KCBpbmRleCwgMTAgKTtcbiAgdGhpcy5fd3JhcFNlbGVjdCggaW5kZXggKTtcblxuICBpZiAoIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kIHx8IGlzV3JhcCApIHtcbiAgICBpbmRleCA9IHV0aWxzLm1vZHVsbyggaW5kZXgsIHRoaXMuc2xpZGVzLmxlbmd0aCApO1xuICB9XG4gIC8vIGJhaWwgaWYgaW52YWxpZCBpbmRleFxuICBpZiAoICF0aGlzLnNsaWRlc1sgaW5kZXggXSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByZXZJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gIHRoaXMudXBkYXRlU2VsZWN0ZWRTbGlkZSgpO1xuICBpZiAoIGlzSW5zdGFudCApIHtcbiAgICB0aGlzLnBvc2l0aW9uU2xpZGVyQXRTZWxlY3RlZCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcbiAgfVxuICBpZiAoIHRoaXMub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCApIHtcbiAgICB0aGlzLnNldEdhbGxlcnlTaXplKCk7XG4gIH1cbiAgLy8gZXZlbnRzXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3NlbGVjdCcsIG51bGwsIFsgaW5kZXggXSApO1xuICAvLyBjaGFuZ2UgZXZlbnQgaWYgbmV3IGluZGV4XG4gIGlmICggaW5kZXggIT0gcHJldkluZGV4ICkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2NoYW5nZScsIG51bGwsIFsgaW5kZXggXSApO1xuICB9XG4gIC8vIG9sZCB2MSBldmVudCBuYW1lLCByZW1vdmUgaW4gdjNcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjZWxsU2VsZWN0Jyk7XG59O1xuXG4vLyB3cmFwcyBwb3NpdGlvbiBmb3Igd3JhcEFyb3VuZCwgdG8gbW92ZSB0byBjbG9zZXN0IHNsaWRlLiAjMTEzXG5wcm90by5fd3JhcFNlbGVjdCA9IGZ1bmN0aW9uKCBpbmRleCApIHtcbiAgdmFyIGxlbiA9IHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgdmFyIGlzV3JhcHBpbmcgPSB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCAmJiBsZW4gPiAxO1xuICBpZiAoICFpc1dyYXBwaW5nICkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICB2YXIgd3JhcEluZGV4ID0gdXRpbHMubW9kdWxvKCBpbmRleCwgbGVuICk7XG4gIC8vIGdvIHRvIHNob3J0ZXN0XG4gIHZhciBkZWx0YSA9IE1hdGguYWJzKCB3cmFwSW5kZXggLSB0aGlzLnNlbGVjdGVkSW5kZXggKTtcbiAgdmFyIGJhY2tXcmFwRGVsdGEgPSBNYXRoLmFicyggKCB3cmFwSW5kZXggKyBsZW4gKSAtIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuICB2YXIgZm9yZXdhcmRXcmFwRGVsdGEgPSBNYXRoLmFicyggKCB3cmFwSW5kZXggLSBsZW4gKSAtIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuICBpZiAoICF0aGlzLmlzRHJhZ1NlbGVjdCAmJiBiYWNrV3JhcERlbHRhIDwgZGVsdGEgKSB7XG4gICAgaW5kZXggKz0gbGVuO1xuICB9IGVsc2UgaWYgKCAhdGhpcy5pc0RyYWdTZWxlY3QgJiYgZm9yZXdhcmRXcmFwRGVsdGEgPCBkZWx0YSApIHtcbiAgICBpbmRleCAtPSBsZW47XG4gIH1cbiAgLy8gd3JhcCBwb3NpdGlvbiBzbyBzbGlkZXIgaXMgd2l0aGluIG5vcm1hbCBhcmVhXG4gIGlmICggaW5kZXggPCAwICkge1xuICAgIHRoaXMueCAtPSB0aGlzLnNsaWRlYWJsZVdpZHRoO1xuICB9IGVsc2UgaWYgKCBpbmRleCA+PSBsZW4gKSB7XG4gICAgdGhpcy54ICs9IHRoaXMuc2xpZGVhYmxlV2lkdGg7XG4gIH1cbn07XG5cbnByb3RvLnByZXZpb3VzID0gZnVuY3Rpb24oIGlzV3JhcCwgaXNJbnN0YW50ICkge1xuICB0aGlzLnNlbGVjdCggdGhpcy5zZWxlY3RlZEluZGV4IC0gMSwgaXNXcmFwLCBpc0luc3RhbnQgKTtcbn07XG5cbnByb3RvLm5leHQgPSBmdW5jdGlvbiggaXNXcmFwLCBpc0luc3RhbnQgKSB7XG4gIHRoaXMuc2VsZWN0KCB0aGlzLnNlbGVjdGVkSW5kZXggKyAxLCBpc1dyYXAsIGlzSW5zdGFudCApO1xufTtcblxucHJvdG8udXBkYXRlU2VsZWN0ZWRTbGlkZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1sgdGhpcy5zZWxlY3RlZEluZGV4IF07XG4gIC8vIHNlbGVjdGVkSW5kZXggY291bGQgYmUgb3V0c2lkZSBvZiBzbGlkZXMsIGlmIHRyaWdnZXJlZCBiZWZvcmUgcmVzaXplKClcbiAgaWYgKCAhc2xpZGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGVkIHNsaWRlXG4gIHRoaXMudW5zZWxlY3RTZWxlY3RlZFNsaWRlKCk7XG4gIC8vIHVwZGF0ZSBuZXcgc2VsZWN0ZWQgc2xpZGVcbiAgdGhpcy5zZWxlY3RlZFNsaWRlID0gc2xpZGU7XG4gIHNsaWRlLnNlbGVjdCgpO1xuICB0aGlzLnNlbGVjdGVkQ2VsbHMgPSBzbGlkZS5jZWxscztcbiAgdGhpcy5zZWxlY3RlZEVsZW1lbnRzID0gc2xpZGUuZ2V0Q2VsbEVsZW1lbnRzKCk7XG4gIC8vIEhBQ0s6IHNlbGVjdGVkQ2VsbCAmIHNlbGVjdGVkRWxlbWVudCBpcyBmaXJzdCBjZWxsIGluIHNsaWRlLCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAvLyBSZW1vdmUgaW4gdjM/XG4gIHRoaXMuc2VsZWN0ZWRDZWxsID0gc2xpZGUuY2VsbHNbMF07XG4gIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gdGhpcy5zZWxlY3RlZEVsZW1lbnRzWzBdO1xufTtcblxucHJvdG8udW5zZWxlY3RTZWxlY3RlZFNsaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5zZWxlY3RlZFNsaWRlICkge1xuICAgIHRoaXMuc2VsZWN0ZWRTbGlkZS51bnNlbGVjdCgpO1xuICB9XG59O1xuXG5wcm90by5zZWxlY3RJbml0aWFsSW5kZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluaXRpYWxJbmRleCA9IHRoaXMub3B0aW9ucy5pbml0aWFsSW5kZXg7XG4gIC8vIGFscmVhZHkgYWN0aXZhdGVkLCBzZWxlY3QgcHJldmlvdXMgc2VsZWN0ZWRJbmRleFxuICBpZiAoIHRoaXMuaXNJbml0QWN0aXZhdGVkICkge1xuICAgIHRoaXMuc2VsZWN0KCB0aGlzLnNlbGVjdGVkSW5kZXgsIGZhbHNlLCB0cnVlICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNlbGVjdCB3aXRoIHNlbGVjdG9yIHN0cmluZ1xuICBpZiAoIGluaXRpYWxJbmRleCAmJiB0eXBlb2YgaW5pdGlhbEluZGV4ID09ICdzdHJpbmcnICkge1xuICAgIHZhciBjZWxsID0gdGhpcy5xdWVyeUNlbGwoIGluaXRpYWxJbmRleCApO1xuICAgIGlmICggY2VsbCApIHtcbiAgICAgIHRoaXMuc2VsZWN0Q2VsbCggaW5pdGlhbEluZGV4LCBmYWxzZSwgdHJ1ZSApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbmRleCA9IDA7XG4gIC8vIHNlbGVjdCB3aXRoIG51bWJlclxuICBpZiAoIGluaXRpYWxJbmRleCAmJiB0aGlzLnNsaWRlc1sgaW5pdGlhbEluZGV4IF0gKSB7XG4gICAgaW5kZXggPSBpbml0aWFsSW5kZXg7XG4gIH1cbiAgLy8gc2VsZWN0IGluc3RhbnRseVxuICB0aGlzLnNlbGVjdCggaW5kZXgsIGZhbHNlLCB0cnVlICk7XG59O1xuXG4vKipcbiAqIHNlbGVjdCBzbGlkZSBmcm9tIG51bWJlciBvciBjZWxsIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudCBvciBOdW1iZXJ9IGVsZW1cbiAqL1xucHJvdG8uc2VsZWN0Q2VsbCA9IGZ1bmN0aW9uKCB2YWx1ZSwgaXNXcmFwLCBpc0luc3RhbnQgKSB7XG4gIC8vIGdldCBjZWxsXG4gIHZhciBjZWxsID0gdGhpcy5xdWVyeUNlbGwoIHZhbHVlICk7XG4gIGlmICggIWNlbGwgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gdGhpcy5nZXRDZWxsU2xpZGVJbmRleCggY2VsbCApO1xuICB0aGlzLnNlbGVjdCggaW5kZXgsIGlzV3JhcCwgaXNJbnN0YW50ICk7XG59O1xuXG5wcm90by5nZXRDZWxsU2xpZGVJbmRleCA9IGZ1bmN0aW9uKCBjZWxsICkge1xuICAvLyBnZXQgaW5kZXggb2Ygc2xpZGVzIHRoYXQgaGFzIGNlbGxcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuc2xpZGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzW2ldO1xuICAgIHZhciBpbmRleCA9IHNsaWRlLmNlbGxzLmluZGV4T2YoIGNlbGwgKTtcbiAgICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXQgY2VsbHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXQgRmxpY2tpdHkuQ2VsbCwgZ2l2ZW4gYW4gRWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7RmxpY2tpdHkuQ2VsbH0gaXRlbVxuICovXG5wcm90by5nZXRDZWxsID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGxvb3AgdGhyb3VnaCBjZWxscyB0byBnZXQgdGhlIG9uZSB0aGF0IG1hdGNoZXNcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2ldO1xuICAgIGlmICggY2VsbC5lbGVtZW50ID09IGVsZW0gKSB7XG4gICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IGNvbGxlY3Rpb24gb2YgRmxpY2tpdHkuQ2VsbHMsIGdpdmVuIEVsZW1lbnRzXG4gKiBAcGFyYW0ge0VsZW1lbnQsIEFycmF5LCBOb2RlTGlzdH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gY2VsbHMgLSBGbGlja2l0eS5DZWxsc1xuICovXG5wcm90by5nZXRDZWxscyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBjZWxscyA9IFtdO1xuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCggZWxlbSApO1xuICAgIGlmICggY2VsbCApIHtcbiAgICAgIGNlbGxzLnB1c2goIGNlbGwgKTtcbiAgICB9XG4gIH0sIHRoaXMgKTtcbiAgcmV0dXJuIGNlbGxzO1xufTtcblxuLyoqXG4gKiBnZXQgY2VsbCBlbGVtZW50c1xuICogQHJldHVybnMge0FycmF5fSBjZWxsRWxlbXNcbiAqL1xucHJvdG8uZ2V0Q2VsbEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNlbGxzLm1hcCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgcmV0dXJuIGNlbGwuZWxlbWVudDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGdldCBwYXJlbnQgY2VsbCBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge0ZsaWNraXQuQ2VsbH0gY2VsbFxuICovXG5wcm90by5nZXRQYXJlbnRDZWxsID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGZpcnN0IGNoZWNrIGlmIGVsZW0gaXMgY2VsbFxuICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCggZWxlbSApO1xuICBpZiAoIGNlbGwgKSB7XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgLy8gdHJ5IHRvIGdldCBwYXJlbnQgY2VsbCBlbGVtXG4gIGVsZW0gPSB1dGlscy5nZXRQYXJlbnQoIGVsZW0sICcuZmxpY2tpdHktc2xpZGVyID4gKicgKTtcbiAgcmV0dXJuIHRoaXMuZ2V0Q2VsbCggZWxlbSApO1xufTtcblxuLyoqXG4gKiBnZXQgY2VsbHMgYWRqYWNlbnQgdG8gYSBzbGlkZVxuICogQHBhcmFtIHtJbnRlZ2VyfSBhZGpDb3VudCAtIG51bWJlciBvZiBhZGphY2VudCBzbGlkZXNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggLSBpbmRleCBvZiBzbGlkZSB0byBzdGFydFxuICogQHJldHVybnMge0FycmF5fSBjZWxscyAtIGFycmF5IG9mIEZsaWNraXR5LkNlbGxzXG4gKi9cbnByb3RvLmdldEFkamFjZW50Q2VsbEVsZW1lbnRzID0gZnVuY3Rpb24oIGFkakNvdW50LCBpbmRleCApIHtcbiAgaWYgKCAhYWRqQ291bnQgKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRTbGlkZS5nZXRDZWxsRWxlbWVudHMoKTtcbiAgfVxuICBpbmRleCA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLnNlbGVjdGVkSW5kZXggOiBpbmRleDtcblxuICB2YXIgbGVuID0gdGhpcy5zbGlkZXMubGVuZ3RoO1xuICBpZiAoIDEgKyAoIGFkakNvdW50ICogMiApID49IGxlbiApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsRWxlbWVudHMoKTtcbiAgfVxuXG4gIHZhciBjZWxsRWxlbXMgPSBbXTtcbiAgZm9yICggdmFyIGkgPSBpbmRleCAtIGFkakNvdW50OyBpIDw9IGluZGV4ICsgYWRqQ291bnQgOyBpKysgKSB7XG4gICAgdmFyIHNsaWRlSW5kZXggPSB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCA/IHV0aWxzLm1vZHVsbyggaSwgbGVuICkgOiBpO1xuICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzWyBzbGlkZUluZGV4IF07XG4gICAgaWYgKCBzbGlkZSApIHtcbiAgICAgIGNlbGxFbGVtcyA9IGNlbGxFbGVtcy5jb25jYXQoIHNsaWRlLmdldENlbGxFbGVtZW50cygpICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjZWxsRWxlbXM7XG59O1xuXG4vKipcbiAqIHNlbGVjdCBzbGlkZSBmcm9tIG51bWJlciBvciBjZWxsIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudCwgU2VsZWN0b3IgU3RyaW5nLCBvciBOdW1iZXJ9IHNlbGVjdG9yXG4gKi9cbnByb3RvLnF1ZXJ5Q2VsbCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT0gJ251bWJlcicgKSB7XG4gICAgLy8gdXNlIG51bWJlciBhcyBpbmRleFxuICAgIHJldHVybiB0aGlzLmNlbGxzWyBzZWxlY3RvciBdO1xuICB9XG4gIGlmICggdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnICkge1xuICAgIC8vIGRvIG5vdCBzZWxlY3QgaW52YWxpZCBzZWxlY3RvcnMgZnJvbSBoYXNoOiAjMTIzLCAjLy4gIzc5MVxuICAgIGlmICggc2VsZWN0b3IubWF0Y2goL15bI1xcLl0/W1xcZFxcL10vKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXNlIHN0cmluZyBhcyBzZWxlY3RvciwgZ2V0IGVsZW1lbnRcbiAgICBzZWxlY3RvciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCBzZWxlY3RvciApO1xuICB9XG4gIC8vIGdldCBjZWxsIGZyb20gZWxlbWVudFxuICByZXR1cm4gdGhpcy5nZXRDZWxsKCBzZWxlY3RvciApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLnVpQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCd1aUNoYW5nZScpO1xufTtcblxuLy8ga2VlcCBmb2N1cyBvbiBlbGVtZW50IHdoZW4gY2hpbGQgVUkgZWxlbWVudHMgYXJlIGNsaWNrZWRcbnByb3RvLmNoaWxkVUlQb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gSEFDSyBpT1MgZG9lcyBub3QgYWxsb3cgdG91Y2ggZXZlbnRzIHRvIGJ1YmJsZSB1cD8hXG4gIGlmICggZXZlbnQudHlwZSAhPSAndG91Y2hzdGFydCcgKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICB0aGlzLmZvY3VzKCk7XG59O1xuXG4vLyAtLS0tLSByZXNpemUgLS0tLS0gLy9cblxucHJvdG8ub25yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53YXRjaENTUygpO1xuICB0aGlzLnJlc2l6ZSgpO1xufTtcblxudXRpbHMuZGVib3VuY2VNZXRob2QoIEZsaWNraXR5LCAnb25yZXNpemUnLCAxNTAgKTtcblxucHJvdG8ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuaXNBY3RpdmUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZ2V0U2l6ZSgpO1xuICAvLyB3cmFwIHZhbHVlc1xuICBpZiAoIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kICkge1xuICAgIHRoaXMueCA9IHV0aWxzLm1vZHVsbyggdGhpcy54LCB0aGlzLnNsaWRlYWJsZVdpZHRoICk7XG4gIH1cbiAgdGhpcy5wb3NpdGlvbkNlbGxzKCk7XG4gIHRoaXMuX2dldFdyYXBTaGlmdENlbGxzKCk7XG4gIHRoaXMuc2V0R2FsbGVyeVNpemUoKTtcbiAgdGhpcy5lbWl0RXZlbnQoJ3Jlc2l6ZScpO1xuICAvLyB1cGRhdGUgc2VsZWN0ZWQgaW5kZXggZm9yIGdyb3VwIHNsaWRlcywgaW5zdGFudFxuICAvLyBUT0RPOiBwb3NpdGlvbiBjYW4gYmUgbG9zdCBiZXR3ZWVuIGdyb3VwcyBvZiB2YXJpb3VzIG51bWJlcnNcbiAgdmFyIHNlbGVjdGVkRWxlbWVudCA9IHRoaXMuc2VsZWN0ZWRFbGVtZW50cyAmJiB0aGlzLnNlbGVjdGVkRWxlbWVudHNbMF07XG4gIHRoaXMuc2VsZWN0Q2VsbCggc2VsZWN0ZWRFbGVtZW50LCBmYWxzZSwgdHJ1ZSApO1xufTtcblxuLy8gd2F0Y2hlcyB0aGUgOmFmdGVyIHByb3BlcnR5LCBhY3RpdmF0ZXMvZGVhY3RpdmF0ZXNcbnByb3RvLndhdGNoQ1NTID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3YXRjaE9wdGlvbiA9IHRoaXMub3B0aW9ucy53YXRjaENTUztcbiAgaWYgKCAhd2F0Y2hPcHRpb24gKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFmdGVyQ29udGVudCA9IGdldENvbXB1dGVkU3R5bGUoIHRoaXMuZWxlbWVudCwgJzphZnRlcicgKS5jb250ZW50O1xuICAvLyBhY3RpdmF0ZSBpZiA6YWZ0ZXIgeyBjb250ZW50OiAnZmxpY2tpdHknIH1cbiAgaWYgKCBhZnRlckNvbnRlbnQuaW5kZXhPZignZmxpY2tpdHknKSAhPSAtMSApIHtcbiAgICB0aGlzLmFjdGl2YXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIGtleWRvd24gLS0tLS0gLy9cblxuLy8gZ28gcHJldmlvdXMvbmV4dCBpZiBsZWZ0L3JpZ2h0IGtleXMgcHJlc3NlZFxucHJvdG8ub25rZXlkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAvLyBvbmx5IHdvcmsgaWYgZWxlbWVudCBpcyBpbiBmb2N1c1xuICB2YXIgaXNOb3RGb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZWxlbWVudDtcbiAgaWYgKCAhdGhpcy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgfHxpc05vdEZvY3VzZWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBGbGlja2l0eS5rZXlib2FyZEhhbmRsZXJzWyBldmVudC5rZXlDb2RlIF07XG4gIGlmICggaGFuZGxlciApIHtcbiAgICBoYW5kbGVyLmNhbGwoIHRoaXMgKTtcbiAgfVxufTtcblxuRmxpY2tpdHkua2V5Ym9hcmRIYW5kbGVycyA9IHtcbiAgLy8gbGVmdCBhcnJvd1xuICAzNzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnRNZXRob2QgPSB0aGlzLm9wdGlvbnMucmlnaHRUb0xlZnQgPyAnbmV4dCcgOiAncHJldmlvdXMnO1xuICAgIHRoaXMudWlDaGFuZ2UoKTtcbiAgICB0aGlzWyBsZWZ0TWV0aG9kIF0oKTtcbiAgfSxcbiAgLy8gcmlnaHQgYXJyb3dcbiAgMzk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByaWdodE1ldGhvZCA9IHRoaXMub3B0aW9ucy5yaWdodFRvTGVmdCA/ICdwcmV2aW91cycgOiAnbmV4dCc7XG4gICAgdGhpcy51aUNoYW5nZSgpO1xuICAgIHRoaXNbIHJpZ2h0TWV0aG9kIF0oKTtcbiAgfSxcbn07XG5cbi8vIC0tLS0tIGZvY3VzIC0tLS0tIC8vXG5cbnByb3RvLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8gcmVtb3ZlIHNjcm9sbFRvIG9uY2UgZm9jdXMgb3B0aW9ucyBnZXRzIG1vcmUgc3VwcG9ydFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvZm9jdXMjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gIHZhciBwcmV2U2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgdGhpcy5lbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgLy8gaGFjayB0byBmaXggc2Nyb2xsIGp1bXAgYWZ0ZXIgZm9jdXMsICM3NlxuICBpZiAoIHdpbmRvdy5wYWdlWU9mZnNldCAhPSBwcmV2U2Nyb2xsWSApIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8oIHdpbmRvdy5wYWdlWE9mZnNldCwgcHJldlNjcm9sbFkgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGVzdHJveSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBkZWFjdGl2YXRlIGFsbCBGbGlja2l0eSBmdW5jdGlvbmFsaXR5LCBidXQga2VlcCBzdHVmZiBhdmFpbGFibGVcbnByb3RvLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5pc0FjdGl2ZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2ZsaWNraXR5LWVuYWJsZWQnKTtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2ZsaWNraXR5LXJ0bCcpO1xuICB0aGlzLnVuc2VsZWN0U2VsZWN0ZWRTbGlkZSgpO1xuICAvLyBkZXN0cm95IGNlbGxzXG4gIHRoaXMuY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgY2VsbC5kZXN0cm95KCk7XG4gIH0pO1xuICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRoaXMudmlld3BvcnQgKTtcbiAgLy8gbW92ZSBjaGlsZCBlbGVtZW50cyBiYWNrIGludG8gZWxlbWVudFxuICBtb3ZlRWxlbWVudHMoIHRoaXMuc2xpZGVyLmNoaWxkcmVuLCB0aGlzLmVsZW1lbnQgKTtcbiAgaWYgKCB0aGlzLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSApIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIHRoaXMgKTtcbiAgfVxuICAvLyBzZXQgZmxhZ3NcbiAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmVtaXRFdmVudCgnZGVhY3RpdmF0ZScpO1xufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIHRoaXMuYWxsT2ZmKCk7XG4gIHRoaXMuZW1pdEV2ZW50KCdkZXN0cm95Jyk7XG4gIGlmICggalF1ZXJ5ICYmIHRoaXMuJGVsZW1lbnQgKSB7XG4gICAgalF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMuZWxlbWVudCwgJ2ZsaWNraXR5JyApO1xuICB9XG4gIGRlbGV0ZSB0aGlzLmVsZW1lbnQuZmxpY2tpdHlHVUlEO1xuICBkZWxldGUgaW5zdGFuY2VzWyB0aGlzLmd1aWQgXTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHByb3RvdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG51dGlscy5leHRlbmQoIHByb3RvLCBhbmltYXRlUHJvdG90eXBlICk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGV4dHJhcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGdldCBGbGlja2l0eSBpbnN0YW5jZSBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge0ZsaWNraXR5fVxuICovXG5GbGlja2l0eS5kYXRhID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIGVsZW0gPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW0gKTtcbiAgdmFyIGlkID0gZWxlbSAmJiBlbGVtLmZsaWNraXR5R1VJRDtcbiAgcmV0dXJuIGlkICYmIGluc3RhbmNlc1sgaWQgXTtcbn07XG5cbnV0aWxzLmh0bWxJbml0KCBGbGlja2l0eSwgJ2ZsaWNraXR5JyApO1xuXG5pZiAoIGpRdWVyeSAmJiBqUXVlcnkuYnJpZGdldCApIHtcbiAgalF1ZXJ5LmJyaWRnZXQoICdmbGlja2l0eScsIEZsaWNraXR5ICk7XG59XG5cbi8vIHNldCBpbnRlcm5hbCBqUXVlcnksIGZvciBXZWJwYWNrICsgalF1ZXJ5IHYzLCAjNDc4XG5GbGlja2l0eS5zZXRKUXVlcnkgPSBmdW5jdGlvbigganEgKSB7XG4gIGpRdWVyeSA9IGpxO1xufTtcblxuRmxpY2tpdHkuQ2VsbCA9IENlbGw7XG5GbGlja2l0eS5TbGlkZSA9IFNsaWRlO1xuXG5yZXR1cm4gRmxpY2tpdHk7XG5cbn0pKTtcbiIsIi8qIVxuICogRmxpY2tpdHkgdjIuMi4xXG4gKiBUb3VjaCwgcmVzcG9uc2l2ZSwgZmxpY2thYmxlIGNhcm91c2Vsc1xuICpcbiAqIExpY2Vuc2VkIEdQTHYzIGZvciBvcGVuIHNvdXJjZSB1c2VcbiAqIG9yIEZsaWNraXR5IENvbW1lcmNpYWwgTGljZW5zZSBmb3IgY29tbWVyY2lhbCB1c2VcbiAqXG4gKiBodHRwczovL2ZsaWNraXR5Lm1ldGFmaXp6eS5jb1xuICogQ29weXJpZ2h0IDIwMTUtMjAxOSBNZXRhZml6enlcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJy4vZmxpY2tpdHknLFxuICAgICAgJy4vZHJhZycsXG4gICAgICAnLi9wcmV2LW5leHQtYnV0dG9uJyxcbiAgICAgICcuL3BhZ2UtZG90cycsXG4gICAgICAnLi9wbGF5ZXInLFxuICAgICAgJy4vYWRkLXJlbW92ZS1jZWxsJyxcbiAgICAgICcuL2xhenlsb2FkJ1xuICAgIF0sIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHJlcXVpcmUoJy4vZmxpY2tpdHknKSxcbiAgICAgIHJlcXVpcmUoJy4vZHJhZycpLFxuICAgICAgcmVxdWlyZSgnLi9wcmV2LW5leHQtYnV0dG9uJyksXG4gICAgICByZXF1aXJlKCcuL3BhZ2UtZG90cycpLFxuICAgICAgcmVxdWlyZSgnLi9wbGF5ZXInKSxcbiAgICAgIHJlcXVpcmUoJy4vYWRkLXJlbW92ZS1jZWxsJyksXG4gICAgICByZXF1aXJlKCcuL2xhenlsb2FkJylcbiAgICApO1xuICB9XG5cbn0pKCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIEZsaWNraXR5ICkge1xuICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlKi9cbiAgcmV0dXJuIEZsaWNraXR5O1xufSk7XG4iLCIvLyBsYXp5bG9hZFxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICcuL2ZsaWNraXR5JyxcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscydcbiAgICBdLCBmdW5jdGlvbiggRmxpY2tpdHksIHV0aWxzICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRmxpY2tpdHksIHV0aWxzICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCcuL2ZsaWNraXR5JyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRmxpY2tpdHksXG4gICAgICB3aW5kb3cuZml6enlVSVV0aWxzXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRmxpY2tpdHksIHV0aWxzICkge1xuJ3VzZSBzdHJpY3QnO1xuXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzLnB1c2goJ19jcmVhdGVMYXp5bG9hZCcpO1xudmFyIHByb3RvID0gRmxpY2tpdHkucHJvdG90eXBlO1xuXG5wcm90by5fY3JlYXRlTGF6eWxvYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vbiggJ3NlbGVjdCcsIHRoaXMubGF6eUxvYWQgKTtcbn07XG5cbnByb3RvLmxhenlMb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYXp5TG9hZCA9IHRoaXMub3B0aW9ucy5sYXp5TG9hZDtcbiAgaWYgKCAhbGF6eUxvYWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldCBhZGphY2VudCBjZWxscywgdXNlIGxhenlMb2FkIG9wdGlvbiBmb3IgYWRqYWNlbnQgY291bnRcbiAgdmFyIGFkakNvdW50ID0gdHlwZW9mIGxhenlMb2FkID09ICdudW1iZXInID8gbGF6eUxvYWQgOiAwO1xuICB2YXIgY2VsbEVsZW1zID0gdGhpcy5nZXRBZGphY2VudENlbGxFbGVtZW50cyggYWRqQ291bnQgKTtcbiAgLy8gZ2V0IGxhenkgaW1hZ2VzIGluIHRob3NlIGNlbGxzXG4gIHZhciBsYXp5SW1hZ2VzID0gW107XG4gIGNlbGxFbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggY2VsbEVsZW0gKSB7XG4gICAgdmFyIGxhenlDZWxsSW1hZ2VzID0gZ2V0Q2VsbExhenlJbWFnZXMoIGNlbGxFbGVtICk7XG4gICAgbGF6eUltYWdlcyA9IGxhenlJbWFnZXMuY29uY2F0KCBsYXp5Q2VsbEltYWdlcyApO1xuICB9KTtcbiAgLy8gbG9hZCBsYXp5IGltYWdlc1xuICBsYXp5SW1hZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBpbWcgKSB7XG4gICAgbmV3IExhenlMb2FkZXIoIGltZywgdGhpcyApO1xuICB9LCB0aGlzICk7XG59O1xuXG5mdW5jdGlvbiBnZXRDZWxsTGF6eUltYWdlcyggY2VsbEVsZW0gKSB7XG4gIC8vIGNoZWNrIGlmIGNlbGwgZWxlbWVudCBpcyBsYXp5IGltYWdlXG4gIGlmICggY2VsbEVsZW0ubm9kZU5hbWUgPT0gJ0lNRycgKSB7XG4gICAgdmFyIGxhenlsb2FkQXR0ciA9IGNlbGxFbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZCcpO1xuICAgIHZhciBzcmNBdHRyID0gY2VsbEVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWZsaWNraXR5LWxhenlsb2FkLXNyYycpO1xuICAgIHZhciBzcmNzZXRBdHRyID0gY2VsbEVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWZsaWNraXR5LWxhenlsb2FkLXNyY3NldCcpO1xuICAgIGlmICggbGF6eWxvYWRBdHRyIHx8IHNyY0F0dHIgfHwgc3Jjc2V0QXR0ciApIHtcbiAgICAgIHJldHVybiBbIGNlbGxFbGVtIF07XG4gICAgfVxuICB9XG4gIC8vIHNlbGVjdCBsYXp5IGltYWdlcyBpbiBjZWxsXG4gIHZhciBsYXp5U2VsZWN0b3IgPSAnaW1nW2RhdGEtZmxpY2tpdHktbGF6eWxvYWRdLCAnICtcbiAgICAnaW1nW2RhdGEtZmxpY2tpdHktbGF6eWxvYWQtc3JjXSwgaW1nW2RhdGEtZmxpY2tpdHktbGF6eWxvYWQtc3Jjc2V0XSc7XG4gIHZhciBpbWdzID0gY2VsbEVsZW0ucXVlcnlTZWxlY3RvckFsbCggbGF6eVNlbGVjdG9yICk7XG4gIHJldHVybiB1dGlscy5tYWtlQXJyYXkoIGltZ3MgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTGF6eUxvYWRlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGNsYXNzIHRvIGhhbmRsZSBsb2FkaW5nIGltYWdlc1xuICovXG5mdW5jdGlvbiBMYXp5TG9hZGVyKCBpbWcsIGZsaWNraXR5ICkge1xuICB0aGlzLmltZyA9IGltZztcbiAgdGhpcy5mbGlja2l0eSA9IGZsaWNraXR5O1xuICB0aGlzLmxvYWQoKTtcbn1cblxuTGF6eUxvYWRlci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSB1dGlscy5oYW5kbGVFdmVudDtcblxuTGF6eUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICAvLyBnZXQgc3JjICYgc3Jjc2V0XG4gIHZhciBzcmMgPSB0aGlzLmltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmxpY2tpdHktbGF6eWxvYWQnKSB8fFxuICAgIHRoaXMuaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZC1zcmMnKTtcbiAgdmFyIHNyY3NldCA9IHRoaXMuaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZC1zcmNzZXQnKTtcbiAgLy8gc2V0IHNyYyAmIHNlcnNldFxuICB0aGlzLmltZy5zcmMgPSBzcmM7XG4gIGlmICggc3Jjc2V0ICkge1xuICAgIHRoaXMuaW1nLnNldEF0dHJpYnV0ZSggJ3NyY3NldCcsIHNyY3NldCApO1xuICB9XG4gIC8vIHJlbW92ZSBhdHRyXG4gIHRoaXMuaW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZCcpO1xuICB0aGlzLmltZy5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZmxpY2tpdHktbGF6eWxvYWQtc3JjJyk7XG4gIHRoaXMuaW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZC1zcmNzZXQnKTtcbn07XG5cbkxhenlMb2FkZXIucHJvdG90eXBlLm9ubG9hZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5jb21wbGV0ZSggZXZlbnQsICdmbGlja2l0eS1sYXp5bG9hZGVkJyApO1xufTtcblxuTGF6eUxvYWRlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5jb21wbGV0ZSggZXZlbnQsICdmbGlja2l0eS1sYXp5ZXJyb3InICk7XG59O1xuXG5MYXp5TG9hZGVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCBldmVudCwgY2xhc3NOYW1lICkge1xuICAvLyB1bmJpbmQgZXZlbnRzXG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG5cbiAgdmFyIGNlbGwgPSB0aGlzLmZsaWNraXR5LmdldFBhcmVudENlbGwoIHRoaXMuaW1nICk7XG4gIHZhciBjZWxsRWxlbSA9IGNlbGwgJiYgY2VsbC5lbGVtZW50O1xuICB0aGlzLmZsaWNraXR5LmNlbGxTaXplQ2hhbmdlKCBjZWxsRWxlbSApO1xuXG4gIHRoaXMuaW1nLmNsYXNzTGlzdC5hZGQoIGNsYXNzTmFtZSApO1xuICB0aGlzLmZsaWNraXR5LmRpc3BhdGNoRXZlbnQoICdsYXp5TG9hZCcsIGV2ZW50LCBjZWxsRWxlbSApO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbkZsaWNraXR5LkxhenlMb2FkZXIgPSBMYXp5TG9hZGVyO1xuXG5yZXR1cm4gRmxpY2tpdHk7XG5cbn0pKTtcbiIsIi8vIHBhZ2UgZG90c1xuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICcuL2ZsaWNraXR5JyxcbiAgICAgICd1bmlwb2ludGVyL3VuaXBvaW50ZXInLFxuICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGlja2l0eSwgVW5pcG9pbnRlciwgdXRpbHMgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgVW5pcG9pbnRlciwgdXRpbHMgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJy4vZmxpY2tpdHknKSxcbiAgICAgIHJlcXVpcmUoJ3VuaXBvaW50ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5GbGlja2l0eSxcbiAgICAgIHdpbmRvdy5Vbmlwb2ludGVyLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlsc1xuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCBVbmlwb2ludGVyLCB1dGlscyApIHtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUGFnZURvdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBQYWdlRG90cyggcGFyZW50ICkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cblBhZ2VEb3RzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFVuaXBvaW50ZXIucHJvdG90eXBlICk7XG5cblBhZ2VEb3RzLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNyZWF0ZSBob2xkZXIgZWxlbWVudFxuICB0aGlzLmhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyk7XG4gIHRoaXMuaG9sZGVyLmNsYXNzTmFtZSA9ICdmbGlja2l0eS1wYWdlLWRvdHMnO1xuICAvLyBjcmVhdGUgZG90cywgYXJyYXkgb2YgZWxlbWVudHNcbiAgdGhpcy5kb3RzID0gW107XG4gIC8vIGV2ZW50c1xuICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQoIHRoaXMgKTtcbiAgdGhpcy5vbiggJ3BvaW50ZXJEb3duJywgdGhpcy5wYXJlbnQuY2hpbGRVSVBvaW50ZXJEb3duLmJpbmQoIHRoaXMucGFyZW50ICkgKTtcbn07XG5cblBhZ2VEb3RzLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNldERvdHMoKTtcbiAgdGhpcy5ob2xkZXIuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljayApO1xuICB0aGlzLmJpbmRTdGFydEV2ZW50KCB0aGlzLmhvbGRlciApO1xuICAvLyBhZGQgdG8gRE9NXG4gIHRoaXMucGFyZW50LmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuaG9sZGVyICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmhvbGRlci5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrICk7XG4gIHRoaXMudW5iaW5kU3RhcnRFdmVudCggdGhpcy5ob2xkZXIgKTtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIHRoaXMucGFyZW50LmVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRoaXMuaG9sZGVyICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUuc2V0RG90cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBnZXQgZGlmZmVyZW5jZSBiZXR3ZWVuIG51bWJlciBvZiBzbGlkZXMgYW5kIG51bWJlciBvZiBkb3RzXG4gIHZhciBkZWx0YSA9IHRoaXMucGFyZW50LnNsaWRlcy5sZW5ndGggLSB0aGlzLmRvdHMubGVuZ3RoO1xuICBpZiAoIGRlbHRhID4gMCApIHtcbiAgICB0aGlzLmFkZERvdHMoIGRlbHRhICk7XG4gIH0gZWxzZSBpZiAoIGRlbHRhIDwgMCApIHtcbiAgICB0aGlzLnJlbW92ZURvdHMoIC1kZWx0YSApO1xuICB9XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUuYWRkRG90cyA9IGZ1bmN0aW9uKCBjb3VudCApIHtcbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgbmV3RG90cyA9IFtdO1xuICB2YXIgbGVuZ3RoID0gdGhpcy5kb3RzLmxlbmd0aDtcbiAgdmFyIG1heCA9IGxlbmd0aCArIGNvdW50O1xuXG4gIGZvciAoIHZhciBpID0gbGVuZ3RoOyBpIDwgbWF4OyBpKysgKSB7XG4gICAgdmFyIGRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgZG90LmNsYXNzTmFtZSA9ICdkb3QnO1xuICAgIGRvdC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsJywgJ1BhZ2UgZG90ICcgKyAoIGkgKyAxICkgKTtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG90ICk7XG4gICAgbmV3RG90cy5wdXNoKCBkb3QgKTtcbiAgfVxuXG4gIHRoaXMuaG9sZGVyLmFwcGVuZENoaWxkKCBmcmFnbWVudCApO1xuICB0aGlzLmRvdHMgPSB0aGlzLmRvdHMuY29uY2F0KCBuZXdEb3RzICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUucmVtb3ZlRG90cyA9IGZ1bmN0aW9uKCBjb3VudCApIHtcbiAgLy8gcmVtb3ZlIGZyb20gdGhpcy5kb3RzIGNvbGxlY3Rpb25cbiAgdmFyIHJlbW92ZURvdHMgPSB0aGlzLmRvdHMuc3BsaWNlKCB0aGlzLmRvdHMubGVuZ3RoIC0gY291bnQsIGNvdW50ICk7XG4gIC8vIHJlbW92ZSBmcm9tIERPTVxuICByZW1vdmVEb3RzLmZvckVhY2goIGZ1bmN0aW9uKCBkb3QgKSB7XG4gICAgdGhpcy5ob2xkZXIucmVtb3ZlQ2hpbGQoIGRvdCApO1xuICB9LCB0aGlzICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUudXBkYXRlU2VsZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIHNlbGVjdGVkIGNsYXNzIG9uIHByZXZpb3VzXG4gIGlmICggdGhpcy5zZWxlY3RlZERvdCApIHtcbiAgICB0aGlzLnNlbGVjdGVkRG90LmNsYXNzTmFtZSA9ICdkb3QnO1xuICAgIHRoaXMuc2VsZWN0ZWREb3QucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcbiAgfVxuICAvLyBkb24ndCBwcm9jZWVkIGlmIG5vIGRvdHNcbiAgaWYgKCAhdGhpcy5kb3RzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5zZWxlY3RlZERvdCA9IHRoaXMuZG90c1sgdGhpcy5wYXJlbnQuc2VsZWN0ZWRJbmRleCBdO1xuICB0aGlzLnNlbGVjdGVkRG90LmNsYXNzTmFtZSA9ICdkb3QgaXMtc2VsZWN0ZWQnO1xuICB0aGlzLnNlbGVjdGVkRG90LnNldEF0dHJpYnV0ZSggJ2FyaWEtY3VycmVudCcsICdzdGVwJyApO1xufTtcblxuUGFnZURvdHMucHJvdG90eXBlLm9uVGFwID0gLy8gb2xkIG1ldGhvZCBuYW1lLCBiYWNrd2FyZHMtY29tcGF0aWJsZVxuUGFnZURvdHMucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIC8vIG9ubHkgY2FyZSBhYm91dCBkb3QgY2xpY2tzXG4gIGlmICggdGFyZ2V0Lm5vZGVOYW1lICE9ICdMSScgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wYXJlbnQudWlDaGFuZ2UoKTtcbiAgdmFyIGluZGV4ID0gdGhpcy5kb3RzLmluZGV4T2YoIHRhcmdldCApO1xuICB0aGlzLnBhcmVudC5zZWxlY3QoIGluZGV4ICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgdGhpcy5hbGxPZmYoKTtcbn07XG5cbkZsaWNraXR5LlBhZ2VEb3RzID0gUGFnZURvdHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZsaWNraXR5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnV0aWxzLmV4dGVuZCggRmxpY2tpdHkuZGVmYXVsdHMsIHtcbiAgcGFnZURvdHM6IHRydWVcbn0pO1xuXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzLnB1c2goJ19jcmVhdGVQYWdlRG90cycpO1xuXG52YXIgcHJvdG8gPSBGbGlja2l0eS5wcm90b3R5cGU7XG5cbnByb3RvLl9jcmVhdGVQYWdlRG90cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLm9wdGlvbnMucGFnZURvdHMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucGFnZURvdHMgPSBuZXcgUGFnZURvdHMoIHRoaXMgKTtcbiAgLy8gZXZlbnRzXG4gIHRoaXMub24oICdhY3RpdmF0ZScsIHRoaXMuYWN0aXZhdGVQYWdlRG90cyApO1xuICB0aGlzLm9uKCAnc2VsZWN0JywgdGhpcy51cGRhdGVTZWxlY3RlZFBhZ2VEb3RzICk7XG4gIHRoaXMub24oICdjZWxsQ2hhbmdlJywgdGhpcy51cGRhdGVQYWdlRG90cyApO1xuICB0aGlzLm9uKCAncmVzaXplJywgdGhpcy51cGRhdGVQYWdlRG90cyApO1xuICB0aGlzLm9uKCAnZGVhY3RpdmF0ZScsIHRoaXMuZGVhY3RpdmF0ZVBhZ2VEb3RzICk7XG59O1xuXG5wcm90by5hY3RpdmF0ZVBhZ2VEb3RzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGFnZURvdHMuYWN0aXZhdGUoKTtcbn07XG5cbnByb3RvLnVwZGF0ZVNlbGVjdGVkUGFnZURvdHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYWdlRG90cy51cGRhdGVTZWxlY3RlZCgpO1xufTtcblxucHJvdG8udXBkYXRlUGFnZURvdHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYWdlRG90cy5zZXREb3RzKCk7XG59O1xuXG5wcm90by5kZWFjdGl2YXRlUGFnZURvdHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYWdlRG90cy5kZWFjdGl2YXRlKCk7XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxuRmxpY2tpdHkuUGFnZURvdHMgPSBQYWdlRG90cztcblxucmV0dXJuIEZsaWNraXR5O1xuXG59KSk7XG4iLCIvLyBwbGF5ZXIgJiBhdXRvUGxheVxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJyxcbiAgICAgICcuL2ZsaWNraXR5J1xuICAgIF0sIGZ1bmN0aW9uKCBFdkVtaXR0ZXIsIHV0aWxzLCBGbGlja2l0eSApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCBFdkVtaXR0ZXIsIHV0aWxzLCBGbGlja2l0eSApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpLFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKSxcbiAgICAgIHJlcXVpcmUoJy4vZmxpY2tpdHknKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICBmYWN0b3J5KFxuICAgICAgd2luZG93LkV2RW1pdHRlcixcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHMsXG4gICAgICB3aW5kb3cuRmxpY2tpdHlcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggRXZFbWl0dGVyLCB1dGlscywgRmxpY2tpdHkgKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUGxheWVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIFBsYXllciggcGFyZW50ICkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5zdGF0ZSA9ICdzdG9wcGVkJztcbiAgLy8gdmlzaWJpbGl0eSBjaGFuZ2UgZXZlbnQgaGFuZGxlclxuICB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMudmlzaWJpbGl0eUNoYW5nZS5iaW5kKCB0aGlzICk7XG4gIHRoaXMub25WaXNpYmlsaXR5UGxheSA9IHRoaXMudmlzaWJpbGl0eVBsYXkuYmluZCggdGhpcyApO1xufVxuXG5QbGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG4vLyBzdGFydCBwbGF5XG5QbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCB0aGlzLnN0YXRlID09ICdwbGF5aW5nJyApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZG8gbm90IHBsYXkgaWYgcGFnZSBpcyBoaWRkZW4sIHN0YXJ0IHBsYXlpbmcgd2hlbiBwYWdlIGlzIHZpc2libGVcbiAgdmFyIGlzUGFnZUhpZGRlbiA9IGRvY3VtZW50LmhpZGRlbjtcbiAgaWYgKCBpc1BhZ2VIaWRkZW4gKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLm9uVmlzaWJpbGl0eVBsYXkgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXRlID0gJ3BsYXlpbmcnO1xuICAvLyBsaXN0ZW4gdG8gdmlzaWJpbGl0eSBjaGFuZ2VcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZSApO1xuICAvLyBzdGFydCB0aWNraW5nXG4gIHRoaXMudGljaygpO1xufTtcblxuUGxheWVyLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIG5vdCB0aWNrIGlmIG5vdCBwbGF5aW5nXG4gIGlmICggdGhpcy5zdGF0ZSAhPSAncGxheWluZycgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRpbWUgPSB0aGlzLnBhcmVudC5vcHRpb25zLmF1dG9QbGF5O1xuICAvLyBkZWZhdWx0IHRvIDMgc2Vjb25kc1xuICB0aW1lID0gdHlwZW9mIHRpbWUgPT0gJ251bWJlcicgPyB0aW1lIDogMzAwMDtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgLy8gSEFDSzogcmVzZXQgdGlja3MgaWYgc3RvcHBlZCBhbmQgc3RhcnRlZCB3aXRoaW4gaW50ZXJ2YWxcbiAgdGhpcy5jbGVhcigpO1xuICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5wYXJlbnQubmV4dCggdHJ1ZSApO1xuICAgIF90aGlzLnRpY2soKTtcbiAgfSwgdGltZSApO1xufTtcblxuUGxheWVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGUgPSAnc3RvcHBlZCc7XG4gIHRoaXMuY2xlYXIoKTtcbiAgLy8gcmVtb3ZlIHZpc2liaWxpdHkgY2hhbmdlIGV2ZW50XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5vblZpc2liaWxpdHlDaGFuZ2UgKTtcbn07XG5cblBsYXllci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVvdXQgKTtcbn07XG5cblBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCB0aGlzLnN0YXRlID09ICdwbGF5aW5nJyApIHtcbiAgICB0aGlzLnN0YXRlID0gJ3BhdXNlZCc7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG59O1xuXG5QbGF5ZXIucHJvdG90eXBlLnVucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmUtc3RhcnQgcGxheSBpZiBwYXVzZWRcbiAgaWYgKCB0aGlzLnN0YXRlID09ICdwYXVzZWQnICkge1xuICAgIHRoaXMucGxheSgpO1xuICB9XG59O1xuXG4vLyBwYXVzZSBpZiBwYWdlIHZpc2liaWxpdHkgaXMgaGlkZGVuLCB1bnBhdXNlIGlmIHZpc2libGVcblBsYXllci5wcm90b3R5cGUudmlzaWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXNQYWdlSGlkZGVuID0gZG9jdW1lbnQuaGlkZGVuO1xuICB0aGlzWyBpc1BhZ2VIaWRkZW4gPyAncGF1c2UnIDogJ3VucGF1c2UnIF0oKTtcbn07XG5cblBsYXllci5wcm90b3R5cGUudmlzaWJpbGl0eVBsYXkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wbGF5KCk7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5vblZpc2liaWxpdHlQbGF5ICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGbGlja2l0eSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG51dGlscy5leHRlbmQoIEZsaWNraXR5LmRlZmF1bHRzLCB7XG4gIHBhdXNlQXV0b1BsYXlPbkhvdmVyOiB0cnVlXG59KTtcblxuRmxpY2tpdHkuY3JlYXRlTWV0aG9kcy5wdXNoKCdfY3JlYXRlUGxheWVyJyk7XG52YXIgcHJvdG8gPSBGbGlja2l0eS5wcm90b3R5cGU7XG5cbnByb3RvLl9jcmVhdGVQbGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wbGF5ZXIgPSBuZXcgUGxheWVyKCB0aGlzICk7XG5cbiAgdGhpcy5vbiggJ2FjdGl2YXRlJywgdGhpcy5hY3RpdmF0ZVBsYXllciApO1xuICB0aGlzLm9uKCAndWlDaGFuZ2UnLCB0aGlzLnN0b3BQbGF5ZXIgKTtcbiAgdGhpcy5vbiggJ3BvaW50ZXJEb3duJywgdGhpcy5zdG9wUGxheWVyICk7XG4gIHRoaXMub24oICdkZWFjdGl2YXRlJywgdGhpcy5kZWFjdGl2YXRlUGxheWVyICk7XG59O1xuXG5wcm90by5hY3RpdmF0ZVBsYXllciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLm9wdGlvbnMuYXV0b1BsYXkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucGxheWVyLnBsYXkoKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWVudGVyJywgdGhpcyApO1xufTtcblxuLy8gUGxheWVyIEFQSSwgZG9uJ3QgaGF0ZSB0aGUgLi4uIHRoYW5rcyBJIGtub3cgd2hlcmUgdGhlIGRvb3IgaXNcblxucHJvdG8ucGxheVBsYXllciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBsYXllci5wbGF5KCk7XG59O1xuXG5wcm90by5zdG9wUGxheWVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGxheWVyLnN0b3AoKTtcbn07XG5cbnByb3RvLnBhdXNlUGxheWVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGxheWVyLnBhdXNlKCk7XG59O1xuXG5wcm90by51bnBhdXNlUGxheWVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGxheWVyLnVucGF1c2UoKTtcbn07XG5cbnByb3RvLmRlYWN0aXZhdGVQbGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wbGF5ZXIuc3RvcCgpO1xuICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZW50ZXInLCB0aGlzICk7XG59O1xuXG4vLyAtLS0tLSBtb3VzZWVudGVyL2xlYXZlIC0tLS0tIC8vXG5cbi8vIHBhdXNlIGF1dG8tcGxheSBvbiBob3ZlclxucHJvdG8ub25tb3VzZWVudGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMub3B0aW9ucy5wYXVzZUF1dG9QbGF5T25Ib3ZlciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wbGF5ZXIucGF1c2UoKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWxlYXZlJywgdGhpcyApO1xufTtcblxuLy8gcmVzdW1lIGF1dG8tcGxheSBvbiBob3ZlciBvZmZcbnByb3RvLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBsYXllci51bnBhdXNlKCk7XG4gIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2VsZWF2ZScsIHRoaXMgKTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5GbGlja2l0eS5QbGF5ZXIgPSBQbGF5ZXI7XG5cbnJldHVybiBGbGlja2l0eTtcblxufSkpO1xuIiwiLy8gcHJldi9uZXh0IGJ1dHRvbnNcbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnLi9mbGlja2l0eScsXG4gICAgICAndW5pcG9pbnRlci91bmlwb2ludGVyJyxcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscydcbiAgICBdLCBmdW5jdGlvbiggRmxpY2tpdHksIFVuaXBvaW50ZXIsIHV0aWxzICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRmxpY2tpdHksIFVuaXBvaW50ZXIsIHV0aWxzICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCcuL2ZsaWNraXR5JyksXG4gICAgICByZXF1aXJlKCd1bmlwb2ludGVyJyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRmxpY2tpdHksXG4gICAgICB3aW5kb3cuVW5pcG9pbnRlcixcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHNcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgVW5pcG9pbnRlciwgdXRpbHMgKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdmdVUkkgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQcmV2TmV4dEJ1dHRvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBQcmV2TmV4dEJ1dHRvbiggZGlyZWN0aW9uLCBwYXJlbnQgKSB7XG4gIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFVuaXBvaW50ZXIucHJvdG90eXBlICk7XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHByb3BlcnRpZXNcbiAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICB0aGlzLmlzUHJldmlvdXMgPSB0aGlzLmRpcmVjdGlvbiA9PSAtMTtcbiAgdmFyIGxlZnREaXJlY3Rpb24gPSB0aGlzLnBhcmVudC5vcHRpb25zLnJpZ2h0VG9MZWZ0ID8gMSA6IC0xO1xuICB0aGlzLmlzTGVmdCA9IHRoaXMuZGlyZWN0aW9uID09IGxlZnREaXJlY3Rpb247XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgZWxlbWVudC5jbGFzc05hbWUgPSAnZmxpY2tpdHktYnV0dG9uIGZsaWNraXR5LXByZXYtbmV4dC1idXR0b24nO1xuICBlbGVtZW50LmNsYXNzTmFtZSArPSB0aGlzLmlzUHJldmlvdXMgPyAnIHByZXZpb3VzJyA6ICcgbmV4dCc7XG4gIC8vIHByZXZlbnQgYnV0dG9uIGZyb20gc3VibWl0dGluZyBmb3JtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwODM2MDc2LzE4MjE4M1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZSggJ3R5cGUnLCAnYnV0dG9uJyApO1xuICAvLyBpbml0IGFzIGRpc2FibGVkXG4gIHRoaXMuZGlzYWJsZSgpO1xuXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnYXJpYS1sYWJlbCcsIHRoaXMuaXNQcmV2aW91cyA/ICdQcmV2aW91cycgOiAnTmV4dCcgKTtcblxuICAvLyBjcmVhdGUgYXJyb3dcbiAgdmFyIHN2ZyA9IHRoaXMuY3JlYXRlU1ZHKCk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoIHN2ZyApO1xuICAvLyBldmVudHNcbiAgdGhpcy5wYXJlbnQub24oICdzZWxlY3QnLCB0aGlzLnVwZGF0ZS5iaW5kKCB0aGlzICkgKTtcbiAgdGhpcy5vbiggJ3BvaW50ZXJEb3duJywgdGhpcy5wYXJlbnQuY2hpbGRVSVBvaW50ZXJEb3duLmJpbmQoIHRoaXMucGFyZW50ICkgKTtcbn07XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJpbmRTdGFydEV2ZW50KCB0aGlzLmVsZW1lbnQgKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIHRoaXMgKTtcbiAgLy8gYWRkIHRvIERPTVxuICB0aGlzLnBhcmVudC5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlbW92ZSBmcm9tIERPTVxuICB0aGlzLnBhcmVudC5lbGVtZW50LnJlbW92ZUNoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbiAgLy8gY2xpY2sgZXZlbnRzXG4gIHRoaXMudW5iaW5kU3RhcnRFdmVudCggdGhpcy5lbGVtZW50ICk7XG4gIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCB0aGlzICk7XG59O1xuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlU1ZHID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoIHN2Z1VSSSwgJ3N2ZycpO1xuICBzdmcuc2V0QXR0cmlidXRlKCAnY2xhc3MnLCAnZmxpY2tpdHktYnV0dG9uLWljb24nICk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoICd2aWV3Qm94JywgJzAgMCAxMDAgMTAwJyApO1xuICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggc3ZnVVJJLCAncGF0aCcpO1xuICB2YXIgcGF0aE1vdmVtZW50cyA9IGdldEFycm93TW92ZW1lbnRzKCB0aGlzLnBhcmVudC5vcHRpb25zLmFycm93U2hhcGUgKTtcbiAgcGF0aC5zZXRBdHRyaWJ1dGUoICdkJywgcGF0aE1vdmVtZW50cyApO1xuICBwYXRoLnNldEF0dHJpYnV0ZSggJ2NsYXNzJywgJ2Fycm93JyApO1xuICAvLyByb3RhdGUgYXJyb3dcbiAgaWYgKCAhdGhpcy5pc0xlZnQgKSB7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDEwMCwgMTAwKSByb3RhdGUoMTgwKSAnICk7XG4gIH1cbiAgc3ZnLmFwcGVuZENoaWxkKCBwYXRoICk7XG4gIHJldHVybiBzdmc7XG59O1xuXG4vLyBnZXQgU1ZHIHBhdGggbW92bWVtZW50XG5mdW5jdGlvbiBnZXRBcnJvd01vdmVtZW50cyggc2hhcGUgKSB7XG4gIC8vIHVzZSBzaGFwZSBhcyBtb3ZlbWVudCBpZiBzdHJpbmdcbiAgaWYgKCB0eXBlb2Ygc2hhcGUgPT0gJ3N0cmluZycgKSB7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9XG4gIC8vIGNyZWF0ZSBtb3ZlbWVudCBzdHJpbmdcbiAgcmV0dXJuICdNICcgKyBzaGFwZS54MCArICcsNTAnICtcbiAgICAnIEwgJyArIHNoYXBlLngxICsgJywnICsgKCBzaGFwZS55MSArIDUwICkgK1xuICAgICcgTCAnICsgc2hhcGUueDIgKyAnLCcgKyAoIHNoYXBlLnkyICsgNTAgKSArXG4gICAgJyBMICcgKyBzaGFwZS54MyArICcsNTAgJyArXG4gICAgJyBMICcgKyBzaGFwZS54MiArICcsJyArICggNTAgLSBzaGFwZS55MiApICtcbiAgICAnIEwgJyArIHNoYXBlLngxICsgJywnICsgKCA1MCAtIHNoYXBlLnkxICkgK1xuICAgICcgWic7XG59XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IHV0aWxzLmhhbmRsZUV2ZW50O1xuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wYXJlbnQudWlDaGFuZ2UoKTtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuaXNQcmV2aW91cyA/ICdwcmV2aW91cycgOiAnbmV4dCc7XG4gIHRoaXMucGFyZW50WyBtZXRob2QgXSgpO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCB0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5lbGVtZW50LmRpc2FibGVkID0gZmFsc2U7XG4gIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbn07XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuaXNFbmFibGVkICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmVsZW1lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuUHJldk5leHRCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBpbmRleCBvZiBmaXJzdCBvciBsYXN0IHNsaWRlLCBpZiBwcmV2aW91cyBvciBuZXh0XG4gIHZhciBzbGlkZXMgPSB0aGlzLnBhcmVudC5zbGlkZXM7XG4gIC8vIGVuYWJsZSBpcyB3cmFwQXJvdW5kIGFuZCBhdCBsZWFzdCAyIHNsaWRlc1xuICBpZiAoIHRoaXMucGFyZW50Lm9wdGlvbnMud3JhcEFyb3VuZCAmJiBzbGlkZXMubGVuZ3RoID4gMSApIHtcbiAgICB0aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gc2xpZGVzLmxlbmd0aCA/IHNsaWRlcy5sZW5ndGggLSAxIDogMDtcbiAgdmFyIGJvdW5kSW5kZXggPSB0aGlzLmlzUHJldmlvdXMgPyAwIDogbGFzdEluZGV4O1xuICB2YXIgbWV0aG9kID0gdGhpcy5wYXJlbnQuc2VsZWN0ZWRJbmRleCA9PSBib3VuZEluZGV4ID8gJ2Rpc2FibGUnIDogJ2VuYWJsZSc7XG4gIHRoaXNbIG1ldGhvZCBdKCk7XG59O1xuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgdGhpcy5hbGxPZmYoKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZsaWNraXR5IHByb3RvdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG51dGlscy5leHRlbmQoIEZsaWNraXR5LmRlZmF1bHRzLCB7XG4gIHByZXZOZXh0QnV0dG9uczogdHJ1ZSxcbiAgYXJyb3dTaGFwZToge1xuICAgIHgwOiAxMCxcbiAgICB4MTogNjAsIHkxOiA1MCxcbiAgICB4MjogNzAsIHkyOiA0MCxcbiAgICB4MzogMzBcbiAgfVxufSk7XG5cbkZsaWNraXR5LmNyZWF0ZU1ldGhvZHMucHVzaCgnX2NyZWF0ZVByZXZOZXh0QnV0dG9ucycpO1xudmFyIHByb3RvID0gRmxpY2tpdHkucHJvdG90eXBlO1xuXG5wcm90by5fY3JlYXRlUHJldk5leHRCdXR0b25zID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMub3B0aW9ucy5wcmV2TmV4dEJ1dHRvbnMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wcmV2QnV0dG9uID0gbmV3IFByZXZOZXh0QnV0dG9uKCAtMSwgdGhpcyApO1xuICB0aGlzLm5leHRCdXR0b24gPSBuZXcgUHJldk5leHRCdXR0b24oIDEsIHRoaXMgKTtcblxuICB0aGlzLm9uKCAnYWN0aXZhdGUnLCB0aGlzLmFjdGl2YXRlUHJldk5leHRCdXR0b25zICk7XG59O1xuXG5wcm90by5hY3RpdmF0ZVByZXZOZXh0QnV0dG9ucyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZCdXR0b24uYWN0aXZhdGUoKTtcbiAgdGhpcy5uZXh0QnV0dG9uLmFjdGl2YXRlKCk7XG4gIHRoaXMub24oICdkZWFjdGl2YXRlJywgdGhpcy5kZWFjdGl2YXRlUHJldk5leHRCdXR0b25zICk7XG59O1xuXG5wcm90by5kZWFjdGl2YXRlUHJldk5leHRCdXR0b25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJldkJ1dHRvbi5kZWFjdGl2YXRlKCk7XG4gIHRoaXMubmV4dEJ1dHRvbi5kZWFjdGl2YXRlKCk7XG4gIHRoaXMub2ZmKCAnZGVhY3RpdmF0ZScsIHRoaXMuZGVhY3RpdmF0ZVByZXZOZXh0QnV0dG9ucyApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbkZsaWNraXR5LlByZXZOZXh0QnV0dG9uID0gUHJldk5leHRCdXR0b247XG5cbnJldHVybiBGbGlja2l0eTtcblxufSkpO1xuIiwiLy8gc2xpZGVcbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5GbGlja2l0eSA9IHdpbmRvdy5GbGlja2l0eSB8fCB7fTtcbiAgICB3aW5kb3cuRmxpY2tpdHkuU2xpZGUgPSBmYWN0b3J5KCk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBTbGlkZSggcGFyZW50ICkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5pc09yaWdpbkxlZnQgPSBwYXJlbnQub3JpZ2luU2lkZSA9PSAnbGVmdCc7XG4gIHRoaXMuY2VsbHMgPSBbXTtcbiAgdGhpcy5vdXRlcldpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xufVxuXG52YXIgcHJvdG8gPSBTbGlkZS5wcm90b3R5cGU7XG5cbnByb3RvLmFkZENlbGwgPSBmdW5jdGlvbiggY2VsbCApIHtcbiAgdGhpcy5jZWxscy5wdXNoKCBjZWxsICk7XG4gIHRoaXMub3V0ZXJXaWR0aCArPSBjZWxsLnNpemUub3V0ZXJXaWR0aDtcbiAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCggY2VsbC5zaXplLm91dGVySGVpZ2h0LCB0aGlzLmhlaWdodCApO1xuICAvLyBmaXJzdCBjZWxsIHN0dWZmXG4gIGlmICggdGhpcy5jZWxscy5sZW5ndGggPT0gMSApIHtcbiAgICB0aGlzLnggPSBjZWxsLng7IC8vIHggY29tZXMgZnJvbSBmaXJzdCBjZWxsXG4gICAgdmFyIGJlZ2luTWFyZ2luID0gdGhpcy5pc09yaWdpbkxlZnQgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnO1xuICAgIHRoaXMuZmlyc3RNYXJnaW4gPSBjZWxsLnNpemVbIGJlZ2luTWFyZ2luIF07XG4gIH1cbn07XG5cbnByb3RvLnVwZGF0ZVRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5kTWFyZ2luID0gdGhpcy5pc09yaWdpbkxlZnQgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnO1xuICB2YXIgbGFzdENlbGwgPSB0aGlzLmdldExhc3RDZWxsKCk7XG4gIHZhciBsYXN0TWFyZ2luID0gbGFzdENlbGwgPyBsYXN0Q2VsbC5zaXplWyBlbmRNYXJnaW4gXSA6IDA7XG4gIHZhciBzbGlkZVdpZHRoID0gdGhpcy5vdXRlcldpZHRoIC0gKCB0aGlzLmZpcnN0TWFyZ2luICsgbGFzdE1hcmdpbiApO1xuICB0aGlzLnRhcmdldCA9IHRoaXMueCArIHRoaXMuZmlyc3RNYXJnaW4gKyBzbGlkZVdpZHRoICogdGhpcy5wYXJlbnQuY2VsbEFsaWduO1xufTtcblxucHJvdG8uZ2V0TGFzdENlbGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2VsbHNbIHRoaXMuY2VsbHMubGVuZ3RoIC0gMSBdO1xufTtcblxucHJvdG8uc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgY2VsbC5zZWxlY3QoKTtcbiAgfSk7XG59O1xuXG5wcm90by51bnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNlbGxzLmZvckVhY2goIGZ1bmN0aW9uKCBjZWxsICkge1xuICAgIGNlbGwudW5zZWxlY3QoKTtcbiAgfSk7XG59O1xuXG5wcm90by5nZXRDZWxsRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2VsbHMubWFwKCBmdW5jdGlvbiggY2VsbCApIHtcbiAgICByZXR1cm4gY2VsbC5lbGVtZW50O1xuICB9KTtcbn07XG5cbnJldHVybiBTbGlkZTtcblxufSkpO1xuIiwiLyohXG4gKiBnZXRTaXplIHYyLjAuM1xuICogbWVhc3VyZSBzaXplIG9mIGVsZW1lbnRzXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qIGpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgY29uc29sZTogZmFsc2UgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5nZXRTaXplID0gZmFjdG9yeSgpO1xuICB9XG5cbn0pKCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2V0IGEgbnVtYmVyIGZyb20gYSBzdHJpbmcsIG5vdCBhIHBlcmNlbnRhZ2VcbmZ1bmN0aW9uIGdldFN0eWxlU2l6ZSggdmFsdWUgKSB7XG4gIHZhciBudW0gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuICAvLyBub3QgYSBwZXJjZW50IGxpa2UgJzEwMCUnLCBhbmQgYSBudW1iZXJcbiAgdmFyIGlzVmFsaWQgPSB2YWx1ZS5pbmRleE9mKCclJykgPT0gLTEgJiYgIWlzTmFOKCBudW0gKTtcbiAgcmV0dXJuIGlzVmFsaWQgJiYgbnVtO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGxvZ0Vycm9yID0gdHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcgPyBub29wIDpcbiAgZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG4gICAgY29uc29sZS5lcnJvciggbWVzc2FnZSApO1xuICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZWFzdXJlbWVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIG1lYXN1cmVtZW50cyA9IFtcbiAgJ3BhZGRpbmdMZWZ0JyxcbiAgJ3BhZGRpbmdSaWdodCcsXG4gICdwYWRkaW5nVG9wJyxcbiAgJ3BhZGRpbmdCb3R0b20nLFxuICAnbWFyZ2luTGVmdCcsXG4gICdtYXJnaW5SaWdodCcsXG4gICdtYXJnaW5Ub3AnLFxuICAnbWFyZ2luQm90dG9tJyxcbiAgJ2JvcmRlckxlZnRXaWR0aCcsXG4gICdib3JkZXJSaWdodFdpZHRoJyxcbiAgJ2JvcmRlclRvcFdpZHRoJyxcbiAgJ2JvcmRlckJvdHRvbVdpZHRoJ1xuXTtcblxudmFyIG1lYXN1cmVtZW50c0xlbmd0aCA9IG1lYXN1cmVtZW50cy5sZW5ndGg7XG5cbmZ1bmN0aW9uIGdldFplcm9TaXplKCkge1xuICB2YXIgc2l6ZSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaW5uZXJXaWR0aDogMCxcbiAgICBpbm5lckhlaWdodDogMCxcbiAgICBvdXRlcldpZHRoOiAwLFxuICAgIG91dGVySGVpZ2h0OiAwXG4gIH07XG4gIGZvciAoIHZhciBpPTA7IGkgPCBtZWFzdXJlbWVudHNMZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFN0eWxlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogZ2V0U3R5bGUsIGdldCBzdHlsZSBvZiBlbGVtZW50LCBjaGVjayBmb3IgRmlyZWZveCBidWdcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICovXG5mdW5jdGlvbiBnZXRTdHlsZSggZWxlbSApIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuICBpZiAoICFzdHlsZSApIHtcbiAgICBsb2dFcnJvciggJ1N0eWxlIHJldHVybmVkICcgKyBzdHlsZSArXG4gICAgICAnLiBBcmUgeW91IHJ1bm5pbmcgdGhpcyBjb2RlIGluIGEgaGlkZGVuIGlmcmFtZSBvbiBGaXJlZm94PyAnICtcbiAgICAgICdTZWUgaHR0cHM6Ly9iaXQubHkvZ2V0c2l6ZWJ1ZzEnICk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzZXR1cCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgaXNTZXR1cCA9IGZhbHNlO1xuXG52YXIgaXNCb3hTaXplT3V0ZXI7XG5cbi8qKlxuICogc2V0dXBcbiAqIGNoZWNrIGlzQm94U2l6ZXJPdXRlclxuICogZG8gb24gZmlyc3QgZ2V0U2l6ZSgpIHJhdGhlciB0aGFuIG9uIHBhZ2UgbG9hZCBmb3IgRmlyZWZveCBidWdcbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gIC8vIHNldHVwIG9uY2VcbiAgaWYgKCBpc1NldHVwICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpc1NldHVwID0gdHJ1ZTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBib3ggc2l6aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgLyoqXG4gICAqIENocm9tZSAmIFNhZmFyaSBtZWFzdXJlIHRoZSBvdXRlci13aWR0aCBvbiBzdHlsZS53aWR0aCBvbiBib3JkZXItYm94IGVsZW1zXG4gICAqIElFMTEgJiBGaXJlZm94PDI5IG1lYXN1cmVzIHRoZSBpbm5lci13aWR0aFxuICAgKi9cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMjAwcHgnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcxcHggMnB4IDNweCA0cHgnO1xuICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICBkaXYuc3R5bGUuYm9yZGVyV2lkdGggPSAnMXB4IDJweCAzcHggNHB4JztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcblxuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGRpdiApO1xuICAvLyByb3VuZCB2YWx1ZSBmb3IgYnJvd3NlciB6b29tLiBkZXNhbmRyby9tYXNvbnJ5IzkyOFxuICBpc0JveFNpemVPdXRlciA9IE1hdGgucm91bmQoIGdldFN0eWxlU2l6ZSggc3R5bGUud2lkdGggKSApID09IDIwMDtcbiAgZ2V0U2l6ZS5pc0JveFNpemVPdXRlciA9IGlzQm94U2l6ZU91dGVyO1xuXG4gIGJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXRTaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIGdldFNpemUoIGVsZW0gKSB7XG4gIHNldHVwKCk7XG5cbiAgLy8gdXNlIHF1ZXJ5U2VsZXRvciBpZiBlbGVtIGlzIHN0cmluZ1xuICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgIGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtICk7XG4gIH1cblxuICAvLyBkbyBub3QgcHJvY2VlZCBvbiBub24tb2JqZWN0c1xuICBpZiAoICFlbGVtIHx8IHR5cGVvZiBlbGVtICE9ICdvYmplY3QnIHx8ICFlbGVtLm5vZGVUeXBlICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGdldFN0eWxlKCBlbGVtICk7XG5cbiAgLy8gaWYgaGlkZGVuLCBldmVyeXRoaW5nIGlzIDBcbiAgaWYgKCBzdHlsZS5kaXNwbGF5ID09ICdub25lJyApIHtcbiAgICByZXR1cm4gZ2V0WmVyb1NpemUoKTtcbiAgfVxuXG4gIHZhciBzaXplID0ge307XG4gIHNpemUud2lkdGggPSBlbGVtLm9mZnNldFdpZHRoO1xuICBzaXplLmhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuXG4gIHZhciBpc0JvcmRlckJveCA9IHNpemUuaXNCb3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT0gJ2JvcmRlci1ib3gnO1xuXG4gIC8vIGdldCBhbGwgbWVhc3VyZW1lbnRzXG4gIGZvciAoIHZhciBpPTA7IGkgPCBtZWFzdXJlbWVudHNMZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIHZhbHVlID0gc3R5bGVbIG1lYXN1cmVtZW50IF07XG4gICAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gICAgLy8gYW55ICdhdXRvJywgJ21lZGl1bScgdmFsdWUgd2lsbCBiZSAwXG4gICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9ICFpc05hTiggbnVtICkgPyBudW0gOiAwO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdXaWR0aCA9IHNpemUucGFkZGluZ0xlZnQgKyBzaXplLnBhZGRpbmdSaWdodDtcbiAgdmFyIHBhZGRpbmdIZWlnaHQgPSBzaXplLnBhZGRpbmdUb3AgKyBzaXplLnBhZGRpbmdCb3R0b207XG4gIHZhciBtYXJnaW5XaWR0aCA9IHNpemUubWFyZ2luTGVmdCArIHNpemUubWFyZ2luUmlnaHQ7XG4gIHZhciBtYXJnaW5IZWlnaHQgPSBzaXplLm1hcmdpblRvcCArIHNpemUubWFyZ2luQm90dG9tO1xuICB2YXIgYm9yZGVyV2lkdGggPSBzaXplLmJvcmRlckxlZnRXaWR0aCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aDtcbiAgdmFyIGJvcmRlckhlaWdodCA9IHNpemUuYm9yZGVyVG9wV2lkdGggKyBzaXplLmJvcmRlckJvdHRvbVdpZHRoO1xuXG4gIHZhciBpc0JvcmRlckJveFNpemVPdXRlciA9IGlzQm9yZGVyQm94ICYmIGlzQm94U2l6ZU91dGVyO1xuXG4gIC8vIG92ZXJ3cml0ZSB3aWR0aCBhbmQgaGVpZ2h0IGlmIHdlIGNhbiBnZXQgaXQgZnJvbSBzdHlsZVxuICB2YXIgc3R5bGVXaWR0aCA9IGdldFN0eWxlU2l6ZSggc3R5bGUud2lkdGggKTtcbiAgaWYgKCBzdHlsZVdpZHRoICE9PSBmYWxzZSApIHtcbiAgICBzaXplLndpZHRoID0gc3R5bGVXaWR0aCArXG4gICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XG4gICAgICAoIGlzQm9yZGVyQm94U2l6ZU91dGVyID8gMCA6IHBhZGRpbmdXaWR0aCArIGJvcmRlcldpZHRoICk7XG4gIH1cblxuICB2YXIgc3R5bGVIZWlnaHQgPSBnZXRTdHlsZVNpemUoIHN0eWxlLmhlaWdodCApO1xuICBpZiAoIHN0eWxlSGVpZ2h0ICE9PSBmYWxzZSApIHtcbiAgICBzaXplLmhlaWdodCA9IHN0eWxlSGVpZ2h0ICtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ0hlaWdodCArIGJvcmRlckhlaWdodCApO1xuICB9XG5cbiAgc2l6ZS5pbm5lcldpZHRoID0gc2l6ZS53aWR0aCAtICggcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgc2l6ZS5pbm5lckhlaWdodCA9IHNpemUuaGVpZ2h0IC0gKCBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XG5cbiAgc2l6ZS5vdXRlcldpZHRoID0gc2l6ZS53aWR0aCArIG1hcmdpbldpZHRoO1xuICBzaXplLm91dGVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyBtYXJnaW5IZWlnaHQ7XG5cbiAgcmV0dXJuIHNpemU7XG59XG5cbnJldHVybiBnZXRTaXplO1xuXG59KTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCIvKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHNoaW1zIHRoYXQgcHJvdmlkZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIEVTNiBjb2xsZWN0aW9ucy5cclxuICpcclxuICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG4gKiBtb2R1bGVzIGFzIHRoZXkgY292ZXIgb25seSBhIGxpbWl0ZWQgcmFuZ2Ugb2YgdXNlIGNhc2VzLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxudmFyIE1hcFNoaW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xyXG4gICAgICAgIGFyci5zb21lKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcclxuICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICB9KCkpO1xyXG59KSgpO1xuXG4vKipcclxuICogRGV0ZWN0cyB3aGV0aGVyIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyBhcmUgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG4vLyBSZXR1cm5zIGdsb2JhbCBvYmplY3Qgb2YgYSBjdXJyZW50IGVudmlyb25tZW50LlxyXG52YXIgZ2xvYmFsJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICovXHJcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gdXNlIGEgYm91bmRlZCBmdW5jdGlvbiBiZWNhdXNlIElFIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuICAgICAgICAvLyBvYmplY3Qgb24gdGhlIGxlZnQgaGFuZCBzaWRlLlxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChnbG9iYWwkMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG59KSgpO1xuXG4vLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxudmFyIHRyYWlsaW5nVGltZW91dCA9IDI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlIChjYWxsYmFjaywgZGVsYXkpIHtcclxuICAgIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLCB0cmFpbGluZ0NhbGwgPSBmYWxzZSwgbGFzdENhbGxUaW1lID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhaWxpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIHByb3h5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cclxuICAgICAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RDYWxsVGltZSA8IHRyYWlsaW5nVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5ldyBjYWxsIHRvIGJlIGluIGludm9rZWQgd2hlbiB0aGUgcGVuZGluZyBvbmUgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcclxuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gaGFwcGVucyBhbWlkcyB0aGUgcGVuZGluZyBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XG5cbi8vIE1pbmltdW0gZGVsYXkgYmVmb3JlIGludm9raW5nIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLlxyXG52YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xyXG4vLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxyXG4vLyBtaWdodCBhZmZlY3QgZGltZW5zaW9ucyBvZiBvYnNlcnZlZCBlbGVtZW50cy5cclxudmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XHJcbi8vIENoZWNrIGlmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxyXG52YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgRE9NIGxpc3RlbmVycyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCA9IHRocm90dGxlKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcclxuICAgICAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cclxuICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGlmIGNvbnRyb2xsZXIgaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG4gICAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpZiBjaGFuZ2VzIGhhdmUgYmVlbiBkZXRlY3RlZCBhcyB0aGVyZSBtaWdodFxyXG4gICAgICAgIC8vIGJlIGZ1dHVyZSBvbmVzIGNhdXNlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XHJcbiAgICAgICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxyXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFyZSB0cmFja2luZyB0aGUgc2FtZSBlbGVtZW50IGFuZCB0aGUgY2FsbGJhY2sgb2Ygb25lXHJcbiAgICAgICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcclxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXHJcbiAgICAgICAgYWN0aXZlT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIHRvIHRoZSBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBmb3JcclxuICAgICAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXHJcbiAgICAgICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmRfID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc1JlZmxvd1Byb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhlIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xyXG59KCkpO1xuXG4vKipcclxuICogRGVmaW5lcyBub24td3JpdGFibGUvZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBwcm92aWRlZCB0YXJnZXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyB0byBiZSBkZWZpbmVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gKi9cclxudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IChmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59KTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXHJcbnZhciBnZXRXaW5kb3dPZiA9IChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XHJcbiAgICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cclxuICAgIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXHJcbiAgICAvLyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xyXG59KTtcblxuLy8gUGxhY2Vob2xkZXIgb2YgYW4gZW1wdHkgY29udGVudCByZWN0YW5nbGUuXHJcbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGJvcmRlcnMgc2l6ZSBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHBvc2l0aW9ucyAtIEJvcmRlcnMgcG9zaXRpb25zICh0b3AsIHJpZ2h0LCAuLi4pXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcG9zaXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xyXG4gICAgICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9LCAwKTtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XHJcbiAgICB2YXIgcGFkZGluZ3MgPSB7fTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1sncGFkZGluZy0nICsgcG9zaXRpb25dO1xyXG4gICAgICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhZGRpbmdzO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIFNWRyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkc1xyXG4gKiAgICAgIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXHJcbiAgICAvLyB1c2VkIGV4Y2x1c2l2ZWx5IGFzIHRoZXkgcHJvdmlkZSByb3VuZGVkIHZhbHVlcy5cclxuICAgIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgIC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxyXG4gICAgLy8gZGV0YWNoZWQgZWxlbWVudHMuIFRob3VnaCBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgbGVzc1xyXG4gICAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cclxuICAgIC8vXHJcbiAgICAvLyBXaXRob3V0IGl0IHdlIHdvdWxkIG5lZWQgdG8gaW1wbGVtZW50IHNlcGFyYXRlIG1ldGhvZHMgZm9yIGVhY2ggb2ZcclxuICAgIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcclxuICAgIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxyXG4gICAgLy8gZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBsZXNzIHRoYW4gMC41LlxyXG4gICAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcclxuICAgIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XHJcbiAgICB2YXIgaG9yaXpQYWQgPSBwYWRkaW5ncy5sZWZ0ICsgcGFkZGluZ3MucmlnaHQ7XHJcbiAgICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcclxuICAgIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxyXG4gICAgLy8gb25seSBkaW1lbnNpb25zIGF2YWlsYWJsZSB0byBKUyB0aGF0IGNvbnRhaW4gbm9uLXJvdW5kZWQgdmFsdWVzLiBJdCBjb3VsZFxyXG4gICAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxyXG4gICAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxyXG4gICAgdmFyIHdpZHRoID0gdG9GbG9hdChzdHlsZXMud2lkdGgpLCBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpO1xyXG4gICAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XHJcbiAgICAvLyBtb2RlbCBpcyBhcHBsaWVkIChleGNlcHQgZm9yIElFKS5cclxuICAgIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcclxuICAgICAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXHJcbiAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xyXG4gICAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxyXG4gICAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcclxuICAgIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cclxuICAgIGlmICghaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxyXG4gICAgICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXHJcbiAgICAgICAgLy8gYmFycyBhcmUgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHJvdW5kZWQgZGltZW5zaW9ucyArIHBhZGRpbmdzXHJcbiAgICAgICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cclxuICAgICAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXHJcbiAgICAgICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXHJcbiAgICAgICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcclxuICAgICAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cclxuICAgICAgICBpZiAoTWF0aC5hYnModmVydFNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFNWR0dyYXBoaWNzRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxudmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XHJcbiAgICAvLyBpbnRlcmZhY2UuXHJcbiAgICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7IH07XHJcbiAgICB9XHJcbiAgICAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJlxyXG4gICAgICAgIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyk7IH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0ID09PSBnZXRXaW5kb3dPZih0YXJnZXQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuICpcclxuICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcclxuICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xyXG4gICAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpO1xyXG4gICAgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cclxuICAgIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XHJcbiAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICB0b3A6IHksXHJcbiAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgICBib3R0b206IGhlaWdodCArIHksXHJcbiAgICAgICAgbGVmdDogeFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVjdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxufVxuXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtET01SZWN0SW5pdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIChyZWN0LndpZHRoICE9PSB0aGlzLmJyb2FkY2FzdFdpZHRoIHx8XHJcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICE9PSB0aGlzLmJyb2FkY2FzdEhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRoYXQgaXMgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJFbnRyeSh0YXJnZXQsIHJlY3RJbml0KSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxyXG4gICAgICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxyXG4gICAgICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxyXG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7IHRhcmdldDogdGFyZ2V0LCBjb250ZW50UmVjdDogY29udGVudFJlY3QgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyU1BJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn0gY29udHJvbGxlciAtIENvbnRyb2xsZXIgaW5zdGFuY2Ugd2hpY2hcclxuICAgICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAgICogICAgICBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0cnkgb2YgdGhlIFJlc2l6ZU9ic2VydmF0aW9uIGluc3RhbmNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXyA9IG5ldyBNYXBTaGltKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmIChvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBhbGwgZWxlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgICAqIGl0J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbi5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICogaW5zdGFuY2VzIGNvbGxlY3RlZCBmcm9tIGFjdGl2ZSByZXNpemUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xyXG4gICAgICAgIC8vIENyZWF0ZSBSZXNpemVPYnNlcnZlckVudHJ5IGluc3RhbmNlIGZvciBldmVyeSBhY3RpdmUgb2JzZXJ2YXRpb24uXHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubWFwKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY29sbGVjdGlvbiBvZiBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcclxufSgpKTtcblxuLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxyXG4vLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXHJcbi8vIGNhbid0IGJlIGZ1bGx5IHBvbHlmaWxsZWQgYW55d2F5LlxyXG52YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XHJcbi8qKlxyXG4gKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCB0aGlzKTtcclxuICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSgpKTtcclxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5bXHJcbiAgICAnb2JzZXJ2ZScsXHJcbiAgICAndW5vYnNlcnZlJyxcclxuICAgICdkaXNjb25uZWN0J1xyXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSBvYnNlcnZlcnMuZ2V0KHRoaXMpKVttZXRob2RdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBpbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiaW1wb3J0IGNhblVzZURPTSBmcm9tICdjYW4tdXNlLWRvbSc7XG5cbmxldCBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IG51bGw7XG5sZXQgY2FjaGVkRGV2aWNlUGl4ZWxSYXRpbyA9IG51bGw7XG5cbmlmIChjYW5Vc2VET00pIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICBpZiAoY2FjaGVkRGV2aWNlUGl4ZWxSYXRpbyAhPT0gd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgIGNhY2hlZERldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzY3JvbGxiYXJXaWR0aCgpIHtcbiAgaWYgKGNhY2hlZFNjcm9sbGJhcldpZHRoID09PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gMDtcbiAgICAgIHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGJveC5jbGFzc0xpc3QuYWRkKCdzaW1wbGViYXItaGlkZS1zY3JvbGxiYXInKTtcblxuICAgIGJvZHkuYXBwZW5kQ2hpbGQoYm94KTtcblxuICAgIGNvbnN0IHdpZHRoID0gYm94LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0O1xuXG4gICAgYm9keS5yZW1vdmVDaGlsZChib3gpO1xuXG4gICAgY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcbn1cbiIsIi8vIEhlbHBlciBmdW5jdGlvbiB0byByZXRyaWV2ZSBvcHRpb25zIGZyb20gZWxlbWVudCBhdHRyaWJ1dGVzXG5leHBvcnQgY29uc3QgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9iaikge1xuICBjb25zdCBvcHRpb25zID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKFxuICAgIG9iaixcbiAgICAoYWNjLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbiA9IGF0dHJpYnV0ZS5uYW1lLm1hdGNoKC9kYXRhLXNpbXBsZWJhci0oLispLyk7XG4gICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG9wdGlvblsxXS5yZXBsYWNlKC9cXFcrKC4pL2csICh4LCBjaHIpID0+IGNoci50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGUudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgIGFjY1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIGFjY1trZXldID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIGFjY1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRXaW5kb3coZWxlbWVudCkge1xuICBpZiAoXG4gICAgIWVsZW1lbnQgfHxcbiAgICAhZWxlbWVudC5vd25lckRvY3VtZW50IHx8XG4gICAgIWVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xuICApIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50RG9jdW1lbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQub3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuIiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC50aHJvdHRsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuaW1wb3J0IGNhblVzZURPTSBmcm9tICdjYW4tdXNlLWRvbSc7XG5pbXBvcnQgc2Nyb2xsYmFyV2lkdGggZnJvbSAnLi9zY3JvbGxiYXItd2lkdGgnO1xuaW1wb3J0IHsgZ2V0RWxlbWVudFdpbmRvdywgZ2V0RWxlbWVudERvY3VtZW50IH0gZnJvbSAnLi9oZWxwZXJzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlQmFyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuZWwgPSBlbGVtZW50O1xuICAgIHRoaXMubWluU2Nyb2xsYmFyV2lkdGggPSAyMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLlNpbXBsZUJhci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IHtcbiAgICAgIC4uLlNpbXBsZUJhci5kZWZhdWx0T3B0aW9ucy5jbGFzc05hbWVzLFxuICAgICAgLi4udGhpcy5vcHRpb25zLmNsYXNzTmFtZXNcbiAgICB9O1xuICAgIHRoaXMuYXhpcyA9IHtcbiAgICAgIHg6IHtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0QXR0cjogJ3Njcm9sbExlZnQnLFxuICAgICAgICBzaXplQXR0cjogJ3dpZHRoJyxcbiAgICAgICAgc2Nyb2xsU2l6ZUF0dHI6ICdzY3JvbGxXaWR0aCcsXG4gICAgICAgIG9mZnNldFNpemVBdHRyOiAnb2Zmc2V0V2lkdGgnLFxuICAgICAgICBvZmZzZXRBdHRyOiAnbGVmdCcsXG4gICAgICAgIG92ZXJmbG93QXR0cjogJ292ZXJmbG93WCcsXG4gICAgICAgIGRyYWdPZmZzZXQ6IDAsXG4gICAgICAgIGlzT3ZlcmZsb3dpbmc6IHRydWUsXG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIGZvcmNlVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIHRyYWNrOiB7fSxcbiAgICAgICAgc2Nyb2xsYmFyOiB7fVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0QXR0cjogJ3Njcm9sbFRvcCcsXG4gICAgICAgIHNpemVBdHRyOiAnaGVpZ2h0JyxcbiAgICAgICAgc2Nyb2xsU2l6ZUF0dHI6ICdzY3JvbGxIZWlnaHQnLFxuICAgICAgICBvZmZzZXRTaXplQXR0cjogJ29mZnNldEhlaWdodCcsXG4gICAgICAgIG9mZnNldEF0dHI6ICd0b3AnLFxuICAgICAgICBvdmVyZmxvd0F0dHI6ICdvdmVyZmxvd1knLFxuICAgICAgICBkcmFnT2Zmc2V0OiAwLFxuICAgICAgICBpc092ZXJmbG93aW5nOiB0cnVlLFxuICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICBmb3JjZVZpc2libGU6IGZhbHNlLFxuICAgICAgICB0cmFjazoge30sXG4gICAgICAgIHNjcm9sbGJhcjoge31cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPSBudWxsO1xuXG4gICAgLy8gRG9uJ3QgcmUtaW5zdGFudGlhdGUgb3ZlciBhbiBleGlzdGluZyBvbmVcbiAgICBpZiAoU2ltcGxlQmFyLmluc3RhbmNlcy5oYXModGhpcy5lbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlID0gdGhyb3R0bGUodGhpcy5yZWNhbGN1bGF0ZS5iaW5kKHRoaXMpLCA2NCk7XG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRocm90dGxlKHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSwgNjQpO1xuICAgIHRoaXMuaGlkZVNjcm9sbGJhcnMgPSBkZWJvdW5jZShcbiAgICAgIHRoaXMuaGlkZVNjcm9sbGJhcnMuYmluZCh0aGlzKSxcbiAgICAgIHRoaXMub3B0aW9ucy50aW1lb3V0XG4gICAgKTtcbiAgICB0aGlzLm9uV2luZG93UmVzaXplID0gZGVib3VuY2UodGhpcy5vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpLCA2NCwge1xuICAgICAgbGVhZGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMgPSBtZW1vaXplKFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZml4IGJyb3dzZXJzIGluY29uc2lzdGVuY3kgb24gUlRMOlxuICAgKiAgLSBGaXJlZm94IGludmVydHMgdGhlIHNjcm9sbGJhciBpbml0aWFsIHBvc2l0aW9uXG4gICAqICAtIElFMTEgaW52ZXJ0cyBib3RoIHNjcm9sbGJhciBwb3NpdGlvbiBhbmQgc2Nyb2xsaW5nIG9mZnNldFxuICAgKiBEaXJlY3RseSBpbnNwaXJlZCBieSBAS2luZ1NvcmEncyBPdmVybGF5U2Nyb2xsYmFycyBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnMvYmxvYi9tYXN0ZXIvanMvT3ZlcmxheVNjcm9sbGJhcnMuanMjTDE2MzRcbiAgICovXG4gIHN0YXRpYyBnZXRSdGxIZWxwZXJzKCkge1xuICAgIGNvbnN0IGR1bW15RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHVtbXlEaXYuaW5uZXJIVE1MID1cbiAgICAgICc8ZGl2IGNsYXNzPVwiaHMtZHVtbXktc2Nyb2xsYmFyLXNpemVcIj48ZGl2IHN0eWxlPVwiaGVpZ2h0OiAyMDAlOyB3aWR0aDogMjAwJTsgbWFyZ2luOiAxMHB4IDA7XCI+PC9kaXY+PC9kaXY+JztcbiAgICBjb25zdCBzY3JvbGxiYXJEdW1teUVsID0gZHVtbXlEaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxiYXJEdW1teUVsKTtcbiAgICBjb25zdCBkdW1teUNvbnRhaW5lckNoaWxkID0gc2Nyb2xsYmFyRHVtbXlFbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICBzY3JvbGxiYXJEdW1teUVsLnNjcm9sbExlZnQgPSAwO1xuICAgIGNvbnN0IGR1bW15Q29udGFpbmVyT2Zmc2V0ID0gU2ltcGxlQmFyLmdldE9mZnNldChzY3JvbGxiYXJEdW1teUVsKTtcbiAgICBjb25zdCBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0ID0gU2ltcGxlQmFyLmdldE9mZnNldChkdW1teUNvbnRhaW5lckNoaWxkKTtcbiAgICBzY3JvbGxiYXJEdW1teUVsLnNjcm9sbExlZnQgPSA5OTk7XG4gICAgY29uc3QgZHVtbXlDb250YWluZXJTY3JvbGxPZmZzZXRBZnRlclNjcm9sbCA9IFNpbXBsZUJhci5nZXRPZmZzZXQoXG4gICAgICBkdW1teUNvbnRhaW5lckNoaWxkXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBkZXRlcm1pbmVzIGlmIHRoZSBzY3JvbGxpbmcgaXMgcmVzcG9uZGluZyB3aXRoIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgaXNSdGxTY3JvbGxpbmdJbnZlcnRlZDpcbiAgICAgICAgZHVtbXlDb250YWluZXJPZmZzZXQubGVmdCAhPT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0ICYmXG4gICAgICAgIGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQubGVmdCAtXG4gICAgICAgICAgZHVtbXlDb250YWluZXJTY3JvbGxPZmZzZXRBZnRlclNjcm9sbC5sZWZ0ICE9PVxuICAgICAgICAgIDAsXG4gICAgICAvLyBkZXRlcm1pbmVzIGlmIHRoZSBvcmlnaW4gc2Nyb2xsYmFyIHBvc2l0aW9uIGlzIGludmVydGVkIG9yIG5vdCAocG9zaXRpb25lZCBvbiBsZWZ0IG9yIHJpZ2h0KVxuICAgICAgaXNSdGxTY3JvbGxiYXJJbnZlcnRlZDpcbiAgICAgICAgZHVtbXlDb250YWluZXJPZmZzZXQubGVmdCAhPT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBhdXRvSGlkZTogdHJ1ZSxcbiAgICBmb3JjZVZpc2libGU6IGZhbHNlLFxuICAgIGNsaWNrT25UcmFjazogdHJ1ZSxcbiAgICBjbGFzc05hbWVzOiB7XG4gICAgICBjb250ZW50RWw6ICdzaW1wbGViYXItY29udGVudCcsXG4gICAgICBjb250ZW50V3JhcHBlcjogJ3NpbXBsZWJhci1jb250ZW50LXdyYXBwZXInLFxuICAgICAgb2Zmc2V0OiAnc2ltcGxlYmFyLW9mZnNldCcsXG4gICAgICBtYXNrOiAnc2ltcGxlYmFyLW1hc2snLFxuICAgICAgd3JhcHBlcjogJ3NpbXBsZWJhci13cmFwcGVyJyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnc2ltcGxlYmFyLXBsYWNlaG9sZGVyJyxcbiAgICAgIHNjcm9sbGJhcjogJ3NpbXBsZWJhci1zY3JvbGxiYXInLFxuICAgICAgdHJhY2s6ICdzaW1wbGViYXItdHJhY2snLFxuICAgICAgaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsOiAnc2ltcGxlYmFyLWhlaWdodC1hdXRvLW9ic2VydmVyLXdyYXBwZXInLFxuICAgICAgaGVpZ2h0QXV0b09ic2VydmVyRWw6ICdzaW1wbGViYXItaGVpZ2h0LWF1dG8tb2JzZXJ2ZXInLFxuICAgICAgdmlzaWJsZTogJ3NpbXBsZWJhci12aXNpYmxlJyxcbiAgICAgIGhvcml6b250YWw6ICdzaW1wbGViYXItaG9yaXpvbnRhbCcsXG4gICAgICB2ZXJ0aWNhbDogJ3NpbXBsZWJhci12ZXJ0aWNhbCcsXG4gICAgICBob3ZlcjogJ3NpbXBsZWJhci1ob3ZlcicsXG4gICAgICBkcmFnZ2luZzogJ3NpbXBsZWJhci1kcmFnZ2luZydcbiAgICB9LFxuICAgIHNjcm9sbGJhck1pblNpemU6IDI1LFxuICAgIHNjcm9sbGJhck1heFNpemU6IDAsXG4gICAgdGltZW91dDogMTAwMFxuICB9O1xuXG4gIHN0YXRpYyBnZXRPZmZzZXQoZWwpIHtcbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZWxEb2N1bWVudCA9IGdldEVsZW1lbnREb2N1bWVudChlbCk7XG4gICAgY29uc3QgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KGVsKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6XG4gICAgICAgIHJlY3QudG9wICtcbiAgICAgICAgKGVsV2luZG93LnBhZ2VZT2Zmc2V0IHx8IGVsRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICBsZWZ0OlxuICAgICAgICByZWN0LmxlZnQgK1xuICAgICAgICAoZWxXaW5kb3cucGFnZVhPZmZzZXQgfHwgZWxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdClcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGluc3RhbmNlcyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSwgc28gd2Uga25vdyB0aGlzIERPTSBub2RlIGhhcyBhbHJlYWR5IGJlZW4gaW5zdGFuY2llZFxuICAgIFNpbXBsZUJhci5pbnN0YW5jZXMuc2V0KHRoaXMuZWwsIHRoaXMpO1xuXG4gICAgLy8gV2Ugc3RvcCBoZXJlIG9uIHNlcnZlci1zaWRlXG4gICAgaWYgKGNhblVzZURPTSkge1xuICAgICAgdGhpcy5pbml0RE9NKCk7XG5cbiAgICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFNjcm9sbGJhcldpZHRoKCk7XG5cbiAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcblxuICAgICAgdGhpcy5pbml0TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdERPTSgpIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhpcyBlbGVtZW50IGRvZXNuJ3QgaGF2ZSB0aGUgZWxlbWVudHMgeWV0XG4gICAgaWYgKFxuICAgICAgQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuZWwuY2hpbGRyZW4sIGNoaWxkID0+XG4gICAgICAgIGNoaWxkLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNsYXNzTmFtZXMud3JhcHBlcilcbiAgICAgICkubGVuZ3RoXG4gICAgKSB7XG4gICAgICAvLyBhc3N1bWUgdGhhdCBlbGVtZW50IGhhcyBoaXMgRE9NIGFscmVhZHkgaW5pdGlhdGVkXG4gICAgICB0aGlzLndyYXBwZXJFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5jbGFzc05hbWVzLndyYXBwZXJ9YCk7XG4gICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwgPVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZU5vZGUgfHxcbiAgICAgICAgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNsYXNzTmFtZXMuY29udGVudFdyYXBwZXJ9YCk7XG4gICAgICB0aGlzLmNvbnRlbnRFbCA9XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb250ZW50Tm9kZSB8fFxuICAgICAgICB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuY2xhc3NOYW1lcy5jb250ZW50RWx9YCk7XG5cbiAgICAgIHRoaXMub2Zmc2V0RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuY2xhc3NOYW1lcy5vZmZzZXR9YCk7XG4gICAgICB0aGlzLm1hc2tFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5jbGFzc05hbWVzLm1hc2t9YCk7XG5cbiAgICAgIHRoaXMucGxhY2Vob2xkZXJFbCA9IHRoaXMuZmluZENoaWxkKFxuICAgICAgICB0aGlzLndyYXBwZXJFbCxcbiAgICAgICAgYC4ke3RoaXMuY2xhc3NOYW1lcy5wbGFjZWhvbGRlcn1gXG4gICAgICApO1xuICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIGAuJHt0aGlzLmNsYXNzTmFtZXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsfWBcbiAgICAgICk7XG4gICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlckVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgLiR7dGhpcy5jbGFzc05hbWVzLmhlaWdodEF1dG9PYnNlcnZlckVsfWBcbiAgICAgICk7XG4gICAgICB0aGlzLmF4aXMueC50cmFjay5lbCA9IHRoaXMuZmluZENoaWxkKFxuICAgICAgICB0aGlzLmVsLFxuICAgICAgICBgLiR7dGhpcy5jbGFzc05hbWVzLnRyYWNrfS4ke3RoaXMuY2xhc3NOYW1lcy5ob3Jpem9udGFsfWBcbiAgICAgICk7XG4gICAgICB0aGlzLmF4aXMueS50cmFjay5lbCA9IHRoaXMuZmluZENoaWxkKFxuICAgICAgICB0aGlzLmVsLFxuICAgICAgICBgLiR7dGhpcy5jbGFzc05hbWVzLnRyYWNrfS4ke3RoaXMuY2xhc3NOYW1lcy52ZXJ0aWNhbH1gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcmVwYXJlIERPTVxuICAgICAgdGhpcy53cmFwcGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vZmZzZXRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5tYXNrRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY29udGVudEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLnBsYWNlaG9sZGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIHRoaXMud3JhcHBlckVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLndyYXBwZXIpO1xuICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmNvbnRlbnRXcmFwcGVyKTtcbiAgICAgIHRoaXMub2Zmc2V0RWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMub2Zmc2V0KTtcbiAgICAgIHRoaXMubWFza0VsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLm1hc2spO1xuICAgICAgdGhpcy5jb250ZW50RWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuY29udGVudEVsKTtcbiAgICAgIHRoaXMucGxhY2Vob2xkZXJFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5wbGFjZWhvbGRlcik7XG4gICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbC5jbGFzc0xpc3QuYWRkKFxuICAgICAgICB0aGlzLmNsYXNzTmFtZXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsXG4gICAgICApO1xuICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbC5jbGFzc0xpc3QuYWRkKFxuICAgICAgICB0aGlzLmNsYXNzTmFtZXMuaGVpZ2h0QXV0b09ic2VydmVyRWxcbiAgICAgICk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsKTtcbiAgICAgIHRoaXMub2Zmc2V0RWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50V3JhcHBlckVsKTtcbiAgICAgIHRoaXMubWFza0VsLmFwcGVuZENoaWxkKHRoaXMub2Zmc2V0RWwpO1xuICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbCk7XG4gICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbCk7XG4gICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLm1hc2tFbCk7XG4gICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLnBsYWNlaG9sZGVyRWwpO1xuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXJFbCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmF4aXMueC50cmFjay5lbCB8fCAhdGhpcy5heGlzLnkudHJhY2suZWwpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCBzY3JvbGxiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgdHJhY2suY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMudHJhY2spO1xuICAgICAgc2Nyb2xsYmFyLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cbiAgICAgIHRyYWNrLmFwcGVuZENoaWxkKHNjcm9sbGJhcik7XG5cbiAgICAgIHRoaXMuYXhpcy54LnRyYWNrLmVsID0gdHJhY2suY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdGhpcy5heGlzLngudHJhY2suZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuaG9yaXpvbnRhbCk7XG5cbiAgICAgIHRoaXMuYXhpcy55LnRyYWNrLmVsID0gdHJhY2suY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdGhpcy5heGlzLnkudHJhY2suZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMudmVydGljYWwpO1xuXG4gICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuYXhpcy54LnRyYWNrLmVsKTtcbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5heGlzLnkudHJhY2suZWwpO1xuICAgIH1cblxuICAgIHRoaXMuYXhpcy54LnNjcm9sbGJhci5lbCA9IHRoaXMuYXhpcy54LnRyYWNrLmVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBgLiR7dGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcn1gXG4gICAgKTtcbiAgICB0aGlzLmF4aXMueS5zY3JvbGxiYXIuZWwgPSB0aGlzLmF4aXMueS50cmFjay5lbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgYC4ke3RoaXMuY2xhc3NOYW1lcy5zY3JvbGxiYXJ9YFxuICAgICk7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5hdXRvSGlkZSkge1xuICAgICAgdGhpcy5heGlzLnguc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuICAgICAgdGhpcy5heGlzLnkuc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuICAgIH1cblxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLXNpbXBsZWJhcicsICdpbml0Jyk7XG4gIH1cblxuICBpbml0TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyh0aGlzLmVsKTtcbiAgICAvLyBFdmVudCBsaXN0ZW5lcnNcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IaWRlKSB7XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG4gICAgfVxuXG4gICAgWydtb3VzZWRvd24nLCAnY2xpY2snLCAnZGJsY2xpY2snXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGUsIHRoaXMub25Qb2ludGVyRXZlbnQsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgdGhpcy5vblBvaW50ZXJFdmVudCwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuXG4gICAgdGhpcy5jb250ZW50V3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwpO1xuXG4gICAgLy8gQnJvd3NlciB6b29tIHRyaWdnZXJzIGEgd2luZG93IHJlc2l6ZVxuICAgIGVsV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemUpO1xuXG4gICAgLy8gSGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvUmVzaXplT2JzZXJ2ZXIvaXNzdWVzLzM4XG4gICAgbGV0IHJlc2l6ZU9ic2VydmVyU3RhcnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gZWxXaW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgUmVzaXplT2JzZXJ2ZXI7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyByZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBpZiAoIXJlc2l6ZU9ic2VydmVyU3RhcnRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNvbnRlbnRFbCk7XG5cbiAgICBlbFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgcmVzaXplT2JzZXJ2ZXJTdGFydGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gZGV0ZWN0IGhvcml6b250YWwgc2Nyb2xsLiBWZXJ0aWNhbCBzY3JvbGwgb25seSBuZWVkcyB0aGUgcmVzaXplT2JzZXJ2ZXIuXG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IGVsV2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWNhbGN1bGF0ZSk7XG5cbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNvbnRlbnRFbCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlY2FsY3VsYXRlKCkge1xuICAgIGNvbnN0IGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyh0aGlzLmVsKTtcbiAgICB0aGlzLmVsU3R5bGVzID0gZWxXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKTtcbiAgICB0aGlzLmlzUnRsID0gdGhpcy5lbFN0eWxlcy5kaXJlY3Rpb24gPT09ICdydGwnO1xuXG4gICAgY29uc3QgY29udGVudEVsT2Zmc2V0V2lkdGggPSB0aGlzLmNvbnRlbnRFbC5vZmZzZXRXaWR0aDtcblxuICAgIGNvbnN0IGlzSGVpZ2h0QXV0byA9IHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyRWwub2Zmc2V0SGVpZ2h0IDw9IDE7XG4gICAgY29uc3QgaXNXaWR0aEF1dG8gPVxuICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbC5vZmZzZXRXaWR0aCA8PSAxIHx8IGNvbnRlbnRFbE9mZnNldFdpZHRoID4gMDtcblxuICAgIGNvbnN0IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRXaWR0aCA9IHRoaXMuY29udGVudFdyYXBwZXJFbC5vZmZzZXRXaWR0aDtcblxuICAgIGNvbnN0IGVsT3ZlcmZsb3dYID0gdGhpcy5lbFN0eWxlcy5vdmVyZmxvd1g7XG4gICAgY29uc3QgZWxPdmVyZmxvd1kgPSB0aGlzLmVsU3R5bGVzLm92ZXJmbG93WTtcblxuICAgIHRoaXMuY29udGVudEVsLnN0eWxlLnBhZGRpbmcgPSBgJHt0aGlzLmVsU3R5bGVzLnBhZGRpbmdUb3B9ICR7dGhpcy5lbFN0eWxlcy5wYWRkaW5nUmlnaHR9ICR7dGhpcy5lbFN0eWxlcy5wYWRkaW5nQm90dG9tfSAke3RoaXMuZWxTdHlsZXMucGFkZGluZ0xlZnR9YDtcbiAgICB0aGlzLndyYXBwZXJFbC5zdHlsZS5tYXJnaW4gPSBgLSR7dGhpcy5lbFN0eWxlcy5wYWRkaW5nVG9wfSAtJHt0aGlzLmVsU3R5bGVzLnBhZGRpbmdSaWdodH0gLSR7dGhpcy5lbFN0eWxlcy5wYWRkaW5nQm90dG9tfSAtJHt0aGlzLmVsU3R5bGVzLnBhZGRpbmdMZWZ0fWA7XG5cbiAgICBjb25zdCBjb250ZW50RWxTY3JvbGxIZWlnaHQgPSB0aGlzLmNvbnRlbnRFbC5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgY29udGVudEVsU2Nyb2xsV2lkdGggPSB0aGlzLmNvbnRlbnRFbC5zY3JvbGxXaWR0aDtcblxuICAgIHRoaXMuY29udGVudFdyYXBwZXJFbC5zdHlsZS5oZWlnaHQgPSBpc0hlaWdodEF1dG8gPyAnYXV0bycgOiAnMTAwJSc7XG5cbiAgICAvLyBEZXRlcm1pbmUgcGxhY2Vob2xkZXIgc2l6ZVxuICAgIHRoaXMucGxhY2Vob2xkZXJFbC5zdHlsZS53aWR0aCA9IGlzV2lkdGhBdXRvXG4gICAgICA/IGAke2NvbnRlbnRFbE9mZnNldFdpZHRoIHx8IGNvbnRlbnRFbFNjcm9sbFdpZHRofXB4YFxuICAgICAgOiAnYXV0byc7XG4gICAgdGhpcy5wbGFjZWhvbGRlckVsLnN0eWxlLmhlaWdodCA9IGAke2NvbnRlbnRFbFNjcm9sbEhlaWdodH1weGA7XG5cbiAgICBjb25zdCBjb250ZW50V3JhcHBlckVsT2Zmc2V0SGVpZ2h0ID0gdGhpcy5jb250ZW50V3JhcHBlckVsLm9mZnNldEhlaWdodDtcblxuICAgIHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgPVxuICAgICAgY29udGVudEVsT2Zmc2V0V2lkdGggIT09IDAgJiYgY29udGVudEVsU2Nyb2xsV2lkdGggPiBjb250ZW50RWxPZmZzZXRXaWR0aDtcbiAgICB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nID1cbiAgICAgIGNvbnRlbnRFbFNjcm9sbEhlaWdodCA+IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBTZXQgaXNPdmVyZmxvd2luZyB0byBmYWxzZSBpZiB1c2VyIGV4cGxpY2l0ZWx5IHNldCBoaWRkZW4gb3ZlcmZsb3dcbiAgICB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nID1cbiAgICAgIGVsT3ZlcmZsb3dYID09PSAnaGlkZGVuJyA/IGZhbHNlIDogdGhpcy5heGlzLnguaXNPdmVyZmxvd2luZztcbiAgICB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nID1cbiAgICAgIGVsT3ZlcmZsb3dZID09PSAnaGlkZGVuJyA/IGZhbHNlIDogdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZztcblxuICAgIHRoaXMuYXhpcy54LmZvcmNlVmlzaWJsZSA9XG4gICAgICB0aGlzLm9wdGlvbnMuZm9yY2VWaXNpYmxlID09PSAneCcgfHwgdGhpcy5vcHRpb25zLmZvcmNlVmlzaWJsZSA9PT0gdHJ1ZTtcbiAgICB0aGlzLmF4aXMueS5mb3JjZVZpc2libGUgPVxuICAgICAgdGhpcy5vcHRpb25zLmZvcmNlVmlzaWJsZSA9PT0gJ3knIHx8IHRoaXMub3B0aW9ucy5mb3JjZVZpc2libGUgPT09IHRydWU7XG5cbiAgICB0aGlzLmhpZGVOYXRpdmVTY3JvbGxiYXIoKTtcblxuICAgIC8vIFNldCBpc092ZXJmbG93aW5nIHRvIGZhbHNlIGlmIHNjcm9sbGJhciBpcyBub3QgbmVjZXNzYXJ5IChjb250ZW50IGlzIHNob3J0ZXIgdGhhbiBvZmZzZXQpXG4gICAgbGV0IG9mZnNldEZvclhTY3JvbGxiYXIgPSB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nXG4gICAgICA/IHRoaXMuc2Nyb2xsYmFyV2lkdGhcbiAgICAgIDogMDtcbiAgICBsZXQgb2Zmc2V0Rm9yWVNjcm9sbGJhciA9IHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmdcbiAgICAgID8gdGhpcy5zY3JvbGxiYXJXaWR0aFxuICAgICAgOiAwO1xuXG4gICAgdGhpcy5heGlzLnguaXNPdmVyZmxvd2luZyA9XG4gICAgICB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nICYmXG4gICAgICBjb250ZW50RWxTY3JvbGxXaWR0aCA+IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRXaWR0aCAtIG9mZnNldEZvcllTY3JvbGxiYXI7XG4gICAgdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyA9XG4gICAgICB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nICYmXG4gICAgICBjb250ZW50RWxTY3JvbGxIZWlnaHQgPlxuICAgICAgICBjb250ZW50V3JhcHBlckVsT2Zmc2V0SGVpZ2h0IC0gb2Zmc2V0Rm9yWFNjcm9sbGJhcjtcblxuICAgIHRoaXMuYXhpcy54LnNjcm9sbGJhci5zaXplID0gdGhpcy5nZXRTY3JvbGxiYXJTaXplKCd4Jyk7XG4gICAgdGhpcy5heGlzLnkuc2Nyb2xsYmFyLnNpemUgPSB0aGlzLmdldFNjcm9sbGJhclNpemUoJ3knKTtcblxuICAgIHRoaXMuYXhpcy54LnNjcm9sbGJhci5lbC5zdHlsZS53aWR0aCA9IGAke3RoaXMuYXhpcy54LnNjcm9sbGJhci5zaXplfXB4YDtcbiAgICB0aGlzLmF4aXMueS5zY3JvbGxiYXIuZWwuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5heGlzLnkuc2Nyb2xsYmFyLnNpemV9cHhgO1xuXG4gICAgdGhpcy5wb3NpdGlvblNjcm9sbGJhcigneCcpO1xuICAgIHRoaXMucG9zaXRpb25TY3JvbGxiYXIoJ3knKTtcblxuICAgIHRoaXMudG9nZ2xlVHJhY2tWaXNpYmlsaXR5KCd4Jyk7XG4gICAgdGhpcy50b2dnbGVUcmFja1Zpc2liaWxpdHkoJ3knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgc2Nyb2xsYmFyIHNpemVcbiAgICovXG4gIGdldFNjcm9sbGJhclNpemUoYXhpcyA9ICd5Jykge1xuICAgIGlmICghdGhpcy5heGlzW2F4aXNdLmlzT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnRTaXplID0gdGhpcy5jb250ZW50RWxbdGhpcy5heGlzW2F4aXNdLnNjcm9sbFNpemVBdHRyXTtcbiAgICBjb25zdCB0cmFja1NpemUgPSB0aGlzLmF4aXNbYXhpc10udHJhY2suZWxbdGhpcy5heGlzW2F4aXNdLm9mZnNldFNpemVBdHRyXTtcbiAgICBsZXQgc2Nyb2xsYmFyU2l6ZTtcblxuICAgIGxldCBzY3JvbGxiYXJSYXRpbyA9IHRyYWNrU2l6ZSAvIGNvbnRlbnRTaXplO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5ldyBoZWlnaHQvcG9zaXRpb24gb2YgZHJhZyBoYW5kbGUuXG4gICAgc2Nyb2xsYmFyU2l6ZSA9IE1hdGgubWF4KFxuICAgICAgfn4oc2Nyb2xsYmFyUmF0aW8gKiB0cmFja1NpemUpLFxuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbGJhck1pblNpemVcbiAgICApO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxiYXJNYXhTaXplKSB7XG4gICAgICBzY3JvbGxiYXJTaXplID0gTWF0aC5taW4oc2Nyb2xsYmFyU2l6ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhck1heFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JvbGxiYXJTaXplO1xuICB9XG5cbiAgcG9zaXRpb25TY3JvbGxiYXIoYXhpcyA9ICd5Jykge1xuICAgIGlmICghdGhpcy5heGlzW2F4aXNdLmlzT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IHRoaXMuY29udGVudFdyYXBwZXJFbFt0aGlzLmF4aXNbYXhpc10uc2Nyb2xsU2l6ZUF0dHJdO1xuICAgIGNvbnN0IHRyYWNrU2l6ZSA9IHRoaXMuYXhpc1theGlzXS50cmFjay5lbFt0aGlzLmF4aXNbYXhpc10ub2Zmc2V0U2l6ZUF0dHJdO1xuICAgIGNvbnN0IGhvc3RTaXplID0gcGFyc2VJbnQodGhpcy5lbFN0eWxlc1t0aGlzLmF4aXNbYXhpc10uc2l6ZUF0dHJdLCAxMCk7XG4gICAgY29uc3Qgc2Nyb2xsYmFyID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhcjtcblxuICAgIGxldCBzY3JvbGxPZmZzZXQgPSB0aGlzLmNvbnRlbnRXcmFwcGVyRWxbdGhpcy5heGlzW2F4aXNdLnNjcm9sbE9mZnNldEF0dHJdO1xuICAgIHNjcm9sbE9mZnNldCA9XG4gICAgICBheGlzID09PSAneCcgJiZcbiAgICAgIHRoaXMuaXNSdGwgJiZcbiAgICAgIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKCkuaXNSdGxTY3JvbGxpbmdJbnZlcnRlZFxuICAgICAgICA/IC1zY3JvbGxPZmZzZXRcbiAgICAgICAgOiBzY3JvbGxPZmZzZXQ7XG4gICAgbGV0IHNjcm9sbFBvdXJjZW50ID0gc2Nyb2xsT2Zmc2V0IC8gKGNvbnRlbnRTaXplIC0gaG9zdFNpemUpO1xuXG4gICAgbGV0IGhhbmRsZU9mZnNldCA9IH5+KCh0cmFja1NpemUgLSBzY3JvbGxiYXIuc2l6ZSkgKiBzY3JvbGxQb3VyY2VudCk7XG4gICAgaGFuZGxlT2Zmc2V0ID1cbiAgICAgIGF4aXMgPT09ICd4JyAmJlxuICAgICAgdGhpcy5pc1J0bCAmJlxuICAgICAgU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMoKS5pc1J0bFNjcm9sbGJhckludmVydGVkXG4gICAgICAgID8gaGFuZGxlT2Zmc2V0ICsgKHRyYWNrU2l6ZSAtIHNjcm9sbGJhci5zaXplKVxuICAgICAgICA6IGhhbmRsZU9mZnNldDtcblxuICAgIHNjcm9sbGJhci5lbC5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgYXhpcyA9PT0gJ3gnXG4gICAgICAgID8gYHRyYW5zbGF0ZTNkKCR7aGFuZGxlT2Zmc2V0fXB4LCAwLCAwKWBcbiAgICAgICAgOiBgdHJhbnNsYXRlM2QoMCwgJHtoYW5kbGVPZmZzZXR9cHgsIDApYDtcbiAgfVxuXG4gIHRvZ2dsZVRyYWNrVmlzaWJpbGl0eShheGlzID0gJ3knKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmF4aXNbYXhpc10udHJhY2suZWw7XG4gICAgY29uc3Qgc2Nyb2xsYmFyID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbDtcblxuICAgIGlmICh0aGlzLmF4aXNbYXhpc10uaXNPdmVyZmxvd2luZyB8fCB0aGlzLmF4aXNbYXhpc10uZm9yY2VWaXNpYmxlKSB7XG4gICAgICB0cmFjay5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnN0eWxlW3RoaXMuYXhpc1theGlzXS5vdmVyZmxvd0F0dHJdID0gJ3Njcm9sbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbC5zdHlsZVt0aGlzLmF4aXNbYXhpc10ub3ZlcmZsb3dBdHRyXSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIC8vIEV2ZW4gaWYgZm9yY2VWaXNpYmxlIGlzIGVuYWJsZWQsIHNjcm9sbGJhciBpdHNlbGYgc2hvdWxkIGJlIGhpZGRlblxuICAgIGlmICh0aGlzLmF4aXNbYXhpc10uaXNPdmVyZmxvd2luZykge1xuICAgICAgc2Nyb2xsYmFyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxiYXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gIH1cblxuICBoaWRlTmF0aXZlU2Nyb2xsYmFyKCkge1xuICAgIHRoaXMub2Zmc2V0RWwuc3R5bGVbdGhpcy5pc1J0bCA/ICdsZWZ0JyA6ICdyaWdodCddID1cbiAgICAgIHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgfHwgdGhpcy5heGlzLnkuZm9yY2VWaXNpYmxlXG4gICAgICAgID8gYC0ke3RoaXMuc2Nyb2xsYmFyV2lkdGh9cHhgXG4gICAgICAgIDogMDtcbiAgICB0aGlzLm9mZnNldEVsLnN0eWxlLmJvdHRvbSA9XG4gICAgICB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nIHx8IHRoaXMuYXhpcy54LmZvcmNlVmlzaWJsZVxuICAgICAgICA/IGAtJHt0aGlzLnNjcm9sbGJhcldpZHRofXB4YFxuICAgICAgICA6IDA7XG4gIH1cblxuICAvKipcbiAgICogT24gc2Nyb2xsIGV2ZW50IGhhbmRsaW5nXG4gICAqL1xuICBvblNjcm9sbCA9ICgpID0+IHtcbiAgICBjb25zdCBlbFdpbmRvdyA9IGdldEVsZW1lbnRXaW5kb3codGhpcy5lbCk7XG4gICAgaWYgKCF0aGlzLnNjcm9sbFhUaWNraW5nKSB7XG4gICAgICBlbFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxYKTtcbiAgICAgIHRoaXMuc2Nyb2xsWFRpY2tpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zY3JvbGxZVGlja2luZykge1xuICAgICAgZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsWSk7XG4gICAgICB0aGlzLnNjcm9sbFlUaWNraW5nID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgc2Nyb2xsWCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5heGlzLnguaXNPdmVyZmxvd2luZykge1xuICAgICAgdGhpcy5zaG93U2Nyb2xsYmFyKCd4Jyk7XG4gICAgICB0aGlzLnBvc2l0aW9uU2Nyb2xsYmFyKCd4Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxYVGlja2luZyA9IGZhbHNlO1xuICB9O1xuXG4gIHNjcm9sbFkgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHRoaXMuc2hvd1Njcm9sbGJhcigneScpO1xuICAgICAgdGhpcy5wb3NpdGlvblNjcm9sbGJhcigneScpO1xuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsWVRpY2tpbmcgPSBmYWxzZTtcbiAgfTtcblxuICBvbk1vdXNlRW50ZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5zaG93U2Nyb2xsYmFyKCd4Jyk7XG4gICAgdGhpcy5zaG93U2Nyb2xsYmFyKCd5Jyk7XG4gIH07XG5cbiAgb25Nb3VzZU1vdmUgPSBlID0+IHtcbiAgICB0aGlzLm1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICB0aGlzLm1vdXNlWSA9IGUuY2xpZW50WTtcblxuICAgIGlmICh0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nIHx8IHRoaXMuYXhpcy54LmZvcmNlVmlzaWJsZSkge1xuICAgICAgdGhpcy5vbk1vdXNlTW92ZUZvckF4aXMoJ3gnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyB8fCB0aGlzLmF4aXMueS5mb3JjZVZpc2libGUpIHtcbiAgICAgIHRoaXMub25Nb3VzZU1vdmVGb3JBeGlzKCd5Jyk7XG4gICAgfVxuICB9O1xuXG4gIG9uTW91c2VNb3ZlRm9yQXhpcyhheGlzID0gJ3knKSB7XG4gICAgdGhpcy5heGlzW2F4aXNdLnRyYWNrLnJlY3QgPSB0aGlzLmF4aXNbXG4gICAgICBheGlzXG4gICAgXS50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLnJlY3QgPSB0aGlzLmF4aXNbXG4gICAgICBheGlzXG4gICAgXS5zY3JvbGxiYXIuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCBpc1dpdGhpblNjcm9sbGJhckJvdW5kc1ggPSB0aGlzLmlzV2l0aGluQm91bmRzKFxuICAgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5yZWN0XG4gICAgKTtcblxuICAgIGlmIChpc1dpdGhpblNjcm9sbGJhckJvdW5kc1gpIHtcbiAgICAgIHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXIuZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuaG92ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1dpdGhpbkJvdW5kcyh0aGlzLmF4aXNbYXhpc10udHJhY2sucmVjdCkpIHtcbiAgICAgIHRoaXMuc2hvd1Njcm9sbGJhcihheGlzKTtcbiAgICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgIHRoaXMub25Nb3VzZU1vdmUuY2FuY2VsKCk7XG5cbiAgICBpZiAodGhpcy5heGlzLnguaXNPdmVyZmxvd2luZyB8fCB0aGlzLmF4aXMueC5mb3JjZVZpc2libGUpIHtcbiAgICAgIHRoaXMub25Nb3VzZUxlYXZlRm9yQXhpcygneCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nIHx8IHRoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSkge1xuICAgICAgdGhpcy5vbk1vdXNlTGVhdmVGb3JBeGlzKCd5Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZVggPSAtMTtcbiAgICB0aGlzLm1vdXNlWSA9IC0xO1xuICB9O1xuXG4gIG9uTW91c2VMZWF2ZUZvckF4aXMoYXhpcyA9ICd5Jykge1xuICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG4gICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG4gIH1cblxuICBvbldpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICAvLyBSZWNhbGN1bGF0ZSBzY3JvbGxiYXJXaWR0aCBpbiBjYXNlIGl0J3MgYSB6b29tXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcblxuICAgIHRoaXMuaGlkZU5hdGl2ZVNjcm9sbGJhcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHNjcm9sbGJhclxuICAgKi9cbiAgc2hvd1Njcm9sbGJhcihheGlzID0gJ3knKSB7XG4gICAgbGV0IHNjcm9sbGJhciA9IHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXIuZWw7XG5cbiAgICBpZiAoIXRoaXMuYXhpc1theGlzXS5pc1Zpc2libGUpIHtcbiAgICAgIHNjcm9sbGJhci5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcbiAgICAgIHRoaXMuYXhpc1theGlzXS5pc1Zpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUpIHtcbiAgICAgIHRoaXMuaGlkZVNjcm9sbGJhcnMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZSBTY3JvbGxiYXJcbiAgICovXG4gIGhpZGVTY3JvbGxiYXJzID0gKCkgPT4ge1xuICAgIHRoaXMuYXhpcy54LnRyYWNrLnJlY3QgPSB0aGlzLmF4aXMueC50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLmF4aXMueS50cmFjay5yZWN0ID0gdGhpcy5heGlzLnkudHJhY2suZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAoIXRoaXMuaXNXaXRoaW5Cb3VuZHModGhpcy5heGlzLnkudHJhY2sucmVjdCkpIHtcbiAgICAgIHRoaXMuYXhpcy55LnNjcm9sbGJhci5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcbiAgICAgIHRoaXMuYXhpcy55LmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1dpdGhpbkJvdW5kcyh0aGlzLmF4aXMueC50cmFjay5yZWN0KSkge1xuICAgICAgdGhpcy5heGlzLnguc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuICAgICAgdGhpcy5heGlzLnguaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIG9uUG9pbnRlckV2ZW50ID0gZSA9PiB7XG4gICAgbGV0IGlzV2l0aGluVHJhY2tYQm91bmRzLCBpc1dpdGhpblRyYWNrWUJvdW5kcztcblxuICAgIHRoaXMuYXhpcy54LnRyYWNrLnJlY3QgPSB0aGlzLmF4aXMueC50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLmF4aXMueS50cmFjay5yZWN0ID0gdGhpcy5heGlzLnkudHJhY2suZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAodGhpcy5heGlzLnguaXNPdmVyZmxvd2luZyB8fCB0aGlzLmF4aXMueC5mb3JjZVZpc2libGUpIHtcbiAgICAgIGlzV2l0aGluVHJhY2tYQm91bmRzID0gdGhpcy5pc1dpdGhpbkJvdW5kcyh0aGlzLmF4aXMueC50cmFjay5yZWN0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyB8fCB0aGlzLmF4aXMueS5mb3JjZVZpc2libGUpIHtcbiAgICAgIGlzV2l0aGluVHJhY2tZQm91bmRzID0gdGhpcy5pc1dpdGhpbkJvdW5kcyh0aGlzLmF4aXMueS50cmFjay5yZWN0KTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgcG9pbnRlciBldmVudCBpcyBjYWxsZWQgb24gdGhlIHNjcm9sbGJhclxuICAgIGlmIChpc1dpdGhpblRyYWNrWEJvdW5kcyB8fCBpc1dpdGhpblRyYWNrWUJvdW5kcykge1xuICAgICAgLy8gUHJldmVudGluZyB0aGUgZXZlbnQncyBkZWZhdWx0IGFjdGlvbiBzdG9wcyB0ZXh0IGJlaW5nXG4gICAgICAvLyBzZWxlY3RhYmxlIGR1cmluZyB0aGUgZHJhZy5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIFByZXZlbnQgZXZlbnQgbGVha2luZ1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgaWYgKGlzV2l0aGluVHJhY2tYQm91bmRzKSB7XG4gICAgICAgICAgdGhpcy5heGlzLnguc2Nyb2xsYmFyLnJlY3QgPSB0aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1dpdGhpbkJvdW5kcyh0aGlzLmF4aXMueC5zY3JvbGxiYXIucmVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZSwgJ3gnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vblRyYWNrQ2xpY2soZSwgJ3gnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNXaXRoaW5UcmFja1lCb3VuZHMpIHtcbiAgICAgICAgICB0aGlzLmF4aXMueS5zY3JvbGxiYXIucmVjdCA9IHRoaXMuYXhpcy55LnNjcm9sbGJhci5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzV2l0aGluQm91bmRzKHRoaXMuYXhpcy55LnNjcm9sbGJhci5yZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChlLCAneScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uVHJhY2tDbGljayhlLCAneScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogb24gc2Nyb2xsYmFyIGhhbmRsZSBkcmFnIG1vdmVtZW50IHN0YXJ0c1xuICAgKi9cbiAgb25EcmFnU3RhcnQoZSwgYXhpcyA9ICd5Jykge1xuICAgIGNvbnN0IGVsRG9jdW1lbnQgPSBnZXRFbGVtZW50RG9jdW1lbnQodGhpcy5lbCk7XG4gICAgY29uc3QgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpO1xuICAgIGNvbnN0IHNjcm9sbGJhciA9IHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXI7XG5cbiAgICAvLyBNZWFzdXJlIGhvdyBmYXIgdGhlIHVzZXIncyBtb3VzZSBpcyBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcm9sbGJhciBkcmFnIGhhbmRsZS5cbiAgICBjb25zdCBldmVudE9mZnNldCA9IGF4aXMgPT09ICd5JyA/IGUucGFnZVkgOiBlLnBhZ2VYO1xuICAgIHRoaXMuYXhpc1theGlzXS5kcmFnT2Zmc2V0ID1cbiAgICAgIGV2ZW50T2Zmc2V0IC0gc2Nyb2xsYmFyLnJlY3RbdGhpcy5heGlzW2F4aXNdLm9mZnNldEF0dHJdO1xuICAgIHRoaXMuZHJhZ2dlZEF4aXMgPSBheGlzO1xuXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5kcmFnZ2luZyk7XG5cbiAgICBlbERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuZHJhZywgdHJ1ZSk7XG4gICAgZWxEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkVuZERyYWcsIHRydWUpO1xuICAgIGlmICh0aGlzLnJlbW92ZVByZXZlbnRDbGlja0lkID09PSBudWxsKSB7XG4gICAgICBlbERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5wcmV2ZW50Q2xpY2ssIHRydWUpO1xuICAgICAgZWxEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMucHJldmVudENsaWNrLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxXaW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVtb3ZlUHJldmVudENsaWNrSWQpO1xuICAgICAgdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tJZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgc2Nyb2xsYmFyIGhhbmRsZVxuICAgKi9cbiAgZHJhZyA9IGUgPT4ge1xuICAgIGxldCBldmVudE9mZnNldDtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuYXhpc1t0aGlzLmRyYWdnZWRBeGlzXS50cmFjaztcbiAgICBjb25zdCB0cmFja1NpemUgPSB0cmFjay5yZWN0W3RoaXMuYXhpc1t0aGlzLmRyYWdnZWRBeGlzXS5zaXplQXR0cl07XG4gICAgY29uc3Qgc2Nyb2xsYmFyID0gdGhpcy5heGlzW3RoaXMuZHJhZ2dlZEF4aXNdLnNjcm9sbGJhcjtcbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IHRoaXMuY29udGVudFdyYXBwZXJFbFtcbiAgICAgIHRoaXMuYXhpc1t0aGlzLmRyYWdnZWRBeGlzXS5zY3JvbGxTaXplQXR0clxuICAgIF07XG4gICAgY29uc3QgaG9zdFNpemUgPSBwYXJzZUludChcbiAgICAgIHRoaXMuZWxTdHlsZXNbdGhpcy5heGlzW3RoaXMuZHJhZ2dlZEF4aXNdLnNpemVBdHRyXSxcbiAgICAgIDEwXG4gICAgKTtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuZHJhZ2dlZEF4aXMgPT09ICd5Jykge1xuICAgICAgZXZlbnRPZmZzZXQgPSBlLnBhZ2VZO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudE9mZnNldCA9IGUucGFnZVg7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgdGhlIHVzZXIncyBtb3VzZSBpcyBmcm9tIHRoZSB0b3AvbGVmdCBvZiB0aGUgc2Nyb2xsYmFyIChtaW51cyB0aGUgZHJhZ09mZnNldCkuXG4gICAgbGV0IGRyYWdQb3MgPVxuICAgICAgZXZlbnRPZmZzZXQgLVxuICAgICAgdHJhY2sucmVjdFt0aGlzLmF4aXNbdGhpcy5kcmFnZ2VkQXhpc10ub2Zmc2V0QXR0cl0gLVxuICAgICAgdGhpcy5heGlzW3RoaXMuZHJhZ2dlZEF4aXNdLmRyYWdPZmZzZXQ7XG4gICAgLy8gQ29udmVydCB0aGUgbW91c2UgcG9zaXRpb24gaW50byBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNjcm9sbGJhciBoZWlnaHQvd2lkdGguXG4gICAgbGV0IGRyYWdQZXJjID0gZHJhZ1BvcyAvICh0cmFja1NpemUgLSBzY3JvbGxiYXIuc2l6ZSk7XG5cbiAgICAvLyBTY3JvbGwgdGhlIGNvbnRlbnQgYnkgdGhlIHNhbWUgcGVyY2VudGFnZS5cbiAgICBsZXQgc2Nyb2xsUG9zID0gZHJhZ1BlcmMgKiAoY29udGVudFNpemUgLSBob3N0U2l6ZSk7XG5cbiAgICAvLyBGaXggYnJvd3NlcnMgaW5jb25zaXN0ZW5jeSBvbiBSVExcbiAgICBpZiAodGhpcy5kcmFnZ2VkQXhpcyA9PT0gJ3gnKSB7XG4gICAgICBzY3JvbGxQb3MgPVxuICAgICAgICB0aGlzLmlzUnRsICYmIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKCkuaXNSdGxTY3JvbGxiYXJJbnZlcnRlZFxuICAgICAgICAgID8gc2Nyb2xsUG9zIC0gKHRyYWNrU2l6ZSArIHNjcm9sbGJhci5zaXplKVxuICAgICAgICAgIDogc2Nyb2xsUG9zO1xuICAgICAgc2Nyb2xsUG9zID1cbiAgICAgICAgdGhpcy5pc1J0bCAmJiBTaW1wbGVCYXIuZ2V0UnRsSGVscGVycygpLmlzUnRsU2Nyb2xsaW5nSW52ZXJ0ZWRcbiAgICAgICAgICA/IC1zY3JvbGxQb3NcbiAgICAgICAgICA6IHNjcm9sbFBvcztcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWxbXG4gICAgICB0aGlzLmF4aXNbdGhpcy5kcmFnZ2VkQXhpc10uc2Nyb2xsT2Zmc2V0QXR0clxuICAgIF0gPSBzY3JvbGxQb3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuZCBzY3JvbGwgaGFuZGxlIGRyYWdcbiAgICovXG4gIG9uRW5kRHJhZyA9IGUgPT4ge1xuICAgIGNvbnN0IGVsRG9jdW1lbnQgPSBnZXRFbGVtZW50RG9jdW1lbnQodGhpcy5lbCk7XG4gICAgY29uc3QgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5kcmFnZ2luZyk7XG5cbiAgICBlbERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuZHJhZywgdHJ1ZSk7XG4gICAgZWxEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkVuZERyYWcsIHRydWUpO1xuICAgIHRoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPSBlbFdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSB0aGVzZSBhc3luY2hyb25vdXNseSBzbyB3ZSBzdGlsbCBzdXBwcmVzcyBjbGljayBldmVudHNcbiAgICAgIC8vIGdlbmVyYXRlZCBzaW11bHRhbmVvdXNseSB3aXRoIG1vdXNldXAuXG4gICAgICBlbERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5wcmV2ZW50Q2xpY2ssIHRydWUpO1xuICAgICAgZWxEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMucHJldmVudENsaWNrLCB0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPSBudWxsO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIHRvIGlnbm9yZSBjbGljayBldmVudHMgZHVyaW5nIGRyYWdcbiAgICovXG4gIHByZXZlbnRDbGljayA9IGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIG9uVHJhY2tDbGljayhlLCBheGlzID0gJ3knKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY2xpY2tPblRyYWNrKSByZXR1cm47XG5cbiAgICBjb25zdCBlbFdpbmRvdyA9IGdldEVsZW1lbnRXaW5kb3codGhpcy5lbCk7XG4gICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5yZWN0ID0gdGhpcy5heGlzW1xuICAgICAgYXhpc1xuICAgIF0uc2Nyb2xsYmFyLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNjcm9sbGJhciA9IHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXI7XG4gICAgY29uc3Qgc2Nyb2xsYmFyT2Zmc2V0ID0gc2Nyb2xsYmFyLnJlY3RbdGhpcy5heGlzW2F4aXNdLm9mZnNldEF0dHJdO1xuICAgIGNvbnN0IGhvc3RTaXplID0gcGFyc2VJbnQodGhpcy5lbFN0eWxlc1t0aGlzLmF4aXNbYXhpc10uc2l6ZUF0dHJdLCAxMCk7XG4gICAgbGV0IHNjcm9sbGVkID0gdGhpcy5jb250ZW50V3JhcHBlckVsW3RoaXMuYXhpc1theGlzXS5zY3JvbGxPZmZzZXRBdHRyXTtcbiAgICBjb25zdCB0ID1cbiAgICAgIGF4aXMgPT09ICd5J1xuICAgICAgICA/IHRoaXMubW91c2VZIC0gc2Nyb2xsYmFyT2Zmc2V0XG4gICAgICAgIDogdGhpcy5tb3VzZVggLSBzY3JvbGxiYXJPZmZzZXQ7XG4gICAgY29uc3QgZGlyID0gdCA8IDAgPyAtMSA6IDE7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGRpciA9PT0gLTEgPyBzY3JvbGxlZCAtIGhvc3RTaXplIDogc2Nyb2xsZWQgKyBob3N0U2l6ZTtcbiAgICBjb25zdCBzcGVlZCA9IDQwO1xuXG4gICAgY29uc3Qgc2Nyb2xsVG8gPSAoKSA9PiB7XG4gICAgICBpZiAoZGlyID09PSAtMSkge1xuICAgICAgICBpZiAoc2Nyb2xsZWQgPiBzY3JvbGxTaXplKSB7XG4gICAgICAgICAgc2Nyb2xsZWQgLT0gc3BlZWQ7XG4gICAgICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICAgIFt0aGlzLmF4aXNbYXhpc10ub2Zmc2V0QXR0cl06IHNjcm9sbGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbFRvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNjcm9sbGVkIDwgc2Nyb2xsU2l6ZSkge1xuICAgICAgICAgIHNjcm9sbGVkICs9IHNwZWVkO1xuICAgICAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICAgICAgICBbdGhpcy5heGlzW2F4aXNdLm9mZnNldEF0dHJdOiBzY3JvbGxlZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzY3JvbGxUbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2Nyb2xsVG8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIGNvbnRlbnQgZWxlbWVudFxuICAgKi9cbiAgZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudEVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3Igb3JpZ2luYWwgc2Nyb2xsaW5nIGVsZW1lbnRcbiAgICovXG4gIGdldFNjcm9sbEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFdyYXBwZXJFbDtcbiAgfVxuXG4gIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgIC8vIFRyeS9jYXRjaCBmb3IgRkYgNTYgdGhyb3dpbmcgb24gdW5kZWZpbmVkIGNvbXB1dGVkU3R5bGVzXG4gICAgdHJ5IHtcbiAgICAgIC8vIERldGVjdCBicm93c2VycyBzdXBwb3J0aW5nIENTUyBzY3JvbGxiYXIgc3R5bGluZyBhbmQgZG8gbm90IGNhbGN1bGF0ZVxuICAgICAgaWYgKFxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKHRoaXMuY29udGVudFdyYXBwZXJFbCwgJzo6LXdlYmtpdC1zY3JvbGxiYXInKVxuICAgICAgICAgIC5kaXNwbGF5ID09PSAnbm9uZScgfHxcbiAgICAgICAgJ3Njcm9sbGJhcldpZHRoJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgfHxcbiAgICAgICAgJy1tcy1vdmVyZmxvdy1zdHlsZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpO1xuICAgIC8vIEV2ZW50IGxpc3RlbmVyc1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Nb3VzZUVudGVyKTtcbiAgICB9XG5cbiAgICBbJ21vdXNlZG93bicsICdjbGljaycsICdkYmxjbGljayddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdGhpcy5vblBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCB0aGlzLm9uUG9pbnRlckV2ZW50LCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG5cbiAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbCk7XG4gICAgZWxXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vbldpbmRvd1Jlc2l6ZSk7XG5cbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgLy8gQ2FuY2VsIGFsbCBkZWJvdW5jZWQgZnVuY3Rpb25zXG4gICAgdGhpcy5yZWNhbGN1bGF0ZS5jYW5jZWwoKTtcbiAgICB0aGlzLm9uTW91c2VNb3ZlLmNhbmNlbCgpO1xuICAgIHRoaXMuaGlkZVNjcm9sbGJhcnMuY2FuY2VsKCk7XG4gICAgdGhpcy5vbldpbmRvd1Jlc2l6ZS5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbk1vdW50IG11dGF0aW9uIG9ic2VydmVyIGFuZCBkZWxldGUgU2ltcGxlQmFyIGluc3RhbmNlIGZyb20gRE9NIGVsZW1lbnRcbiAgICovXG4gIHVuTW91bnQoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLmRlbGV0ZSh0aGlzLmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBtb3VzZSBpcyB3aXRoaW4gYm91bmRzXG4gICAqL1xuICBpc1dpdGhpbkJvdW5kcyhiYm94KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubW91c2VYID49IGJib3gubGVmdCAmJlxuICAgICAgdGhpcy5tb3VzZVggPD0gYmJveC5sZWZ0ICsgYmJveC53aWR0aCAmJlxuICAgICAgdGhpcy5tb3VzZVkgPj0gYmJveC50b3AgJiZcbiAgICAgIHRoaXMubW91c2VZIDw9IGJib3gudG9wICsgYmJveC5oZWlnaHRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgZWxlbWVudCBjaGlsZHJlbiBtYXRjaGVzIHF1ZXJ5XG4gICAqL1xuICBmaW5kQ2hpbGQoZWwsIHF1ZXJ5KSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICBlbC5tYXRjaGVzIHx8XG4gICAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbC5jaGlsZHJlbiwgY2hpbGQgPT5cbiAgICAgIG1hdGNoZXMuY2FsbChjaGlsZCwgcXVlcnkpXG4gICAgKVswXTtcbiAgfVxufVxuIiwiaW1wb3J0IGNhblVzZURPTSBmcm9tICdjYW4tdXNlLWRvbSc7XG5cbmltcG9ydCBTaW1wbGVCYXIgZnJvbSAnLi9zaW1wbGViYXInO1xuaW1wb3J0IHsgZ2V0T3B0aW9ucyB9IGZyb20gJy4vaGVscGVycyc7XG5cblNpbXBsZUJhci5pbml0RE9NTG9hZGVkRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW1wbGViYXJdJyksXG4gICAgZWwgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2ltcGxlYmFyJykgIT09ICdpbml0JyAmJlxuICAgICAgICAhU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMoZWwpXG4gICAgICApXG4gICAgICAgIG5ldyBTaW1wbGVCYXIoZWwsIGdldE9wdGlvbnMoZWwuYXR0cmlidXRlcykpO1xuICAgIH1cbiAgKTtcbn07XG5cblNpbXBsZUJhci5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsb2JhbE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbn07XG5cblNpbXBsZUJhci5pbml0SHRtbEFwaSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyA9IHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzLmJpbmQodGhpcyk7XG5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBpcyBJRTExK1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTXV0YXRpb24gb2JzZXJ2ZXIgdG8gb2JzZXJ2ZSBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xuICAgIHRoaXMuZ2xvYmFsT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihTaW1wbGVCYXIuaGFuZGxlTXV0YXRpb25zKTtcblxuICAgIHRoaXMuZ2xvYmFsT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gIH1cblxuICAvLyBUYWtlbiBmcm9tIGpRdWVyeSBgcmVhZHlgIGZ1bmN0aW9uXG4gIC8vIEluc3RhbnRpYXRlIGVsZW1lbnRzIGFscmVhZHkgcHJlc2VudCBvbiB0aGUgcGFnZVxuICBpZiAoXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fFxuICAgIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbClcbiAgKSB7XG4gICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IGluaXRcbiAgICB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKTtcbiAgfVxufTtcblxuU2ltcGxlQmFyLmhhbmRsZU11dGF0aW9ucyA9IG11dGF0aW9ucyA9PiB7XG4gIG11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG11dGF0aW9uLmFkZGVkTm9kZXMsIGFkZGVkTm9kZSA9PiB7XG4gICAgICBpZiAoYWRkZWROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChhZGRlZE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNpbXBsZWJhcicpKSB7XG4gICAgICAgICAgIVNpbXBsZUJhci5pbnN0YW5jZXMuaGFzKGFkZGVkTm9kZSkgJiZcbiAgICAgICAgICAgIG5ldyBTaW1wbGVCYXIoYWRkZWROb2RlLCBnZXRPcHRpb25zKGFkZGVkTm9kZS5hdHRyaWJ1dGVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChcbiAgICAgICAgICAgIGFkZGVkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW1wbGViYXJdJyksXG4gICAgICAgICAgICBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNpbXBsZWJhcicpICE9PSAnaW5pdCcgJiZcbiAgICAgICAgICAgICAgICAhU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMoZWwpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBuZXcgU2ltcGxlQmFyKGVsLCBnZXRPcHRpb25zKGVsLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG11dGF0aW9uLnJlbW92ZWROb2RlcywgcmVtb3ZlZE5vZGUgPT4ge1xuICAgICAgaWYgKHJlbW92ZWROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZS5oYXNBdHRyaWJ1dGUoJ1tkYXRhLXNpbXBsZWJhcj1cImluaXRcIl0nKSkge1xuICAgICAgICAgIFNpbXBsZUJhci5pbnN0YW5jZXMuaGFzKHJlbW92ZWROb2RlKSAmJlxuICAgICAgICAgICAgU2ltcGxlQmFyLmluc3RhbmNlcy5nZXQocmVtb3ZlZE5vZGUpLnVuTW91bnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFxuICAgICAgICAgICAgcmVtb3ZlZE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2ltcGxlYmFyPVwiaW5pdFwiXScpLFxuICAgICAgICAgICAgZWwgPT4ge1xuICAgICAgICAgICAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLmhhcyhlbCkgJiZcbiAgICAgICAgICAgICAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLmdldChlbCkudW5Nb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5TaW1wbGVCYXIuZ2V0T3B0aW9ucyA9IGdldE9wdGlvbnM7XG5cbi8qKlxuICogSFRNTCBBUElcbiAqIENhbGxlZCBvbmx5IGluIGEgYnJvd3NlciBlbnYuXG4gKi9cbmlmIChjYW5Vc2VET00pIHtcbiAgU2ltcGxlQmFyLmluaXRIdG1sQXBpKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXBsZUJhcjtcbiIsIi8qIVxuICogVW5pZHJhZ2dlciB2Mi4zLjFcbiAqIERyYWdnYWJsZSBiYXNlIGNsYXNzXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVudXNlZDogdHJ1ZSwgdW5kZWY6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAndW5pcG9pbnRlci91bmlwb2ludGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBVbmlwb2ludGVyICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgndW5pcG9pbnRlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5VbmlkcmFnZ2VyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5Vbmlwb2ludGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVbmlkcmFnZ2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIFVuaWRyYWdnZXIoKSB7fVxuXG4vLyBpbmhlcml0IFVuaXBvaW50ZXIgJiBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaWRyYWdnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVW5pcG9pbnRlci5wcm90b3R5cGUgKTtcblxuLy8gLS0tLS0gYmluZCBzdGFydCAtLS0tLSAvL1xuXG5wcm90by5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZFxuICovXG5wcm90by5fYmluZEhhbmRsZXMgPSBmdW5jdGlvbiggaXNBZGQgKSB7XG4gIC8vIG11bmdlIGlzQWRkLCBkZWZhdWx0IHRvIHRydWVcbiAgaXNBZGQgPSBpc0FkZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzQWRkO1xuICAvLyBiaW5kIGVhY2ggaGFuZGxlXG4gIHZhciBiaW5kTWV0aG9kID0gaXNBZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gIHZhciB0b3VjaEFjdGlvbiA9IGlzQWRkID8gdGhpcy5fdG91Y2hBY3Rpb25WYWx1ZSA6ICcnO1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLmhhbmRsZXNbaV07XG4gICAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIGhhbmRsZSwgaXNBZGQgKTtcbiAgICBoYW5kbGVbIGJpbmRNZXRob2QgXSggJ2NsaWNrJywgdGhpcyApO1xuICAgIC8vIHRvdWNoLWFjdGlvbjogbm9uZSB0byBvdmVycmlkZSBicm93c2VyIHRvdWNoIGdlc3R1cmVzLiBtZXRhZml6enkvZmxpY2tpdHkjNTQwXG4gICAgaWYgKCB3aW5kb3cuUG9pbnRlckV2ZW50ICkge1xuICAgICAgaGFuZGxlLnN0eWxlLnRvdWNoQWN0aW9uID0gdG91Y2hBY3Rpb247XG4gICAgfVxuICB9XG59O1xuXG4vLyBwcm90b3R5cGUgc28gaXQgY2FuIGJlIG92ZXJ3cml0ZWFibGUgYnkgRmxpY2tpdHlcbnByb3RvLl90b3VjaEFjdGlvblZhbHVlID0gJ25vbmUnO1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB2YXIgaXNPa2F5ID0gdGhpcy5va2F5UG9pbnRlckRvd24oIGV2ZW50ICk7XG4gIGlmICggIWlzT2theSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdHJhY2sgc3RhcnQgZXZlbnQgcG9zaXRpb25cbiAgLy8gU2FmYXJpIDkgb3ZlcnJpZGVzIHBhZ2VYIGFuZCBwYWdlWS4gVGhlc2UgdmFsdWVzIG5lZWRzIHRvIGJlIGNvcGllZC4gZmxpY2tpdHkjODQyXG4gIHRoaXMucG9pbnRlckRvd25Qb2ludGVyID0ge1xuICAgIHBhZ2VYOiBwb2ludGVyLnBhZ2VYLFxuICAgIHBhZ2VZOiBwb2ludGVyLnBhZ2VZLFxuICB9O1xuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHRoaXMucG9pbnRlckRvd25CbHVyKCk7XG4gIC8vIGJpbmQgbW92ZSBhbmQgZW5kIGV2ZW50c1xuICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJEb3duJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyBub2RlcyB0aGF0IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjdXJzb3JOb2RlcyA9IHtcbiAgVEVYVEFSRUE6IHRydWUsXG4gIElOUFVUOiB0cnVlLFxuICBTRUxFQ1Q6IHRydWUsXG4gIE9QVElPTjogdHJ1ZSxcbn07XG5cbi8vIGlucHV0IHR5cGVzIHRoYXQgZG8gbm90IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjbGlja1R5cGVzID0ge1xuICByYWRpbzogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgZmlsZTogdHJ1ZSxcbn07XG5cbi8vIGRpc21pc3MgaW5wdXRzIHdpdGggdGV4dCBmaWVsZHMuIGZsaWNraXR5IzQwMywgZmxpY2tpdHkjNDA0XG5wcm90by5va2F5UG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBpc0N1cnNvck5vZGUgPSBjdXJzb3JOb2Rlc1sgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIF07XG4gIHZhciBpc0NsaWNrVHlwZSA9IGNsaWNrVHlwZXNbIGV2ZW50LnRhcmdldC50eXBlIF07XG4gIHZhciBpc09rYXkgPSAhaXNDdXJzb3JOb2RlIHx8IGlzQ2xpY2tUeXBlO1xuICBpZiAoICFpc09rYXkgKSB7XG4gICAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIH1cbiAgcmV0dXJuIGlzT2theTtcbn07XG5cbi8vIGtsdWRnZSB0byBibHVyIHByZXZpb3VzbHkgZm9jdXNlZCBpbnB1dFxucHJvdG8ucG9pbnRlckRvd25CbHVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgLy8gZG8gbm90IGJsdXIgYm9keSBmb3IgSUUxMCwgbWV0YWZpenp5L2ZsaWNraXR5IzExN1xuICB2YXIgY2FuQmx1ciA9IGZvY3VzZWQgJiYgZm9jdXNlZC5ibHVyICYmIGZvY3VzZWQgIT0gZG9jdW1lbnQuYm9keTtcbiAgaWYgKCBjYW5CbHVyICkge1xuICAgIGZvY3VzZWQuYmx1cigpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbi8qKlxuICogZHJhZyBtb3ZlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB0aGlzLl9kcmFnUG9pbnRlck1vdmUoIGV2ZW50LCBwb2ludGVyICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcbiAgdGhpcy5fZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG4vLyBiYXNlIHBvaW50ZXIgbW92ZSBsb2dpY1xucHJvdG8uX2RyYWdQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB7XG4gICAgeDogcG9pbnRlci5wYWdlWCAtIHRoaXMucG9pbnRlckRvd25Qb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVkgLSB0aGlzLnBvaW50ZXJEb3duUG9pbnRlci5wYWdlWVxuICB9O1xuICAvLyBzdGFydCBkcmFnIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5oYXNEcmFnU3RhcnRlZCggbW92ZVZlY3RvciApICkge1xuICAgIHRoaXMuX2RyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfVxuICByZXR1cm4gbW92ZVZlY3Rvcjtcbn07XG5cbi8vIGNvbmRpdGlvbiBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcbnByb3RvLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XG4gIHJldHVybiBNYXRoLmFicyggbW92ZVZlY3Rvci54ICkgPiAzIHx8IE1hdGguYWJzKCBtb3ZlVmVjdG9yLnkgKSA+IDM7XG59O1xuXG4vLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XG4gIHRoaXMuX2RyYWdQb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5fZHJhZ1BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgdGhpcy5fZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwb2ludGVyIGRpZG4ndCBtb3ZlIGVub3VnaCBmb3IgZHJhZyB0byBzdGFydFxuICAgIHRoaXMuX3N0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGRyYWdTdGFydFxucHJvdG8uX2RyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgLy8gcHJldmVudCBjbGlja3NcbiAgdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgPSB0cnVlO1xuICB0aGlzLmRyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnU3RhcnQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGRyYWdNb3ZlXG5wcm90by5fZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIC8vIGRvIG5vdCBkcmFnIGlmIG5vdCBkcmFnZ2luZyB5ZXRcbiAgaWYgKCAhdGhpcy5pc0RyYWdnaW5nICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG5wcm90by5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuLy8gZHJhZ0VuZFxucHJvdG8uX2RyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIC8vIHNldCBmbGFnc1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgLy8gcmUtZW5hYmxlIGNsaWNraW5nIGFzeW5jXG4gIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLmlzUHJldmVudGluZ0NsaWNrcztcbiAgfS5iaW5kKCB0aGlzICkgKTtcblxuICB0aGlzLmRyYWdFbmQoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ2RyYWdFbmQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIG9uY2xpY2sgLS0tLS0gLy9cblxuLy8gaGFuZGxlIGFsbCBjbGlja3MgYW5kIHByZXZlbnQgY2xpY2tzIHdoZW4gZHJhZ2dpbmdcbnByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cblxuLy8gdHJpZ2dlcmVkIGFmdGVyIHBvaW50ZXIgZG93biAmIHVwIHdpdGggbm8vdGlueSBtb3ZlbWVudFxucHJvdG8uX3N0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyBpZ25vcmUgZW11bGF0ZWQgbW91c2UgdXAgY2xpY2tzXG4gIGlmICggdGhpcy5pc0lnbm9yaW5nTW91c2VVcCAmJiBldmVudC50eXBlID09ICdtb3VzZXVwJyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuXG4gIC8vIHNldCBmbGFnIGZvciBlbXVsYXRlZCBjbGlja3MgMzAwbXMgYWZ0ZXIgdG91Y2hlbmRcbiAgaWYgKCBldmVudC50eXBlICE9ICdtb3VzZXVwJyApIHtcbiAgICB0aGlzLmlzSWdub3JpbmdNb3VzZVVwID0gdHJ1ZTtcbiAgICAvLyByZXNldCBmbGFnIGFmdGVyIDMwMG1zXG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5pc0lnbm9yaW5nTW91c2VVcDtcbiAgICB9LmJpbmQoIHRoaXMgKSwgNDAwICk7XG4gIH1cbn07XG5cbnByb3RvLnN0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3N0YXRpY0NsaWNrJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLSB1dGlscyAtLS0tLSAvL1xuXG5VbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIFVuaWRyYWdnZXI7XG5cbn0pKTtcbiIsIi8qIVxuICogVW5pcG9pbnRlciB2Mi4zLjBcbiAqIGJhc2UgY2xhc3MgZm9yIGRvaW5nIG9uZSB0aGluZyB3aXRoIHBvaW50ZXIgZXZlbnRcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBFdkVtaXR0ZXIgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuVW5pcG9pbnRlciA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBVbmlwb2ludGVyKCkge31cblxuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaXBvaW50ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5wcm90by5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZCAtIHJlbW92ZSBpZiBmYWxzZXlcbiAqL1xucHJvdG8uX2JpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIGlzQWRkICkge1xuICAvLyBtdW5nZSBpc0FkZCwgZGVmYXVsdCB0byB0cnVlXG4gIGlzQWRkID0gaXNBZGQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc0FkZDtcbiAgdmFyIGJpbmRNZXRob2QgPSBpc0FkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAvLyBkZWZhdWx0IHRvIG1vdXNlIGV2ZW50c1xuICB2YXIgc3RhcnRFdmVudCA9ICdtb3VzZWRvd24nO1xuICBpZiAoIHdpbmRvdy5Qb2ludGVyRXZlbnQgKSB7XG4gICAgLy8gUG9pbnRlciBFdmVudHNcbiAgICBzdGFydEV2ZW50ID0gJ3BvaW50ZXJkb3duJztcbiAgfSBlbHNlIGlmICggJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICkge1xuICAgIC8vIFRvdWNoIEV2ZW50cy4gaU9TIFNhZmFyaVxuICAgIHN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCc7XG4gIH1cbiAgZWxlbVsgYmluZE1ldGhvZCBdKCBzdGFydEV2ZW50LCB0aGlzICk7XG59O1xuXG4vLyB0cmlnZ2VyIGhhbmRsZXIgbWV0aG9kcyBmb3IgZXZlbnRzXG5wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG4vLyByZXR1cm5zIHRoZSB0b3VjaCB0aGF0IHdlJ3JlIGtlZXBpbmcgdHJhY2sgb2ZcbnByb3RvLmdldFRvdWNoID0gZnVuY3Rpb24oIHRvdWNoZXMgKSB7XG4gIGZvciAoIHZhciBpPTA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgaWYgKCB0b3VjaC5pZGVudGlmaWVyID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgICByZXR1cm4gdG91Y2g7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG5wcm90by5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gZGlzbWlzcyBjbGlja3MgZnJvbSByaWdodCBvciBtaWRkbGUgYnV0dG9uc1xuICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICBpZiAoIGJ1dHRvbiAmJiAoIGJ1dHRvbiAhPT0gMCAmJiBidXR0b24gIT09IDEgKSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fcG9pbnRlckRvd24oIGV2ZW50LCBldmVudCApO1xufTtcblxucHJvdG8ub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLl9wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgLy8gZGlzbWlzcyByaWdodCBjbGljayBhbmQgb3RoZXIgcG9pbnRlcnNcbiAgLy8gYnV0dG9uID0gMCBpcyBva2F5LCAxLTQgbm90XG4gIGlmICggZXZlbnQuYnV0dG9uIHx8IHRoaXMuaXNQb2ludGVyRG93biApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzUG9pbnRlckRvd24gPSB0cnVlO1xuICAvLyBzYXZlIHBvaW50ZXIgaWRlbnRpZmllciB0byBtYXRjaCB1cCB0b3VjaCBldmVudHNcbiAgdGhpcy5wb2ludGVySWRlbnRpZmllciA9IHBvaW50ZXIucG9pbnRlcklkICE9PSB1bmRlZmluZWQgP1xuICAgIC8vIHBvaW50ZXJJZCBmb3IgcG9pbnRlciBldmVudHMsIHRvdWNoLmluZGVudGlmaWVyIGZvciB0b3VjaCBldmVudHNcbiAgICBwb2ludGVyLnBvaW50ZXJJZCA6IHBvaW50ZXIuaWRlbnRpZmllcjtcblxuICB0aGlzLnBvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xufTtcblxucHJvdG8ucG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGhhc2ggb2YgZXZlbnRzIHRvIGJlIGJvdW5kIGFmdGVyIHN0YXJ0IGV2ZW50XG52YXIgcG9zdFN0YXJ0RXZlbnRzID0ge1xuICBtb3VzZWRvd246IFsgJ21vdXNlbW92ZScsICdtb3VzZXVwJyBdLFxuICB0b3VjaHN0YXJ0OiBbICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIF0sXG4gIHBvaW50ZXJkb3duOiBbICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmNhbmNlbCcgXSxcbn07XG5cbnByb3RvLl9iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoICFldmVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0IHByb3BlciBldmVudHMgdG8gbWF0Y2ggc3RhcnQgZXZlbnRcbiAgdmFyIGV2ZW50cyA9IHBvc3RTdGFydEV2ZW50c1sgZXZlbnQudHlwZSBdO1xuICAvLyBiaW5kIGV2ZW50cyB0byBub2RlXG4gIGV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuICAvLyBzYXZlIHRoZXNlIGFyZ3VtZW50c1xuICB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgPSBldmVudHM7XG59O1xuXG5wcm90by5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGZvciBfYm91bmRFdmVudHMsIGluIGNhc2UgZHJhZ0VuZCB0cmlnZ2VyZWQgdHdpY2UgKG9sZCBJRTggYnVnKVxuICBpZiAoICF0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuXG4gIGRlbGV0ZSB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHM7XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyTW92ZSggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8ub250b3VjaG1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCB0b3VjaCApO1xuICB9XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgbW92ZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5wb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIHB1YmxpY1xucHJvdG8ucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG5cbnByb3RvLm9ubW91c2V1cCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ucG9pbnRlcnVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJVcCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hlbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgdG91Y2ggKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX3BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG4vLyBwdWJsaWNcbnByb3RvLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyVXAnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIHBvaW50ZXIgZG9uZSAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyZWQgb24gcG9pbnRlciB1cCAmIHBvaW50ZXIgY2FuY2VsXG5wcm90by5fcG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIHRoaXMuX3VuYmluZFBvc3RTdGFydEV2ZW50cygpO1xuICB0aGlzLnBvaW50ZXJEb25lKCk7XG59O1xuXG5wcm90by5fcG9pbnRlclJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlc2V0IHByb3BlcnRpZXNcbiAgdGhpcy5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyO1xufTtcblxucHJvdG8ucG9pbnRlckRvbmUgPSBub29wO1xuXG4vLyAtLS0tLSBwb2ludGVyIGNhbmNlbCAtLS0tLSAvL1xuXG5wcm90by5vbnBvaW50ZXJjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIHRvdWNoICk7XG4gIH1cbn07XG5cbi8qKlxuICogcG9pbnRlciBjYW5jZWxcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fcG9pbnRlckNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyQ2FuY2VsKCBldmVudCwgcG9pbnRlciApO1xufTtcblxuLy8gcHVibGljXG5wcm90by5wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJDYW5jZWwnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBnZXR0aW5nIHgveSBjb29yZHMgZnJvbSBldmVudFxuVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQgPSBmdW5jdGlvbiggcG9pbnRlciApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVlcbiAgfTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gVW5pcG9pbnRlcjtcblxufSkpO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiY29uc3QgbmF2VHJpZ2dlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25hdiBwOm50aC1jaGlsZCgyKScpO1xuY29uc3QgYWJvdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyX19hYm91dCcpO1xuY29uc3QgYnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcl9fYWJvdXQgYnV0dG9uJyk7XG5jb25zdCBjb250YWluZXJBYm91dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXJfX2Fib3V0Jyk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCk9PiB7XG4gICAgbmF2VHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhYm91dC5jbGFzc0xpc3QudG9nZ2xlKCdjb250YWluZXJfX2Fib3V0LS1hY3RpdmUnKTtcbiAgICAgICAgbmF2VHJpZ2dlci5jbGFzc0xpc3QudG9nZ2xlKCduYXZfX2VsZW1lbnQtLWFjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBzY3JpcHQgZm9yIGNsaWNraW5nIG91dHNpZGUgb2YgY29udGFpbmVyXG4gICAgICogaHR0cHM6Ly93d3cuYmx1c3RlbXkuaW8vZGV0ZWN0aW5nLWEtY2xpY2stb3V0c2lkZS1hbi1lbGVtZW50LWluLWphdmFzY3JpcHQvXG4gICAgICovXG4gICAgY29udGFpbmVyQWJvdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldnQpID0+IHtcbiAgICAgICAgY29uc3QgYWJvdXRNZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hYm91dF9fbWUnKTtcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQgPSBldnQudGFyZ2V0OyAvLyBjbGlja2VkIGVsZW1lbnRcblxuICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PSBhYm91dE1lKSB7XG4gICAgICAgICAgICAvLyB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhYm91dC5jbGFzc0xpc3QucmVtb3ZlKCdjb250YWluZXJfX2Fib3V0LS1hY3RpdmUnKTtcbiAgICAgICAgICAgIG5hdlRyaWdnZXIuY2xhc3NMaXN0LnJlbW92ZSgnbmF2X19lbGVtZW50LS1hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbn0pO1xuXG5cblxuXG5cbiIsImltcG9ydCBGbGlja2l0eSBmcm9tICdmbGlja2l0eSc7XG5cbi8qXG4gKiBodHRwczovL2NvZGVwZW4uaW8vY2hyaXNjb3lpZXIvcGVuL1hRcHFaVlxuICovXG5jb25zdCBwcm9qZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnByb2plY3RfX2l0ZW0nKTtcbmNvbnN0IHByb2plY3RzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2plY3RfX2l0ZW0nKTtcbmNvbnN0IGdhbGxlcmllcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy53cmFwcGVyX19jb250YWluZXJfX2ltYWdlcycpO1xuY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcicpO1xuXG4vLyBmdW5jdGlvbiBmbGlja2l0eShpdGVtKSB7XG4vLyAgICAgbGV0IGNhcm91c2VsID0gbmV3IEZsaWNraXR5KCcuY29udGFpbmVyX2ltYWdlc19fZ2FsbGVyeScsIHtcbi8vICAgICAgICAgYWRhcHRpdmVIZWlnaHQ6IHRydWUsXG4vLyAgICAgICAgIGxhenlMb2FkOiB0cnVlLFxuLy8gICAgICAgICBwYWdlRG90czogZmFsc2Vcbi8vICAgICB9KTtcbi8vIH1cbmxldCBjYXJvdXNlbCA9IG5ldyBGbGlja2l0eSgnLmNvbnRhaW5lcl9pbWFnZXNfX2dhbGxlcnknLCB7XG4gICAgYWRhcHRpdmVIZWlnaHQ6IHRydWUsXG4gICAgbGF6eUxvYWQ6IHRydWUsXG4gICAgcGFnZURvdHM6IGZhbHNlXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTY3JpcHQgZm9yIGJvdGhcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnByb2plY3RzLmZvckVhY2gocHJvamVjdCA9PiB7XG4gICAgcHJvamVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJlbW92ZUFjdGl2ZVByb2plY3QoKTtcbiAgICAgICAgYWRkQWN0aXZlUHJvamVjdChwcm9qZWN0KTtcbiAgICAgICAgY2xpY2tPdXRzaWRlKHByb2plY3QpO1xuICAgIH0pO1xuICAgIHByb2plY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQ7XG4gICAgICAgIHJlbW92ZUhvdmVyUHJvamVjdCgpO1xuICAgICAgICByZW1vdmVJbWFnZUhvdmVyKCk7XG4gICAgICAgIGFkZEhvdmVyUHJvamVjdChwcm9qZWN0KTtcbiAgICB9KTtcbiAgICBwcm9qZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQ7XG4gICAgICAgIHJlbW92ZVNvbWV0aGluZ1Byb2plY3QocHJvamVjdCk7XG4gICAgfSk7XG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmVtb3ZlIEFjdGl2ZSBTdGF0ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgcmVtb3ZlQWN0aXZlUHJvamVjdCA9ICgpID0+IHtcbiAgICBwcm9qZWN0cy5mb3JFYWNoKHByb2plY3QgPT4ge1xuICAgICAgICBwcm9qZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIH0pO1xuICAgIGdhbGxlcmllcy5mb3JFYWNoKGdhbGxlcnkgPT4ge1xuICAgICAgICBnYWxsZXJ5LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIH0pO1xufVxuXG5jb25zdCByZW1vdmVTb21ldGhpbmdQcm9qZWN0ID0gKHByb2plY3QpID0+IHtcbiAgICAgICAgY29uc3QgaHJlZiA9IHByb2plY3QuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nU2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaHJlZik7XG5cbiAgICAgICAgaWYgKHByb2plY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdpcy1ob3ZlcicpKSB7XG4gICAgICAgICAgICBwcm9qZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhvdmVyJyk7XG4gICAgICAgICAgICBtYXRjaGluZ1NlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtaG92ZXInKTtcbiAgICAgICAgICAgIG1hdGNoaW5nU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyX2ltYWdlc19fZ2FsbGVyeScpLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQWRkIEFjdGl2ZSBTdGF0ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgYWRkQWN0aXZlUHJvamVjdCA9IHByb2plY3QgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSBwcm9qZWN0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGNvbnN0IG1hdGNoaW5nU2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaHJlZik7XG5cbiAgICAvLyBQcm9qZWN0IExpc3RcbiAgICBwcm9qZWN0LmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuICAgIHByb2plY3QuY2xhc3NMaXN0LnJlbW92ZSgnaXMtaG92ZXInKTtcblxuICAgIC8vIFByb2plY3QgR2FsbGVyeSBJdGVtXG4gICAgbWF0Y2hpbmdTZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuICAgIG1hdGNoaW5nU2VjdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1ob3ZlcicpO1xuXG4gICAgLy8gU2hvdyBQcm9qZWN0IEdhbGxlcnkgSXRlbVxuICAgIG1hdGNoaW5nU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyX2ltYWdlc19faW5mbycpLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgbWF0Y2hpbmdTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXJfaW1hZ2VzX19nYWxsZXJ5Jykuc3R5bGUub3BhY2l0eSA9ICcxJztcblxuICAgIC8vIFJlZHVjZSBPcGFjaXR5IE9uIE1haW4gQ29udGFpbmVyXG4gICAgY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMC4xJztcbn1cblxuY29uc3QgY2xpY2tPdXRzaWRlID0gcHJvamVjdCA9PiB7XG4gICAgY29uc3QgaHJlZiA9IHByb2plY3QuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgY29uc3QgbWF0Y2hpbmdTZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihocmVmKTtcblxuICAgIG1hdGNoaW5nU2VjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyB0aGlzIHNlbGVjdCB0aGUgbWF0Y2hpbmdTZWN0aW9uIGNoaWxkXG4gICAgICAgIGxldCBmbHlvdXRFbGVtZW50ID0gbWF0Y2hpbmdTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXJfaW1hZ2VzX19nYWxsZXJ5JyksXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gZXZ0LnRhcmdldDsgLy8gY2xpY2tlZCBlbGVtZW50XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQgPT0gZmx5b3V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjbGljayBpbnNpZGUuIERvIG5vdGhpbmcsIGp1c3QgcmV0dXJuLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGlja2VkIGluc2lkZSEnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHbyB1cCB0aGUgRE9NXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9IHdoaWxlICh0YXJnZXRFbGVtZW50KTtcblxuICAgICAgICAvLyBUaGlzIGlzIGEgY2xpY2sgb3V0c2lkZS5cbiAgICAgICAgbWF0Y2hpbmdTZWN0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgICAgICBtYXRjaGluZ1NlY3Rpb24ucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcl9pbWFnZXNfX2luZm8nKS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBtYXRjaGluZ1NlY3Rpb24ucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcl9pbWFnZXNfX2dhbGxlcnknKS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgICAgcHJvamVjdC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcblxuICAgICAgICAvLyByZWluaXRpYXRlIHRoZSBjYXJvdXNlbCB0byB0aGUgZmlyc3Qgc2xpZGUgZm9yIDFzIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2Fyb3VzZWwuc2VsZWN0Q2VsbCgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmbGlja2l0eSBpcyByZWluaXRpYXRlJyk7XG4gICAgICAgIH0sIDcwMCk7XG4gICAgfSk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBSZW1vdmUgSG92ZXIgU3RhdGVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IHJlbW92ZUhvdmVyUHJvamVjdCA9ICgpID0+IHtcbiAgICBwcm9qZWN0cy5mb3JFYWNoKHByb2plY3QgPT4ge1xuICAgICAgICBwcm9qZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhvdmVyJyk7XG4gICAgfSk7XG4gICAgZ2FsbGVyaWVzLmZvckVhY2goZ2FsbGVyeSA9PiB7XG4gICAgICAgIGdhbGxlcnkuY2xhc3NMaXN0LnJlbW92ZSgnaXMtaG92ZXInKTtcbiAgICAgICAgZ2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyX2ltYWdlc19fZ2FsbGVyeScpLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgfSk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEFkZCBIb3ZlciBTdGF0ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgYWRkSG92ZXJQcm9qZWN0ID0gcHJvamVjdCA9PiB7XG4gICAgcHJvamVjdC5jbGFzc0xpc3QuYWRkKCdpcy1ob3ZlcicpO1xuICAgIGNvbnN0IGhyZWYgPSBwcm9qZWN0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGNvbnN0IG1hdGNoaW5nU2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaHJlZik7XG4gICAgbWF0Y2hpbmdTZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ2lzLWhvdmVyJyk7XG4gICAgbWF0Y2hpbmdTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXJfaW1hZ2VzX19nYWxsZXJ5Jykuc3R5bGUub3BhY2l0eSA9ICcwLjMnO1xufVxuXG5jb25zdCByZW1vdmVJbWFnZUhvdmVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSBwcm9qZWN0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGNvbnN0IG1hdGNoaW5nU2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaHJlZik7XG5cbiAgICBpZiAocHJvamVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ2lzLWhvdmVyJykpIHtcbiAgICAgICAgcHJvamVjdC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1ob3ZlcicpO1xuICAgICAgICBtYXRjaGluZ1NlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtaG92ZXInKTtcbiAgICAgICAgbWF0Y2hpbmdTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXJfaW1hZ2VzX19nYWxsZXJ5Jykuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICB9XG59XG4iLCIvKlxuICogcGx1Z2luIHNpbXBsZUJhciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9HcnNtdG8vc2ltcGxlYmFyL3RyZWUvbWFzdGVyL3BhY2thZ2VzL3NpbXBsZWJhclxuICogb24gc3R5bGlzZSBsYSBiYXIgZGUgc2Nyb2xsIGF2ZWMgbGEgY2xhc3MgLnNpbXBsZWJhci1zY3JvbGxiYXJcbiAqIC5zaW1wbGViYXItc2Nyb2xsYmFyLXRodW1iXG4gKi9cbmltcG9ydCBTaW1wbGVCYXIgZnJvbSAnc2ltcGxlYmFyJztcblxubmV3IFNpbXBsZUJhcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyX19wcm9qZWN0cycpLCB7XG4gICAgZGlyZWN0aW9uOiAncnRsJ1xufSk7XG4iLCJpbXBvcnQgJy4vY29tcG9uZW50cy9uYXYnO1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvc2Nyb2xsQmFyJztcbmltcG9ydCAnLi9jb21wb25lbnRzL3Byb2plY3QnO1xuXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=